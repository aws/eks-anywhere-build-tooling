package fixpatches

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/google/go-github/v53/github"
	"golang.org/x/oauth2"

	"github.com/aws/eks-anywhere-build-tooling/tools/version-tracker/pkg/constants"
	"github.com/aws/eks-anywhere-build-tooling/tools/version-tracker/pkg/util/logger"
)

// GitHubClient wraps GitHub API operations for patch fixing.
type GitHubClient struct {
	client *github.Client
	owner  string
	repo   string
}

// NewGitHubClient creates a new GitHub client for patch fixing operations.
func NewGitHubClient() (*GitHubClient, error) {
	githubToken, ok := os.LookupEnv(constants.GitHubTokenEnvvar)
	if !ok {
		return nil, fmt.Errorf("GITHUB_TOKEN environment variable is not set")
	}

	ctx := context.Background()
	ts := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: githubToken})
	tc := oauth2.NewClient(ctx, ts)
	client := github.NewClient(tc)

	return &GitHubClient{
		client: client,
		owner:  constants.AWSOrgName,
		repo:   constants.BuildToolingRepoName,
	}, nil
}

// CommentOnPR adds a comment to a pull request.
func (g *GitHubClient) CommentOnPR(prNumber int, comment string) error {
	logger.Info("Adding comment to PR", "pr", prNumber)

	prComment := &github.IssueComment{
		Body: github.String(comment),
	}

	_, _, err := g.client.Issues.CreateComment(
		context.Background(),
		g.owner,
		g.repo,
		prNumber,
		prComment,
	)

	if err != nil {
		return fmt.Errorf("creating comment on PR #%d: %v", prNumber, err)
	}

	logger.Info("Successfully commented on PR", "pr", prNumber)
	return nil
}

// FormatSuccessComment creates a formatted success comment for a PR.
func FormatSuccessComment(project string, patchesFixed []string) string {
	var sb strings.Builder

	sb.WriteString("## ✅ Patches Fixed Successfully\n\n")
	sb.WriteString(fmt.Sprintf("The patch fixer automatically resolved conflicts for **%s**.\n\n", project))

	sb.WriteString("### Fixed Patches\n")
	for _, patch := range patchesFixed {
		sb.WriteString(fmt.Sprintf("- ✅ `%s`\n", patch))
	}

	sb.WriteString("\n### Next Steps\n")
	sb.WriteString("- Review the fixed patches to ensure they match the original intent\n")
	sb.WriteString("- Run tests to validate the changes\n")

	sb.WriteString("\n---\n")
	sb.WriteString("*This comment was automatically generated by the patch fixer*\n")

	return sb.String()
}

// FormatFailureComment creates a formatted failure comment for a PR.
func FormatFailureComment(project string, failedPatches []string) string {
	var sb strings.Builder

	sb.WriteString("## ❌ Automatic Patch Fixing Failed\n\n")
	sb.WriteString(fmt.Sprintf("The patch fixer was unable to automatically resolve conflicts for **%s**.\n\n", project))

	sb.WriteString("### Failed Patches\n")
	for _, patch := range failedPatches {
		sb.WriteString(fmt.Sprintf("- ❌ `%s`\n", patch))
	}

	sb.WriteString("\n**Manual intervention required** - please review and fix the patches.\n")

	sb.WriteString("\n---\n")
	sb.WriteString("*This comment was automatically generated by the patch fixer*\n")

	return sb.String()
}

// CommitAndPush commits fixed patches and pushes to the PR branch.
func CommitAndPush(projectPath, branchName, commitMessage string) error {
	logger.Info("Committing and pushing fixed patches", "branch", branchName)

	// Configure git user
	gitUserName := os.Getenv(constants.CommitAuthorNameEnvvar)
	if gitUserName == "" {
		gitUserName = "prow"
	}

	gitUserEmail := os.Getenv(constants.CommitAuthorEmailEnvvar)
	if gitUserEmail == "" {
		gitUserEmail = "prow@amazonaws.com"
	}

	// Set git config
	if err := runGitCommand(projectPath, "config", "user.name", gitUserName); err != nil {
		return fmt.Errorf("setting git user.name: %v", err)
	}

	if err := runGitCommand(projectPath, "config", "user.email", gitUserEmail); err != nil {
		return fmt.Errorf("setting git user.email: %v", err)
	}

	// Stage all changes in patches directory
	if err := runGitCommand(projectPath, "add", "patches/"); err != nil {
		return fmt.Errorf("staging patches: %v", err)
	}

	// Commit changes
	if err := runGitCommand(projectPath, "commit", "-m", commitMessage); err != nil {
		// Check if there's nothing to commit
		if strings.Contains(err.Error(), "nothing to commit") {
			logger.Info("No changes to commit")
			return nil
		}
		return fmt.Errorf("committing changes: %v", err)
	}

	// Push to remote
	if err := runGitCommand(projectPath, "push", "origin", branchName); err != nil {
		return fmt.Errorf("pushing to remote: %v", err)
	}

	logger.Info("Successfully pushed fixed patches", "branch", branchName)
	return nil
}

// runGitCommand executes a git command in the specified directory.
func runGitCommand(dir string, args ...string) error {
	cmd := exec.Command("git", args...)
	cmd.Dir = dir
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("git %v failed: %v\nOutput: %s", args, err, string(output))
	}
	return nil
}
