package fixpatches

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/google/go-github/v53/github"
	"golang.org/x/oauth2"

	"github.com/aws/eks-anywhere-build-tooling/tools/version-tracker/pkg/constants"
	"github.com/aws/eks-anywhere-build-tooling/tools/version-tracker/pkg/util/logger"
)

// GitHubClient wraps GitHub API operations for patch fixing.
type GitHubClient struct {
	client *github.Client
	owner  string
	repo   string
}

// NewGitHubClient creates a new GitHub client for patch fixing operations.
func NewGitHubClient() (*GitHubClient, error) {
	githubToken, ok := os.LookupEnv(constants.GitHubTokenEnvvar)
	if !ok {
		return nil, fmt.Errorf("GITHUB_TOKEN environment variable is not set")
	}

	ctx := context.Background()
	ts := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: githubToken})
	tc := oauth2.NewClient(ctx, ts)
	client := github.NewClient(tc)

	return &GitHubClient{
		client: client,
		owner:  constants.AWSOrgName,
		repo:   constants.BuildToolingRepoName,
	}, nil
}

// CommentOnPR adds a comment to a pull request.
func (g *GitHubClient) CommentOnPR(prNumber int, comment string) error {
	logger.Info("Adding comment to PR", "pr", prNumber)

	prComment := &github.IssueComment{
		Body: github.String(comment),
	}

	_, _, err := g.client.Issues.CreateComment(
		context.Background(),
		g.owner,
		g.repo,
		prNumber,
		prComment,
	)

	if err != nil {
		return fmt.Errorf("creating comment on PR #%d: %v", prNumber, err)
	}

	logger.Info("Successfully commented on PR", "pr", prNumber)
	return nil
}

// FormatSuccessComment creates a formatted success comment for a PR.
// llmFixedPatches: patches that were actually fixed by LLM (had conflicts)
// cleanPatches: patches that applied cleanly without LLM intervention
func FormatSuccessComment(project string, llmFixedPatches []string, cleanPatches []string) string {
	var sb strings.Builder

	sb.WriteString("## ‚úÖ Patches Fixed Successfully\n\n")
	sb.WriteString(fmt.Sprintf("The patch fixer automatically resolved conflicts for **%s**.\n\n", project))

	if len(llmFixedPatches) > 0 {
		sb.WriteString("### üîß Fixed by LLM\n")
		sb.WriteString("These patches had conflicts that were resolved by the LLM:\n")
		for _, patch := range llmFixedPatches {
			sb.WriteString(fmt.Sprintf("- ‚úÖ `%s`\n", patch))
		}
		sb.WriteString("\n")
	}

	if len(cleanPatches) > 0 {
		sb.WriteString("### ‚úì Applied Cleanly\n")
		sb.WriteString("These patches applied without conflicts:\n")
		for _, patch := range cleanPatches {
			sb.WriteString(fmt.Sprintf("- `%s`\n", patch))
		}
		sb.WriteString("\n")
	}

	sb.WriteString("### Next Steps\n")
	sb.WriteString("- Review the fixed patches to ensure they match the original intent\n")
	sb.WriteString("- Run tests to validate the changes\n")

	sb.WriteString("\n---\n")
	sb.WriteString("*This comment was automatically generated by the patch fixer*\n")

	return sb.String()
}

// FormatFailureComment creates a formatted failure comment for a PR.
func FormatFailureComment(project string, failedPatches []string) string {
	var sb strings.Builder

	sb.WriteString("## ‚ùå Automatic Patch Fixing Failed\n\n")
	sb.WriteString(fmt.Sprintf("The patch fixer was unable to automatically resolve conflicts for **%s**.\n\n", project))

	sb.WriteString("### Failed Patches\n")
	for _, patch := range failedPatches {
		sb.WriteString(fmt.Sprintf("- ‚ùå `%s`\n", patch))
	}

	sb.WriteString("\n**Manual intervention required** - please review and fix the patches.\n")

	sb.WriteString("\n---\n")
	sb.WriteString("*This comment was automatically generated by the patch fixer*\n")

	return sb.String()
}

// CommitAndPush commits fixed patches and pushes to the PR branch.
func CommitAndPush(projectPath, branchName, commitMessage string) error {
	logger.Info("Committing and pushing fixed patches", "branch", branchName)

	// Configure git user
	gitUserName := os.Getenv(constants.CommitAuthorNameEnvvar)
	if gitUserName == "" {
		gitUserName = "prow"
	}

	gitUserEmail := os.Getenv(constants.CommitAuthorEmailEnvvar)
	if gitUserEmail == "" {
		gitUserEmail = "prow@amazonaws.com"
	}

	// Set git config
	if err := GitConfig(projectPath, "user.name", gitUserName); err != nil {
		return fmt.Errorf("setting git user.name: %v", err)
	}

	if err := GitConfig(projectPath, "user.email", gitUserEmail); err != nil {
		return fmt.Errorf("setting git user.email: %v", err)
	}

	// Stage all changes in patches directory
	if err := GitAdd(projectPath, "patches/"); err != nil {
		return fmt.Errorf("staging patches: %v", err)
	}

	// Stage CHECKSUMS if it exists and was modified
	// ValidateBuild stages this file, but we need to ensure it's included in the commit
	checksumsPath := filepath.Join(projectPath, "CHECKSUMS")
	if _, err := os.Stat(checksumsPath); err == nil {
		if err := GitAdd(projectPath, "CHECKSUMS"); err != nil {
			logger.Info("Warning: failed to stage CHECKSUMS", "error", err)
		}
	}

	// Stage expected-artifacts if it exists and was modified
	expectedArtifactsPath := filepath.Join(projectPath, "expected-artifacts")
	if _, err := os.Stat(expectedArtifactsPath); err == nil {
		if err := GitAdd(projectPath, "expected-artifacts"); err != nil {
			logger.Info("Warning: failed to stage expected-artifacts", "error", err)
		}
	}

	// Stage ATTRIBUTION files if they exist
	// These are generated during build and may change when patches are fixed
	attributionFiles := []string{
		"ATTRIBUTION.txt",
		"*_ATTRIBUTION.txt", // e.g., INIT_ATTRIBUTION.txt, SERVICE_ATTRIBUTION.txt
	}
	for _, pattern := range attributionFiles {
		matches, err := filepath.Glob(filepath.Join(projectPath, pattern))
		if err != nil {
			logger.Info("Warning: failed to glob attribution files", "pattern", pattern, "error", err)
			continue
		}
		for _, match := range matches {
			relPath, _ := filepath.Rel(projectPath, match)
			if err := GitAdd(projectPath, relPath); err != nil {
				logger.Info("Warning: failed to stage attribution file", "file", relPath, "error", err)
			}
		}
	}

	// Commit changes (GitCommit handles "nothing to commit" case)
	if err := GitCommit(projectPath, commitMessage); err != nil {
		return fmt.Errorf("committing changes: %v", err)
	}

	// Push to remote
	if _, err := GitCommand(projectPath, "push", "origin", branchName); err != nil {
		return fmt.Errorf("pushing to remote: %v", err)
	}

	logger.Info("Successfully pushed fixed patches", "branch", branchName)
	return nil
}
