#!/usr/bin/env bash
# Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -o errexit
set -o nounset
set -o pipefail

SCRIPT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/" && pwd -P)"
BUILD_LIB_ROOT="$(cd "$(dirname $(realpath "${BASH_SOURCE[0]}"))/.." && pwd -P)"

source "${BUILD_LIB_ROOT}/common.sh"

# go $GOBUILD_COMMAND -trimpath -a -ldflags "$GO_LDFLAGS" $EXTRA_GOBUILD_FLAGS -o $TARGET_FILE $SOURCE_PATTERN

PROJECT_MOUNT=$(realpath .)
GOLANG_VERSION=$(cat $SCRIPT_ROOT/.goversion)
USE_DOCKER=$(cat $SCRIPT_ROOT/.usedocker)

CONTAINER_IMAGE="public.ecr.aws/k1e6s8o8/eks-distro-minimal-base-golang:${GOLANG_VERSION}-foo.2"

EXTRA_MOUNTS=""
ARGS=()
GO_BUILD_ARGS="go "
while test $# -gt 0; do
  case "$1" in
    -o)
        shift
        TARGET_FILE=$1
        OUTPUT_MOUNT=$(dirname $(realpath $TARGET_FILE))
        OUTPUT_FILE=$(basename $TARGET_FILE)
        if [ -d $TARGET_FILE ]; then
            OUTPUT_MOUNT=$TARGET_FILE
            OUTPUT_FILE=
        fi
        EXTRA_MOUNTS="--mount type=bind,source=$OUTPUT_MOUNT,target=/output"
        ARGS+=("-o" "/output/$OUTPUT_FILE")
        GO_BUILD_ARGS+="-o /output/$OUTPUT_FILE "
        shift
        ;;
    *)        
        ARGS+=("$1")
        GO_BUILD_ARGS+="\"$1\" "
        shift
        ;;
  esac
done

if [[ "$USE_DOCKER" = "true" ]] ; then
    USER_ID=""
    if [ "$(uname -s)" = "Linux" ]; then
        USER_ID="-u $(id -u ${USER}):$(id -g ${USER})"
    fi

    docker run \
        --mount type=bind,source=$PROJECT_MOUNT,target=/project $EXTRA_MOUNTS -w /project \
        --mount type=bind,source=$GOCACHE,target=/.cache/build \
        --mount type=bind,source=$GOMODCACHE,target=/.cache/mod $USER_ID \
        -e CGO_ENABLED=${CGO_ENABLED:-0} -e GOOS=${GOOS:-} -e GOARCH=${GOARCH:-} -e GOPROXY=${GOPROXY:-direct} \
        -e GOCACHE=/.cache/build -e GOMODCACHE=/.cache/mod \
        $CONTAINER_IMAGE go "${ARGS[@]}"
    exit $?
fi

DOCKERFILE_DIR=$(mktemp -d)
trap "rm -rf $DOCKERFILE_DIR" EXIT

OUTPUT_MOUNT=${OUTPUT_MOUNT:-$PROJECT_MOUNT}

CONTEXT=$(build::common::longest_common_prefix $PROJECT_MOUNT $OUTPUT_MOUNT)
RELATIVE_PROJECT_MOUNT=$(realpath --relative-to=$CONTEXT $PROJECT_MOUNT)
RELATIVE_OUTPUT_MOUNT=$(realpath --relative-to=$CONTEXT $OUTPUT_MOUNT)
RELATIVE_GOCACHE_MOUNT=$(realpath --relative-to=$CONTEXT $GOCACHE)
RELATIVE_GOMODCACHE_MOUNT=$(realpath --relative-to=$CONTEXT $GOMODCACHE)

LOG_FILE=$(mktemp)
trap "rm -f $LOG_FILE" EXIT
#BUILDCTL_OUTPUT="2>&1 > $LOG_FILE"
if [[ $GO_BUILD_ARGS == *"go \"mod\" \"vendor\""* ]]; then
    TARGET="vendor"
    #BUILDCTL_OUTPUT=""
    cat << EOF > $DOCKERFILE_DIR/Dockerfile.dockerignore
*
!$RELATIVE_PROJECT_MOUNT/go.mod
!$RELATIVE_PROJECT_MOUNT/go.sum
!$RELATIVE_PROJECT_MOUNT/*.go
EOF

elif [[ $GO_BUILD_ARGS == *"go \"build\""* ]]; then
    TARGET="build"
    #BUILDCTL_OUTPUT=""
    cat << EOF > $DOCKERFILE_DIR/Dockerfile.dockerignore
*
!$RELATIVE_PROJECT_MOUNT
EOF

elif [[ $GO_BUILD_ARGS == *"go \"list\""* ]]; then
    TARGET="list"
    cat << EOF > $DOCKERFILE_DIR/Dockerfile.dockerignore
*
!$RELATIVE_PROJECT_MOUNT
EOF

elif [[ $GO_BUILD_ARGS == *"go \"mod\" \"edit\""* ]]; then
    TARGET="mod-edit"
    cat << EOF > $DOCKERFILE_DIR/Dockerfile.dockerignore
*
!$RELATIVE_PROJECT_MOUNT/go.mod
!$RELATIVE_PROJECT_MOUNT/go.sum
!$RELATIVE_PROJECT_MOUNT/*.go
EOF

else
    echo "unexpected go subcommand: ${GO_BUILD_ARGS}"
    exit 1
fi

cat << EOF > $DOCKERFILE_DIR/Dockerfile
FROM $CONTAINER_IMAGE AS run

ENV GOCACHE /.cache/build
ENV GOMODCACHE /.cache/mod
ENV CGO_ENABLED ${CGO_ENABLED:-0}
ENV GOOS ${GOOS:-linux}
ENV GOARCH ${GOARCH:-amd64}
ENV GOPROXY ${GOPROXY:-direct}

WORKDIR /project
RUN --mount=type=bind,source=$RELATIVE_PROJECT_MOUNT,target=/project,rw \
    --mount=type=cache,target=/.cache/build \
    --mount=type=cache,target=/.cache/mod \
    $GO_BUILD_ARGS | tee /build-output && \
    if [[ "$TARGET" = "vendor" ]]; then cp -rf /project/vendor /; fi

FROM scratch as vendor
COPY --from=run /vendor $RELATIVE_PROJECT_MOUNT/vendor/

FROM scratch as build
COPY --from=run /output/* $RELATIVE_OUTPUT_MOUNT/

FROM scratch as list
COPY --from=run /build-output ./

FROM scratch as mod-edit
COPY --from=run /build-output ./
EOF



if ! $BUILD_LIB_ROOT/buildkit.sh build \
    --frontend dockerfile.v0 \
    --local dockerfile=$DOCKERFILE_DIR \
    --local context=$CONTEXT \
    --progress plain \
    --opt target=$TARGET \
    --output type=local,dest=$CONTEXT > $LOG_FILE 2>&1; then
    
    cat $LOG_FILE
    exit 1
fi

if [[ -f  "$CONTEXT/build-output" ]]; then
    cat $CONTEXT/build-output
    rm $CONTEXT/build-output
fi

if [[ "$TARGET" = "build" ]]; then
    # buildctl caches so if the binary hasnt changed it will have an older timestamp
    touch $OUTPUT_MOUNT/*
fi
