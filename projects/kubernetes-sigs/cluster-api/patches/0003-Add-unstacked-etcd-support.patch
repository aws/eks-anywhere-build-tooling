From 37167cf4d6263da6eeb9bb98fbaf9f1a72b4a208 Mon Sep 17 00:00:00 2001
From: Rajashree Mandaogane <mandaor@amazon.com>
Date: Mon, 28 Jun 2021 13:44:50 -0700
Subject: [PATCH 03/18] Add unstacked etcd support

Unstacked etcd: API and config changes

Unstacked etcd: Changes in CAPI core controllers

This commit adds the following changes in the cluster controller:
* A change in reconcileControlPlane to check if the cluster is using managed
external etcd, and if etcd is not ready then pause the control plane provisioning.
* A new phase in cluster controller's phases for reconciling the etcd cluster. If the
etcd cluster is ready then this phase will resume control plane provisioning

This commit also adds the following change in the machine controller:
* The machine controller upon creation of the first etcd machine will save its IP.

Unstacked etcd: Changes in KCP controller

The KubeadmControlPlane controller will get the external etcd endpoints
from the object referenced by cluster.spec.managedExternalEtcdRef.
The validating webhook will allow the external etcd endpoints to be updated.

Unstacked etcd: Change in docker infra provider

Docker is the only infrastructure provider that performs a kubectl patch on the k8s
node corresponding to a Machine. This needs to be skipped for etcd machines since they
are not registered as nodes and do not run kubelet.

Unstacked etcd: Ignore nodeRef check for etcd machines during clusterctl move

Clusterctl before beginning the move checks if all CAPI objects are
ready and provisioned. One of these checks is for Machine.Status.NodeRef field.
This check needs to be skipped for etcd machines since they are not registered
as Kubernetes nodes so they don't have a corresponding Node.

Delete managed external etcd cluster last

Update KCP controller to use renamed etcd endpoints field

The field 'endpoint' on EtcdadmCluster's status has been renamed
to 'endpoints'. This commit updates the KCP controller to use the
renamed field

cr https://code.amazon.com/reviews/CR-54310674

Add external etcd api changes to v1beta1 capi CRDs

Fix etcdMachine to cluster reconciler so it listens on Machine events

cr: https://code.amazon.com/reviews/CR-56463335

Add external etcd api to v1alpha4

Fix watch on machine object for etcdMachine to cluster mapper

While cherry-picking commits from 0.3.19 branch the watch got modified
by mistake. This commit fixes it by changing it back to watching Machine
objects.

Retain update permission on etcdadmcluster for KCP controller

KCP controller updates the etcdadmcluster object once KCP upgrade is completed.
It needs update permission on etcdadmcluster object for this.
We previously had added this permission, it got dropped while rebasing
commits on the new 1.0.1 branch. This commit adds back the permission.
---
 .../kubeadm/v1beta1/kubeadm_types.go          |  19 +
 .../v1beta1/zz_generated.conversion.go        |  44 ++
 .../kubeadm/v1beta1/zz_generated.deepcopy.go  |  17 +
 .../kubeadm/v1beta2/kubeadm_types.go          |  21 +
 .../kubeadm/v1beta2/zz_generated.deepcopy.go  |  17 +
 .../kubeadm/v1beta1/condition_consts.go       |   8 +
 .../v1beta2/kubeadm_control_plane_types.go    |   8 +
 api/core/v1beta1/cluster_types.go             |  14 +
 api/core/v1beta1/common_types.go              |   7 +
 api/core/v1beta1/condition_consts.go          |  16 +
 api/core/v1beta1/machine_types.go             |   2 +
 api/core/v1beta1/zz_generated.conversion.go   |   6 +
 api/core/v1beta1/zz_generated.deepcopy.go     |   5 +
 api/core/v1beta1/zz_generated.openapi.go      |  22 +
 api/core/v1beta2/cluster_types.go             |  14 +
 api/core/v1beta2/common_types.go              |   7 +
 api/core/v1beta2/condition_consts.go          |  19 +
 api/core/v1beta2/machine_types.go             |   3 +
 api/core/v1beta2/zz_generated.deepcopy.go     |   1 +
 api/core/v1beta2/zz_generated.openapi.go      |  23 +
 ...strap.cluster.x-k8s.io_kubeadmconfigs.yaml |  78 ++++
 ...uster.x-k8s.io_kubeadmconfigtemplates.yaml |  84 ++++
 .../internal/bottlerocket/bootstrap.go        |  21 +-
 .../internal/bottlerocket/bottlerocket.go     |  29 +-
 .../bottlerocket/controlplane_join.go         |   6 +
 .../controllers/kubeadmconfig_controller.go   |   9 +
 .../types/upstreamv1beta3/conversion.go       |  24 ++
 .../kubeadm/types/upstreamv1beta3/types.go    |  72 ++++
 .../zz_generated.conversion.go                | 160 ++++++-
 .../upstreamv1beta3/zz_generated.deepcopy.go  |  75 ++++
 .../zz_generated.conversion.go                |   2 +
 cmd/clusterctl/client/cluster/mover.go        |   5 +-
 .../crd/bases/cluster.x-k8s.io_clusters.yaml  | 207 +++++++++
 config/rbac/role.yaml                         |   1 +
 controllers/external/util.go                  |  49 +++
 ...cluster.x-k8s.io_kubeadmcontrolplanes.yaml |  84 ++++
 ...x-k8s.io_kubeadmcontrolplanetemplates.yaml |  84 ++++
 controlplane/kubeadm/config/rbac/role.yaml    |   9 +
 .../internal/controllers/controller.go        | 128 +++++-
 .../internal/controllers/controller_test.go   | 214 +++++++++-
 .../webhooks/kubeadm_control_plane.go         |   4 +
 .../webhooks/kubeadm_control_plane_test.go    |  36 ++
 .../kubeadm/internal/workload_cluster.go      |   1 +
 .../kubeadm/internal/workload_cluster_etcd.go |   9 +
 .../v1alpha3/zz_generated.conversion.go       |   2 +
 .../kubeadm/v1alpha4/kubeadm_types.go         |  19 +
 .../v1alpha4/zz_generated.conversion.go       |  44 ++
 .../kubeadm/v1alpha4/zz_generated.deepcopy.go |  17 +
 internal/api/core/v1alpha3/cluster_types.go   |  14 +
 internal/api/core/v1alpha3/common_types.go    |   7 +
 .../api/core/v1alpha3/condition_consts.go     |  26 ++
 internal/api/core/v1alpha3/conversion.go      |   9 +
 internal/api/core/v1alpha3/machine_types.go   |   3 +
 .../core/v1alpha3/zz_generated.conversion.go  |   6 +
 .../core/v1alpha3/zz_generated.deepcopy.go    |   5 +
 internal/api/core/v1alpha4/cluster_types.go   |  14 +
 internal/api/core/v1alpha4/common_types.go    |   7 +
 .../api/core/v1alpha4/condition_consts.go     |  26 ++
 internal/api/core/v1alpha4/machine_types.go   |   3 +
 .../core/v1alpha4/zz_generated.conversion.go  |   6 +
 .../core/v1alpha4/zz_generated.deepcopy.go    |   5 +
 .../controllers/cluster/cluster_controller.go |  85 +++-
 .../cluster/cluster_controller_phases.go      | 127 ++++++
 .../cluster/cluster_controller_test.go        | 392 ++++++++++++++++++
 .../machine/machine_controller_noderef.go     |   8 +
 .../machine_controller_noderef_test.go        |  45 ++
 .../machine/machine_controller_phases.go      | 117 ++++++
 .../machine/machine_controller_status.go      |   7 +
 util/annotations/helpers.go                   |   5 +
 util/collections/machine_filters.go           |  26 ++
 util/secret/certificates.go                   |   3 +
 util/secret/consts.go                         |   2 +
 util/test/builder/builders.go                 |   7 +
 util/test/builder/etcd.go                     |  80 ++++
 util/test/builder/zz_generated.deepcopy.go    |  23 +
 util/util.go                                  |   6 +
 76 files changed, 2784 insertions(+), 26 deletions(-)
 create mode 100644 util/test/builder/etcd.go

diff --git a/api/bootstrap/kubeadm/v1beta1/kubeadm_types.go b/api/bootstrap/kubeadm/v1beta1/kubeadm_types.go
index 6d1c8f0..5ae15a6 100644
--- a/api/bootstrap/kubeadm/v1beta1/kubeadm_types.go
+++ b/api/bootstrap/kubeadm/v1beta1/kubeadm_types.go
@@ -92,6 +92,11 @@ type ClusterConfiguration struct {
 	// +optional
 	Proxy ProxyConfiguration `json:"proxy,omitempty"`
 
+	// RegistryMirror holds the image registry mirror information
+	// This is only for bottlerocket
+	// +optional
+	RegistryMirror RegistryMirrorConfiguration `json:"registryMirror,omitempty"`
+
 	// etcd holds configuration for etcd.
 	// NB: This value defaults to a Local (stacked) etcd
 	// +optional
@@ -199,6 +204,15 @@ type ProxyConfiguration struct {
 	NoProxy []string `json:"noProxy,omitempty"`
 }
 
+// RegistryMirrorConfiguration holds the settings for image registry mirror
+type RegistryMirrorConfiguration struct {
+	// Endpoint defines the registry mirror endpoint to use for pulling images
+	Endpoint string `json:"endpoint,omitempty"`
+
+	// CACert defines the CA cert for the registry mirror
+	CACert string `json:"caCert,omitempty"`
+}
+
 // ControlPlaneComponent holds settings common to control plane component of the cluster.
 type ControlPlaneComponent struct {
 	// extraArgs is an extra set of flags to pass to the control plane component.
@@ -561,6 +575,11 @@ type JoinConfiguration struct {
 	// +optional
 	Proxy ProxyConfiguration `json:"proxy,omitempty"`
 
+	// RegistryMirror holds the image registry mirror information
+	// This is only for bottlerocket
+	// +optional
+	RegistryMirror RegistryMirrorConfiguration `json:"registryMirror,omitempty"`
+
 	// nodeRegistration holds fields that relate to registering the new control-plane node to the cluster.
 	// When used in the context of control plane nodes, NodeRegistration should remain consistent
 	// across both InitConfiguration and JoinConfiguration
diff --git a/api/bootstrap/kubeadm/v1beta1/zz_generated.conversion.go b/api/bootstrap/kubeadm/v1beta1/zz_generated.conversion.go
index 3e80833..41aa184 100644
--- a/api/bootstrap/kubeadm/v1beta1/zz_generated.conversion.go
+++ b/api/bootstrap/kubeadm/v1beta1/zz_generated.conversion.go
@@ -300,6 +300,16 @@ func RegisterConversions(s *runtime.Scheme) error {
 	}); err != nil {
 		return err
 	}
+	if err := s.AddGeneratedConversionFunc((*RegistryMirrorConfiguration)(nil), (*v1beta2.RegistryMirrorConfiguration)(nil), func(a, b interface{}, scope conversion.Scope) error {
+		return Convert_v1beta1_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(a.(*RegistryMirrorConfiguration), b.(*v1beta2.RegistryMirrorConfiguration), scope)
+	}); err != nil {
+		return err
+	}
+	if err := s.AddGeneratedConversionFunc((*v1beta2.RegistryMirrorConfiguration)(nil), (*RegistryMirrorConfiguration)(nil), func(a, b interface{}, scope conversion.Scope) error {
+		return Convert_v1beta2_RegistryMirrorConfiguration_To_v1beta1_RegistryMirrorConfiguration(a.(*v1beta2.RegistryMirrorConfiguration), b.(*RegistryMirrorConfiguration), scope)
+	}); err != nil {
+		return err
+	}
 	if err := s.AddGeneratedConversionFunc((*SecretFileSource)(nil), (*v1beta2.SecretFileSource)(nil), func(a, b interface{}, scope conversion.Scope) error {
 		return Convert_v1beta1_SecretFileSource_To_v1beta2_SecretFileSource(a.(*SecretFileSource), b.(*v1beta2.SecretFileSource), scope)
 	}); err != nil {
@@ -694,6 +704,9 @@ func autoConvert_v1beta1_ClusterConfiguration_To_v1beta2_ClusterConfiguration(in
 	if err := Convert_v1beta1_ProxyConfiguration_To_v1beta2_ProxyConfiguration(&in.Proxy, &out.Proxy, s); err != nil {
 		return err
 	}
+	if err := Convert_v1beta1_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(&in.RegistryMirror, &out.RegistryMirror, s); err != nil {
+		return err
+	}
 	if err := Convert_v1beta1_Etcd_To_v1beta2_Etcd(&in.Etcd, &out.Etcd, s); err != nil {
 		return err
 	}
@@ -729,6 +742,9 @@ func autoConvert_v1beta2_ClusterConfiguration_To_v1beta1_ClusterConfiguration(in
 	if err := Convert_v1beta2_ProxyConfiguration_To_v1beta1_ProxyConfiguration(&in.Proxy, &out.Proxy, s); err != nil {
 		return err
 	}
+	if err := Convert_v1beta2_RegistryMirrorConfiguration_To_v1beta1_RegistryMirrorConfiguration(&in.RegistryMirror, &out.RegistryMirror, s); err != nil {
+		return err
+	}
 	if err := Convert_v1beta2_Etcd_To_v1beta1_Etcd(&in.Etcd, &out.Etcd, s); err != nil {
 		return err
 	}
@@ -1144,6 +1160,9 @@ func autoConvert_v1beta1_JoinConfiguration_To_v1beta2_JoinConfiguration(in *Join
 	if err := Convert_v1beta1_ProxyConfiguration_To_v1beta2_ProxyConfiguration(&in.Proxy, &out.Proxy, s); err != nil {
 		return err
 	}
+	if err := Convert_v1beta1_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(&in.RegistryMirror, &out.RegistryMirror, s); err != nil {
+		return err
+	}
 	if err := Convert_v1beta1_NodeRegistrationOptions_To_v1beta2_NodeRegistrationOptions(&in.NodeRegistration, &out.NodeRegistration, s); err != nil {
 		return err
 	}
@@ -1167,6 +1186,9 @@ func autoConvert_v1beta2_JoinConfiguration_To_v1beta1_JoinConfiguration(in *v1be
 	if err := Convert_v1beta2_ProxyConfiguration_To_v1beta1_ProxyConfiguration(&in.Proxy, &out.Proxy, s); err != nil {
 		return err
 	}
+	if err := Convert_v1beta2_RegistryMirrorConfiguration_To_v1beta1_RegistryMirrorConfiguration(&in.RegistryMirror, &out.RegistryMirror, s); err != nil {
+		return err
+	}
 	if err := Convert_v1beta2_NodeRegistrationOptions_To_v1beta1_NodeRegistrationOptions(&in.NodeRegistration, &out.NodeRegistration, s); err != nil {
 		return err
 	}
@@ -1818,6 +1840,28 @@ func Convert_v1beta2_ProxyConfiguration_To_v1beta1_ProxyConfiguration(in *v1beta
 	return autoConvert_v1beta2_ProxyConfiguration_To_v1beta1_ProxyConfiguration(in, out, s)
 }
 
+func autoConvert_v1beta1_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(in *RegistryMirrorConfiguration, out *v1beta2.RegistryMirrorConfiguration, s conversion.Scope) error {
+	out.Endpoint = in.Endpoint
+	out.CACert = in.CACert
+	return nil
+}
+
+// Convert_v1beta1_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration is an autogenerated conversion function.
+func Convert_v1beta1_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(in *RegistryMirrorConfiguration, out *v1beta2.RegistryMirrorConfiguration, s conversion.Scope) error {
+	return autoConvert_v1beta1_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(in, out, s)
+}
+
+func autoConvert_v1beta2_RegistryMirrorConfiguration_To_v1beta1_RegistryMirrorConfiguration(in *v1beta2.RegistryMirrorConfiguration, out *RegistryMirrorConfiguration, s conversion.Scope) error {
+	out.Endpoint = in.Endpoint
+	out.CACert = in.CACert
+	return nil
+}
+
+// Convert_v1beta2_RegistryMirrorConfiguration_To_v1beta1_RegistryMirrorConfiguration is an autogenerated conversion function.
+func Convert_v1beta2_RegistryMirrorConfiguration_To_v1beta1_RegistryMirrorConfiguration(in *v1beta2.RegistryMirrorConfiguration, out *RegistryMirrorConfiguration, s conversion.Scope) error {
+	return autoConvert_v1beta2_RegistryMirrorConfiguration_To_v1beta1_RegistryMirrorConfiguration(in, out, s)
+}
+
 func autoConvert_v1beta1_SecretFileSource_To_v1beta2_SecretFileSource(in *SecretFileSource, out *v1beta2.SecretFileSource, s conversion.Scope) error {
 	out.Name = in.Name
 	out.Key = in.Key
diff --git a/api/bootstrap/kubeadm/v1beta1/zz_generated.deepcopy.go b/api/bootstrap/kubeadm/v1beta1/zz_generated.deepcopy.go
index d73d375..568bdee 100644
--- a/api/bootstrap/kubeadm/v1beta1/zz_generated.deepcopy.go
+++ b/api/bootstrap/kubeadm/v1beta1/zz_generated.deepcopy.go
@@ -165,6 +165,7 @@ func (in *ClusterConfiguration) DeepCopyInto(out *ClusterConfiguration) {
 	out.Pause = in.Pause
 	out.BottlerocketBootstrap = in.BottlerocketBootstrap
 	in.Proxy.DeepCopyInto(&out.Proxy)
+	out.RegistryMirror = in.RegistryMirror
 	in.Etcd.DeepCopyInto(&out.Etcd)
 	out.Networking = in.Networking
 	in.APIServer.DeepCopyInto(&out.APIServer)
@@ -626,6 +627,7 @@ func (in *JoinConfiguration) DeepCopyInto(out *JoinConfiguration) {
 	out.Pause = in.Pause
 	out.BottlerocketBootstrap = in.BottlerocketBootstrap
 	in.Proxy.DeepCopyInto(&out.Proxy)
+	out.RegistryMirror = in.RegistryMirror
 	in.NodeRegistration.DeepCopyInto(&out.NodeRegistration)
 	in.Discovery.DeepCopyInto(&out.Discovery)
 	if in.ControlPlane != nil {
@@ -1310,6 +1312,21 @@ func (in *ProxyConfiguration) DeepCopy() *ProxyConfiguration {
 	return out
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *RegistryMirrorConfiguration) DeepCopyInto(out *RegistryMirrorConfiguration) {
+	*out = *in
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RegistryMirrorConfiguration.
+func (in *RegistryMirrorConfiguration) DeepCopy() *RegistryMirrorConfiguration {
+	if in == nil {
+		return nil
+	}
+	out := new(RegistryMirrorConfiguration)
+	in.DeepCopyInto(out)
+	return out
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *SecretFileSource) DeepCopyInto(out *SecretFileSource) {
 	*out = *in
diff --git a/api/bootstrap/kubeadm/v1beta2/kubeadm_types.go b/api/bootstrap/kubeadm/v1beta2/kubeadm_types.go
index 14862bf..f31154d 100644
--- a/api/bootstrap/kubeadm/v1beta2/kubeadm_types.go
+++ b/api/bootstrap/kubeadm/v1beta2/kubeadm_types.go
@@ -125,6 +125,15 @@ func (r *InitConfiguration) IsDefined() bool {
 	return !reflect.DeepEqual(r, &InitConfiguration{})
 }
 
+// RegistryMirrorConfiguration holds the settings for image registry mirror
+type RegistryMirrorConfiguration struct {
+	// Endpoint defines the registry mirror endpoint to use for pulling images
+	Endpoint string `json:"endpoint,omitempty"`
+
+	// CACert defines the CA cert for the registry mirror
+	CACert string `json:"caCert,omitempty"`
+}
+
 // ClusterConfiguration contains cluster-wide configuration for a kubeadm cluster.
 // +kubebuilder:validation:MinProperties=1
 type ClusterConfiguration struct {
@@ -142,6 +151,12 @@ type ClusterConfiguration struct {
 	// This is only for bottlerocket
 	// +optional
 	Proxy ProxyConfiguration `json:"proxy,omitempty"`
+
+	// RegistryMirror holds the image registry mirror information
+	// This is only for bottlerocket
+	// +optional
+	RegistryMirror RegistryMirrorConfiguration `json:"registryMirror,omitempty"`
+
 	// etcd holds configuration for etcd.
 	// NB: This value defaults to a Local (stacked) etcd
 	// +optional
@@ -669,6 +684,12 @@ type JoinConfiguration struct {
 	// This is only for bottlerocket
 	// +optional
 	Proxy ProxyConfiguration `json:"proxy,omitempty"`
+
+	// RegistryMirror holds the image registry mirror information
+	// This is only for bottlerocket
+	// +optional
+	RegistryMirror RegistryMirrorConfiguration `json:"registryMirror,omitempty"`
+
 	// nodeRegistration holds fields that relate to registering the new control-plane node to the cluster.
 	// When used in the context of control plane nodes, NodeRegistration should remain consistent
 	// across both InitConfiguration and JoinConfiguration
diff --git a/api/bootstrap/kubeadm/v1beta2/zz_generated.deepcopy.go b/api/bootstrap/kubeadm/v1beta2/zz_generated.deepcopy.go
index 33ec37d..33dbb82 100644
--- a/api/bootstrap/kubeadm/v1beta2/zz_generated.deepcopy.go
+++ b/api/bootstrap/kubeadm/v1beta2/zz_generated.deepcopy.go
@@ -200,6 +200,7 @@ func (in *ClusterConfiguration) DeepCopyInto(out *ClusterConfiguration) {
 	out.Pause = in.Pause
 	out.BottlerocketBootstrap = in.BottlerocketBootstrap
 	in.Proxy.DeepCopyInto(&out.Proxy)
+	out.RegistryMirror = in.RegistryMirror
 	in.Etcd.DeepCopyInto(&out.Etcd)
 	in.APIServer.DeepCopyInto(&out.APIServer)
 	in.ControllerManager.DeepCopyInto(&out.ControllerManager)
@@ -566,6 +567,7 @@ func (in *JoinConfiguration) DeepCopyInto(out *JoinConfiguration) {
 	out.Pause = in.Pause
 	out.BottlerocketBootstrap = in.BottlerocketBootstrap
 	in.Proxy.DeepCopyInto(&out.Proxy)
+	out.RegistryMirror = in.RegistryMirror
 	in.NodeRegistration.DeepCopyInto(&out.NodeRegistration)
 	in.Discovery.DeepCopyInto(&out.Discovery)
 	if in.ControlPlane != nil {
@@ -1244,6 +1246,21 @@ func (in *ProxyConfiguration) DeepCopy() *ProxyConfiguration {
 	return out
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *RegistryMirrorConfiguration) DeepCopyInto(out *RegistryMirrorConfiguration) {
+	*out = *in
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RegistryMirrorConfiguration.
+func (in *RegistryMirrorConfiguration) DeepCopy() *RegistryMirrorConfiguration {
+	if in == nil {
+		return nil
+	}
+	out := new(RegistryMirrorConfiguration)
+	in.DeepCopyInto(out)
+	return out
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *Scheduler) DeepCopyInto(out *Scheduler) {
 	*out = *in
diff --git a/api/controlplane/kubeadm/v1beta1/condition_consts.go b/api/controlplane/kubeadm/v1beta1/condition_consts.go
index c460c3a..30c7758 100644
--- a/api/controlplane/kubeadm/v1beta1/condition_consts.go
+++ b/api/controlplane/kubeadm/v1beta1/condition_consts.go
@@ -56,6 +56,14 @@ const (
 	// RollingUpdateInProgressReason (Severity=Warning) documents a KubeadmControlPlane object executing a
 	// rolling upgrade for aligning the machines spec to the desired state.
 	RollingUpdateInProgressReason = "RollingUpdateInProgress"
+
+	// ExternalEtcdEndpointsAvailable documents that the external etcd cluster's endpoints are available, and if KCP spec has changed
+	// then a KCP rollout can progress.
+	ExternalEtcdEndpointsAvailable clusterv1beta1.ConditionType = "ExternalEtcdEndpointsAvailable"
+
+	// ExternalEtcdUndergoingUpgrade (Severity=Info) documents the external etcd cluster being used by current KCP object is
+	// undergoing an upgrade and that the etcd endpoints will change once the upgrade completes
+	ExternalEtcdUndergoingUpgrade = "ExternalEtcdUndergoingUpgrade"
 )
 
 const (
diff --git a/api/controlplane/kubeadm/v1beta2/kubeadm_control_plane_types.go b/api/controlplane/kubeadm/v1beta2/kubeadm_control_plane_types.go
index 95aeb6a..acb9263 100644
--- a/api/controlplane/kubeadm/v1beta2/kubeadm_control_plane_types.go
+++ b/api/controlplane/kubeadm/v1beta2/kubeadm_control_plane_types.go
@@ -413,6 +413,14 @@ const (
 	// KubeadmControlPlaneMachineEtcdMemberDeletingReason surfaces when the machine hosting an etcd member
 	// is being deleted.
 	KubeadmControlPlaneMachineEtcdMemberDeletingReason = "Deleting"
+
+	// ExternalEtcdEndpointsAvailable documents that the external etcd cluster's endpoints are available, and if KCP spec has changed
+	// then a KCP rollout can progress.
+	ExternalEtcdEndpointsAvailable clusterv1.ConditionType = "ExternalEtcdEndpointsAvailable"
+
+	// ExternalEtcdUndergoingUpgrade (Severity=Info) documents the external etcd cluster being used by current KCP object is
+	// undergoing an upgrade and that the etcd endpoints will change once the upgrade completes
+	ExternalEtcdUndergoingUpgrade = "ExternalEtcdUndergoingUpgrade"
 )
 
 // KubeadmControlPlaneSpec defines the desired state of KubeadmControlPlane.
diff --git a/api/core/v1beta1/cluster_types.go b/api/core/v1beta1/cluster_types.go
index c6ff085..2766541 100644
--- a/api/core/v1beta1/cluster_types.go
+++ b/api/core/v1beta1/cluster_types.go
@@ -477,6 +477,11 @@ type ClusterSpec struct {
 	// +optional
 	ControlPlaneRef *corev1.ObjectReference `json:"controlPlaneRef,omitempty"`
 
+	// ManagedExternalEtcdRef is an optional reference to an etcd provider resource that holds details
+	// for provisioning an external etcd cluster
+	// +optional
+	ManagedExternalEtcdRef *corev1.ObjectReference `json:"managedExternalEtcdRef,omitempty"`
+
 	// infrastructureRef is a reference to a provider-specific resource that holds the details
 	// for provisioning infrastructure for a cluster in said provider.
 	// +optional
@@ -992,6 +997,15 @@ type ClusterStatus struct {
 	// +optional
 	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
 
+	// ManagedExternalEtcdInitialized indicates that first etcd member's IP address is set by machine controller,
+	// so remaining etcd members can lookup the address to join the cluster
+	// +optional
+	ManagedExternalEtcdInitialized bool `json:"managedExternalEtcdInitialized"`
+
+	// ManagedExternalEtcdReady indicates external etcd cluster is fully provisioned
+	// +optional
+	ManagedExternalEtcdReady bool `json:"managedExternalEtcdReady"`
+
 	// v1beta2 groups all the fields that will be added or modified in Cluster's status with the V1Beta2 version.
 	// +optional
 	V1Beta2 *ClusterV1Beta2Status `json:"v1beta2,omitempty"`
diff --git a/api/core/v1beta1/common_types.go b/api/core/v1beta1/common_types.go
index 2006bb8..4b2e4ed 100644
--- a/api/core/v1beta1/common_types.go
+++ b/api/core/v1beta1/common_types.go
@@ -171,6 +171,9 @@ const (
 	// will receive the resulting object.
 	TopologyDryRunAnnotation = "topology.cluster.x-k8s.io/dry-run"
 
+	// ControlPlaneUpgradeCompletedAnnotation is set by the controlplane on the external etcd object after controlplane upgrade is completed.
+	ControlPlaneUpgradeCompletedAnnotation = "controlplane.cluster.x-k8s.io/upgrade-complete"
+
 	// ReplicasManagedByAnnotation is an annotation that indicates external (non-Cluster API) management of infra scaling.
 	// The practical effect of this is that the capi "replica" count should be passively derived from the number of observed infra machines,
 	// instead of being a source of truth for eventual consistency.
@@ -210,6 +213,10 @@ const (
 	// Note: While the upgrade is blocked changes made to the Cluster Topology will be delayed propagating to the underlying
 	// objects while the object is waiting for upgrade.
 	BeforeClusterUpgradeHookAnnotationPrefix = "before-upgrade.hook.cluster.cluster.x-k8s.io"
+
+	// SkipControlPlanePauseManagedEtcdAnnotation indicates that the cluster controller should not pause or unpause
+	// the control plane after the managed etcd cluster becomes not-ready/ready.
+	SkipControlPlanePauseManagedEtcdAnnotation = "cluster.x-k8s.io/skip-pause-cp-managed-etcd"
 )
 
 // MachineSetPreflightCheck defines a valid MachineSet preflight check.
diff --git a/api/core/v1beta1/condition_consts.go b/api/core/v1beta1/condition_consts.go
index 8e36313..a0568c2 100644
--- a/api/core/v1beta1/condition_consts.go
+++ b/api/core/v1beta1/condition_consts.go
@@ -282,6 +282,22 @@ const (
 	ScalingDownReason = "ScalingDown"
 )
 
+// Conditions used by the Etcd provider objects
+const (
+	// ManagedExternalEtcdClusterInitializedCondition is set once the first member of an etcd cluster is provisioned and running
+	ManagedExternalEtcdClusterInitializedCondition ConditionType = "ManagedEtcdInitialized"
+
+	// ManagedExternalEtcdClusterReadyCondition indicates if the etcd cluster is ready and all members have passed healthchecks.
+	ManagedExternalEtcdClusterReadyCondition ConditionType = "ManagedEtcdReady"
+
+	// WaitingForEtcdClusterInitializedReason (Severity=Info) documents a cluster waiting for the etcd cluster
+	// to report successful etcd cluster initialization.
+	WaitingForEtcdClusterInitializedReason = "WaitingForEtcdClusterProviderInitialized"
+
+	// EtcdHealthCheckFailedReason (Severity=Error) documents that healthcheck on an etcd member failed
+	EtcdHealthCheckFailedReason = "EtcdMemberHealthCheckFailed"
+)
+
 // Conditions and condition reasons for Clusters with a managed Topology.
 const (
 	// TopologyReconciledCondition provides evidence about the reconciliation of a Cluster topology into
diff --git a/api/core/v1beta1/machine_types.go b/api/core/v1beta1/machine_types.go
index 9665953..8cf2421 100644
--- a/api/core/v1beta1/machine_types.go
+++ b/api/core/v1beta1/machine_types.go
@@ -51,6 +51,8 @@ const (
 	// Note: The value of this label may be a hash if the control plane name is longer than 63 characters.
 	MachineControlPlaneNameLabel = "cluster.x-k8s.io/control-plane-name"
 
+	//MachineEtcdClusterLabelName is the label set on machines or related objects that are part of an etcd cluster
+	MachineEtcdClusterLabelName = "cluster.x-k8s.io/etcd-cluster"
 	// PreDrainDeleteHookAnnotationPrefix annotation specifies the prefix we
 	// search each annotation for during the pre-drain.delete lifecycle hook
 	// to pause reconciliation of deletion. These hooks will prevent removal of
diff --git a/api/core/v1beta1/zz_generated.conversion.go b/api/core/v1beta1/zz_generated.conversion.go
index eb54f25..749d480 100644
--- a/api/core/v1beta1/zz_generated.conversion.go
+++ b/api/core/v1beta1/zz_generated.conversion.go
@@ -1483,6 +1483,7 @@ func autoConvert_v1beta1_ClusterSpec_To_v1beta2_ClusterSpec(in *ClusterSpec, out
 		return err
 	}
 	// WARNING: in.ControlPlaneRef requires manual conversion: inconvertible types (*k8s.io/api/core/v1.ObjectReference vs sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference)
+	// WARNING: in.ManagedExternalEtcdRef requires manual conversion: inconvertible types (*k8s.io/api/core/v1.ObjectReference vs sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference)
 	// WARNING: in.InfrastructureRef requires manual conversion: inconvertible types (*k8s.io/api/core/v1.ObjectReference vs sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference)
 	// WARNING: in.Topology requires manual conversion: inconvertible types (*sigs.k8s.io/cluster-api/api/core/v1beta1.Topology vs sigs.k8s.io/cluster-api/api/core/v1beta2.Topology)
 	out.AvailabilityGates = *(*[]v1beta2.ClusterAvailabilityGate)(unsafe.Pointer(&in.AvailabilityGates))
@@ -1498,6 +1499,7 @@ func autoConvert_v1beta2_ClusterSpec_To_v1beta1_ClusterSpec(in *v1beta2.ClusterS
 		return err
 	}
 	// WARNING: in.ControlPlaneRef requires manual conversion: inconvertible types (sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference vs *k8s.io/api/core/v1.ObjectReference)
+	// WARNING: in.ManagedExternalEtcdRef requires manual conversion: inconvertible types (sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference vs *k8s.io/api/core/v1.ObjectReference)
 	// WARNING: in.InfrastructureRef requires manual conversion: inconvertible types (sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference vs *k8s.io/api/core/v1.ObjectReference)
 	// WARNING: in.Topology requires manual conversion: inconvertible types (sigs.k8s.io/cluster-api/api/core/v1beta2.Topology vs *sigs.k8s.io/cluster-api/api/core/v1beta1.Topology)
 	out.AvailabilityGates = *(*[]ClusterAvailabilityGate)(unsafe.Pointer(&in.AvailabilityGates))
@@ -1523,6 +1525,8 @@ func autoConvert_v1beta1_ClusterStatus_To_v1beta2_ClusterStatus(in *ClusterStatu
 		out.Conditions = nil
 	}
 	out.ObservedGeneration = in.ObservedGeneration
+	out.ManagedExternalEtcdInitialized = in.ManagedExternalEtcdInitialized
+	out.ManagedExternalEtcdReady = in.ManagedExternalEtcdReady
 	// WARNING: in.V1Beta2 requires manual conversion: does not exist in peer-type
 	return nil
 }
@@ -1545,6 +1549,8 @@ func autoConvert_v1beta2_ClusterStatus_To_v1beta1_ClusterStatus(in *v1beta2.Clus
 	// WARNING: in.FailureDomains requires manual conversion: inconvertible types ([]sigs.k8s.io/cluster-api/api/core/v1beta2.FailureDomain vs sigs.k8s.io/cluster-api/api/core/v1beta1.FailureDomains)
 	out.Phase = in.Phase
 	out.ObservedGeneration = in.ObservedGeneration
+	out.ManagedExternalEtcdInitialized = in.ManagedExternalEtcdInitialized
+	out.ManagedExternalEtcdReady = in.ManagedExternalEtcdReady
 	// WARNING: in.Deprecated requires manual conversion: does not exist in peer-type
 	return nil
 }
diff --git a/api/core/v1beta1/zz_generated.deepcopy.go b/api/core/v1beta1/zz_generated.deepcopy.go
index a1b0906..9bdcc4a 100644
--- a/api/core/v1beta1/zz_generated.deepcopy.go
+++ b/api/core/v1beta1/zz_generated.deepcopy.go
@@ -501,6 +501,11 @@ func (in *ClusterSpec) DeepCopyInto(out *ClusterSpec) {
 		*out = new(v1.ObjectReference)
 		**out = **in
 	}
+	if in.ManagedExternalEtcdRef != nil {
+		in, out := &in.ManagedExternalEtcdRef, &out.ManagedExternalEtcdRef
+		*out = new(v1.ObjectReference)
+		**out = **in
+	}
 	if in.InfrastructureRef != nil {
 		in, out := &in.InfrastructureRef, &out.InfrastructureRef
 		*out = new(v1.ObjectReference)
diff --git a/api/core/v1beta1/zz_generated.openapi.go b/api/core/v1beta1/zz_generated.openapi.go
index 13a78b2..c7285e4 100644
--- a/api/core/v1beta1/zz_generated.openapi.go
+++ b/api/core/v1beta1/zz_generated.openapi.go
@@ -967,6 +967,12 @@ func schema_cluster_api_api_core_v1beta1_ClusterSpec(ref common.ReferenceCallbac
 							Ref:         ref("k8s.io/api/core/v1.ObjectReference"),
 						},
 					},
+					"managedExternalEtcdRef": {
+						SchemaProps: spec.SchemaProps{
+							Description: "ManagedExternalEtcdRef is an optional reference to an etcd provider resource that holds details for provisioning an external etcd cluster",
+							Ref:         ref("k8s.io/api/core/v1.ObjectReference"),
+						},
+					},
 					"infrastructureRef": {
 						SchemaProps: spec.SchemaProps{
 							Description: "infrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.",
@@ -1089,6 +1095,22 @@ func schema_cluster_api_api_core_v1beta1_ClusterStatus(ref common.ReferenceCallb
 							Format:      "int64",
 						},
 					},
+					"managedExternalEtcdInitialized": {
+						SchemaProps: spec.SchemaProps{
+							Description: "ManagedExternalEtcdInitialized indicates that first etcd member's IP address is set by machine controller, so remaining etcd members can lookup the address to join the cluster",
+							Default:     false,
+							Type:        []string{"boolean"},
+							Format:      "",
+						},
+					},
+					"managedExternalEtcdReady": {
+						SchemaProps: spec.SchemaProps{
+							Description: "ManagedExternalEtcdReady indicates external etcd cluster is fully provisioned",
+							Default:     false,
+							Type:        []string{"boolean"},
+							Format:      "",
+						},
+					},
 					"v1beta2": {
 						SchemaProps: spec.SchemaProps{
 							Description: "v1beta2 groups all the fields that will be added or modified in Cluster's status with the V1Beta2 version.",
diff --git a/api/core/v1beta2/cluster_types.go b/api/core/v1beta2/cluster_types.go
index af09698..99ac9df 100644
--- a/api/core/v1beta2/cluster_types.go
+++ b/api/core/v1beta2/cluster_types.go
@@ -477,6 +477,11 @@ type ClusterSpec struct {
 	// +optional
 	ControlPlaneRef ContractVersionedObjectReference `json:"controlPlaneRef,omitempty,omitzero"`
 
+	// ManagedExternalEtcdRef is an optional reference to an etcd provider resource that holds details
+	// for provisioning an external etcd cluster
+	// +optional
+	ManagedExternalEtcdRef ContractVersionedObjectReference `json:"managedExternalEtcdRef,omitempty"`
+
 	// infrastructureRef is a reference to a provider-specific resource that holds the details
 	// for provisioning infrastructure for a cluster in said provider.
 	// +optional
@@ -1353,6 +1358,15 @@ type ClusterStatus struct {
 	// +kubebuilder:validation:Minimum=1
 	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
 
+	// ManagedExternalEtcdInitialized indicates that first etcd member's IP address is set by machine controller,
+	// so remaining etcd members can lookup the address to join the cluster
+	// +optional
+	ManagedExternalEtcdInitialized bool `json:"managedExternalEtcdInitialized"`
+
+	// ManagedExternalEtcdReady indicates external etcd cluster is fully provisioned
+	// +optional
+	ManagedExternalEtcdReady bool `json:"managedExternalEtcdReady"`
+
 	// deprecated groups all the status fields that are deprecated and will be removed when all the nested field are removed.
 	// +optional
 	Deprecated *ClusterDeprecatedStatus `json:"deprecated,omitempty"`
diff --git a/api/core/v1beta2/common_types.go b/api/core/v1beta2/common_types.go
index 55c37a2..178b364 100644
--- a/api/core/v1beta2/common_types.go
+++ b/api/core/v1beta2/common_types.go
@@ -171,6 +171,9 @@ const (
 	// will receive the resulting object.
 	TopologyDryRunAnnotation = "topology.cluster.x-k8s.io/dry-run"
 
+	// ControlPlaneUpgradeCompletedAnnotation is set by the controlplane on the external etcd object after controlplane upgrade is completed.
+	ControlPlaneUpgradeCompletedAnnotation = "controlplane.cluster.x-k8s.io/upgrade-complete"
+
 	// ReplicasManagedByAnnotation is an annotation that indicates external (non-Cluster API) management of infra scaling.
 	// The practical effect of this is that the capi "replica" count should be passively derived from the number of observed infra machines,
 	// instead of being a source of truth for eventual consistency.
@@ -210,6 +213,10 @@ const (
 	// Note: While the upgrade is blocked changes made to the Cluster Topology will be delayed propagating to the underlying
 	// objects while the object is waiting for upgrade.
 	BeforeClusterUpgradeHookAnnotationPrefix = "before-upgrade.hook.cluster.cluster.x-k8s.io"
+
+	// SkipControlPlanePauseManagedEtcdAnnotation indicates that the cluster controller should not pause or unpause
+	// the control plane after the managed etcd cluster becomes not-ready/ready.
+	SkipControlPlanePauseManagedEtcdAnnotation = "cluster.x-k8s.io/skip-pause-cp-managed-etcd"
 )
 
 // MachineSetPreflightCheck defines a valid MachineSet preflight check.
diff --git a/api/core/v1beta2/condition_consts.go b/api/core/v1beta2/condition_consts.go
index 23abc6c..fa7bda3 100644
--- a/api/core/v1beta2/condition_consts.go
+++ b/api/core/v1beta2/condition_consts.go
@@ -213,3 +213,22 @@ const (
 	// NotProvisionedReason documents an object or a piece of infrastructure is not provisioned.
 	NotProvisionedReason = "NotProvisioned"
 )
+
+// Conditions used by the Etcd provider objects
+const (
+	// ManagedExternalEtcdClusterInitializedCondition is set once the first member of an etcd cluster is provisioned and running
+	ManagedExternalEtcdClusterInitializedCondition ConditionType = "ManagedEtcdInitialized"
+
+	// ManagedExternalEtcdClusterInitializedReason surfaces when the first member of etcd cluster is initialized
+	ManagedExternalEtcdClusterInitializedReason = "ManagedEtcdInitialized"
+
+	// ManagedExternalEtcdClusterReadyCondition indicates if the etcd cluster is ready and all members have passed healthchecks.
+	ManagedExternalEtcdClusterReadyCondition ConditionType = "ManagedEtcdReady"
+
+	// WaitingForEtcdClusterInitializedReason (Severity=Info) documents a cluster waiting for the etcd cluster
+	// to report successful etcd cluster initialization.
+	WaitingForEtcdClusterInitializedReason = "WaitingForEtcdClusterProviderInitialized"
+
+	// EtcdHealthCheckFailedReason (Severity=Error) documents that healthcheck on an etcd member failed
+	EtcdHealthCheckFailedReason = "EtcdMemberHealthCheckFailed"
+)
diff --git a/api/core/v1beta2/machine_types.go b/api/core/v1beta2/machine_types.go
index a60f736..bef57a2 100644
--- a/api/core/v1beta2/machine_types.go
+++ b/api/core/v1beta2/machine_types.go
@@ -30,6 +30,9 @@ const (
 	// MachineControlPlaneLabel is the label set on machines or related objects that are part of a control plane.
 	MachineControlPlaneLabel = "cluster.x-k8s.io/control-plane"
 
+	//MachineEtcdClusterLabelName is the label set on machines or related objects that are part of an etcd cluster
+	MachineEtcdClusterLabelName = "cluster.x-k8s.io/etcd-cluster"
+
 	// ExcludeNodeDrainingAnnotation annotation explicitly skips node draining if set.
 	ExcludeNodeDrainingAnnotation = "machine.cluster.x-k8s.io/exclude-node-draining"
 
diff --git a/api/core/v1beta2/zz_generated.deepcopy.go b/api/core/v1beta2/zz_generated.deepcopy.go
index 49d1f66..a3c8c40 100644
--- a/api/core/v1beta2/zz_generated.deepcopy.go
+++ b/api/core/v1beta2/zz_generated.deepcopy.go
@@ -581,6 +581,7 @@ func (in *ClusterSpec) DeepCopyInto(out *ClusterSpec) {
 	in.ClusterNetwork.DeepCopyInto(&out.ClusterNetwork)
 	out.ControlPlaneEndpoint = in.ControlPlaneEndpoint
 	out.ControlPlaneRef = in.ControlPlaneRef
+	out.ManagedExternalEtcdRef = in.ManagedExternalEtcdRef
 	out.InfrastructureRef = in.InfrastructureRef
 	in.Topology.DeepCopyInto(&out.Topology)
 	if in.AvailabilityGates != nil {
diff --git a/api/core/v1beta2/zz_generated.openapi.go b/api/core/v1beta2/zz_generated.openapi.go
index 6ada26c..8d70d73 100644
--- a/api/core/v1beta2/zz_generated.openapi.go
+++ b/api/core/v1beta2/zz_generated.openapi.go
@@ -1166,6 +1166,13 @@ func schema_cluster_api_api_core_v1beta2_ClusterSpec(ref common.ReferenceCallbac
 							Ref:         ref("sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference"),
 						},
 					},
+					"managedExternalEtcdRef": {
+						SchemaProps: spec.SchemaProps{
+							Description: "ManagedExternalEtcdRef is an optional reference to an etcd provider resource that holds details for provisioning an external etcd cluster",
+							Default:     map[string]interface{}{},
+							Ref:         ref("sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference"),
+						},
+					},
 					"infrastructureRef": {
 						SchemaProps: spec.SchemaProps{
 							Description: "infrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.",
@@ -1294,6 +1301,22 @@ func schema_cluster_api_api_core_v1beta2_ClusterStatus(ref common.ReferenceCallb
 							Format:      "int64",
 						},
 					},
+					"managedExternalEtcdInitialized": {
+						SchemaProps: spec.SchemaProps{
+							Description: "ManagedExternalEtcdInitialized indicates that first etcd member's IP address is set by machine controller, so remaining etcd members can lookup the address to join the cluster",
+							Default:     false,
+							Type:        []string{"boolean"},
+							Format:      "",
+						},
+					},
+					"managedExternalEtcdReady": {
+						SchemaProps: spec.SchemaProps{
+							Description: "ManagedExternalEtcdReady indicates external etcd cluster is fully provisioned",
+							Default:     false,
+							Type:        []string{"boolean"},
+							Format:      "",
+						},
+					},
 					"deprecated": {
 						SchemaProps: spec.SchemaProps{
 							Description: "deprecated groups all the status fields that are deprecated and will be removed when all the nested field are removed.",
diff --git a/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigs.yaml b/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigs.yaml
index d33f51b..4e98062 100644
--- a/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigs.yaml
+++ b/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigs.yaml
@@ -1363,6 +1363,19 @@ spec:
                           type: string
                         type: array
                     type: object
+                  registryMirror:
+                    description: |-
+                      RegistryMirror holds the image registry mirror information
+                      This is only for bottlerocket
+                    properties:
+                      caCert:
+                        description: CACert defines the CA cert for the registry mirror
+                        type: string
+                      endpoint:
+                        description: Endpoint defines the registry mirror endpoint
+                          to use for pulling images
+                        type: string
+                    type: object
                   scheduler:
                     description: scheduler contains extra settings for the scheduler
                       control plane component
@@ -1924,6 +1937,19 @@ spec:
                           type: string
                         type: array
                     type: object
+                  registryMirror:
+                    description: |-
+                      RegistryMirror holds the image registry mirror information
+                      This is only for bottlerocket
+                    properties:
+                      caCert:
+                        description: CACert defines the CA cert for the registry mirror
+                        type: string
+                      endpoint:
+                        description: Endpoint defines the registry mirror endpoint
+                          to use for pulling images
+                        type: string
+                    type: object
                 type: object
               mounts:
                 description: mounts specifies a list of mount points to be setup.
@@ -2906,6 +2932,19 @@ spec:
                           type: string
                         type: array
                     type: object
+                  registryMirror:
+                    description: |-
+                      RegistryMirror holds the image registry mirror information
+                      This is only for bottlerocket
+                    properties:
+                      caCert:
+                        description: CACert defines the CA cert for the registry mirror
+                        type: string
+                      endpoint:
+                        description: Endpoint defines the registry mirror endpoint
+                          to use for pulling images
+                        type: string
+                    type: object
                   scheduler:
                     description: scheduler contains extra settings for the scheduler
                       control plane component
@@ -3946,6 +3985,19 @@ spec:
                           type: string
                         type: array
                     type: object
+                  registryMirror:
+                    description: |-
+                      RegistryMirror holds the image registry mirror information
+                      This is only for bottlerocket
+                    properties:
+                      caCert:
+                        description: CACert defines the CA cert for the registry mirror
+                        type: string
+                      endpoint:
+                        description: Endpoint defines the registry mirror endpoint
+                          to use for pulling images
+                        type: string
+                    type: object
                   skipPhases:
                     description: |-
                       skipPhases is a list of phases to skip during command execution.
@@ -5168,6 +5220,19 @@ spec:
                           type: string
                         type: array
                     type: object
+                  registryMirror:
+                    description: |-
+                      RegistryMirror holds the image registry mirror information
+                      This is only for bottlerocket
+                    properties:
+                      caCert:
+                        description: CACert defines the CA cert for the registry mirror
+                        type: string
+                      endpoint:
+                        description: Endpoint defines the registry mirror endpoint
+                          to use for pulling images
+                        type: string
+                    type: object
                   scheduler:
                     description: scheduler contains extra settings for the scheduler
                       control plane component
@@ -6359,6 +6424,19 @@ spec:
                           type: string
                         type: array
                     type: object
+                  registryMirror:
+                    description: |-
+                      RegistryMirror holds the image registry mirror information
+                      This is only for bottlerocket
+                    properties:
+                      caCert:
+                        description: CACert defines the CA cert for the registry mirror
+                        type: string
+                      endpoint:
+                        description: Endpoint defines the registry mirror endpoint
+                          to use for pulling images
+                        type: string
+                    type: object
                   skipPhases:
                     description: |-
                       skipPhases is a list of phases to skip during command execution.
diff --git a/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigtemplates.yaml b/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigtemplates.yaml
index cab4d6e..a0be5ab 100644
--- a/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigtemplates.yaml
+++ b/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigtemplates.yaml
@@ -1331,6 +1331,20 @@ spec:
                                   type: string
                                 type: array
                             type: object
+                          registryMirror:
+                            description: |-
+                              RegistryMirror holds the image registry mirror information
+                              This is only for bottlerocket
+                            properties:
+                              caCert:
+                                description: CACert defines the CA cert for the registry
+                                  mirror
+                                type: string
+                              endpoint:
+                                description: Endpoint defines the registry mirror
+                                  endpoint to use for pulling images
+                                type: string
+                            type: object
                           scheduler:
                             description: scheduler contains extra settings for the
                               scheduler control plane component
@@ -1905,6 +1919,20 @@ spec:
                                   type: string
                                 type: array
                             type: object
+                          registryMirror:
+                            description: |-
+                              RegistryMirror holds the image registry mirror information
+                              This is only for bottlerocket
+                            properties:
+                              caCert:
+                                description: CACert defines the CA cert for the registry
+                                  mirror
+                                type: string
+                              endpoint:
+                                description: Endpoint defines the registry mirror
+                                  endpoint to use for pulling images
+                                type: string
+                            type: object
                         type: object
                       mounts:
                         description: mounts specifies a list of mount points to be
@@ -2875,6 +2903,20 @@ spec:
                                   type: string
                                 type: array
                             type: object
+                          registryMirror:
+                            description: |-
+                              RegistryMirror holds the image registry mirror information
+                              This is only for bottlerocket
+                            properties:
+                              caCert:
+                                description: CACert defines the CA cert for the registry
+                                  mirror
+                                type: string
+                              endpoint:
+                                description: Endpoint defines the registry mirror
+                                  endpoint to use for pulling images
+                                type: string
+                            type: object
                           scheduler:
                             description: scheduler contains extra settings for the
                               scheduler control plane component
@@ -3939,6 +3981,20 @@ spec:
                                   type: string
                                 type: array
                             type: object
+                          registryMirror:
+                            description: |-
+                              RegistryMirror holds the image registry mirror information
+                              This is only for bottlerocket
+                            properties:
+                              caCert:
+                                description: CACert defines the CA cert for the registry
+                                  mirror
+                                type: string
+                              endpoint:
+                                description: Endpoint defines the registry mirror
+                                  endpoint to use for pulling images
+                                type: string
+                            type: object
                           skipPhases:
                             description: |-
                               skipPhases is a list of phases to skip during command execution.
@@ -5062,6 +5118,20 @@ spec:
                                   type: string
                                 type: array
                             type: object
+                          registryMirror:
+                            description: |-
+                              RegistryMirror holds the image registry mirror information
+                              This is only for bottlerocket
+                            properties:
+                              caCert:
+                                description: CACert defines the CA cert for the registry
+                                  mirror
+                                type: string
+                              endpoint:
+                                description: Endpoint defines the registry mirror
+                                  endpoint to use for pulling images
+                                type: string
+                            type: object
                           scheduler:
                             description: scheduler contains extra settings for the
                               scheduler control plane component
@@ -6274,6 +6344,20 @@ spec:
                                   type: string
                                 type: array
                             type: object
+                          registryMirror:
+                            description: |-
+                              RegistryMirror holds the image registry mirror information
+                              This is only for bottlerocket
+                            properties:
+                              caCert:
+                                description: CACert defines the CA cert for the registry
+                                  mirror
+                                type: string
+                              endpoint:
+                                description: Endpoint defines the registry mirror
+                                  endpoint to use for pulling images
+                                type: string
+                            type: object
                           skipPhases:
                             description: |-
                               skipPhases is a list of phases to skip during command execution.
diff --git a/bootstrap/kubeadm/internal/bottlerocket/bootstrap.go b/bootstrap/kubeadm/internal/bottlerocket/bootstrap.go
index e4be8d9..4e1de77 100644
--- a/bootstrap/kubeadm/internal/bottlerocket/bootstrap.go
+++ b/bootstrap/kubeadm/internal/bottlerocket/bootstrap.go
@@ -29,7 +29,18 @@ user-data = "{{.BootstrapContainerUserData}}"
 	networkInitTemplate = `{{ define "networkInitSettings" -}}
 [settings.network]
 https-proxy = "{{.HTTPSProxyEndpoint}}"
-no-proxy = "{{.NoProxyEndpoints}}"
+no-proxy = [{{stringsJoin .NoProxyEndpoints "," }}]
+{{- end -}}
+`
+	registryMirrorTemplate = `{{ define "registryMirrorSettings" -}}
+[settings.container-registry.mirrors]
+"public.ecr.aws" = ["https://{{.RegistryMirrorEndpoint}}"]
+{{- end -}}
+`
+	registryMirrorCACertTemplate = `{{ define "registryMirrorCACertSettings" -}}
+[settings.pki.registry-mirror-ca]
+data = "{{.RegistryMirrorCACert}}"
+trusted=true
 {{- end -}}
 `
 	bottlerocketNodeInitSettingsTemplate = `{{template "bootstrapHostContainerSettings" .}}
@@ -41,5 +52,13 @@ no-proxy = "{{.NoProxyEndpoints}}"
 {{- if (ne .HTTPSProxyEndpoint "")}}
 {{template "networkInitSettings" .}}
 {{- end -}}
+
+{{- if (ne .RegistryMirrorEndpoint "")}}
+{{template "registryMirrorSettings" .}}
+{{- end -}}
+
+{{- if (ne .RegistryMirrorCACert "")}}
+{{template "registryMirrorCACertSettings" .}}
+{{- end -}}
 `
 )
diff --git a/bootstrap/kubeadm/internal/bottlerocket/bottlerocket.go b/bootstrap/kubeadm/internal/bottlerocket/bottlerocket.go
index 18e559c..4f73296 100644
--- a/bootstrap/kubeadm/internal/bottlerocket/bottlerocket.go
+++ b/bootstrap/kubeadm/internal/bottlerocket/bottlerocket.go
@@ -4,6 +4,7 @@ import (
 	"bytes"
 	"encoding/base64"
 	"fmt"
+	"strconv"
 	"strings"
 	"text/template"
 
@@ -22,9 +23,10 @@ const (
 )
 
 type BottlerocketConfig struct {
-	Pause                 bootstrapv1.Pause
-	BottlerocketBootstrap bootstrapv1.BottlerocketBootstrap
-	ProxyConfiguration    bootstrapv1.ProxyConfiguration
+	Pause                       bootstrapv1.Pause
+	BottlerocketBootstrap       bootstrapv1.BottlerocketBootstrap
+	ProxyConfiguration          bootstrapv1.ProxyConfiguration
+	RegistryMirrorConfiguration bootstrapv1.RegistryMirrorConfiguration
 }
 
 type BottlerocketSettingsInput struct {
@@ -34,6 +36,8 @@ type BottlerocketSettingsInput struct {
 	PauseContainerSource       string
 	HTTPSProxyEndpoint         string
 	NoProxyEndpoints           []string
+	RegistryMirrorEndpoint     string
+	RegistryMirrorCACert       string
 }
 
 type HostPath struct {
@@ -77,7 +81,7 @@ func generateAdminContainerUserData(kind string, tpl string, data interface{}) (
 }
 
 func generateNodeUserData(kind string, tpl string, data interface{}) ([]byte, error) {
-	tm := template.New(kind)
+	tm := template.New(kind).Funcs(template.FuncMap{"stringsJoin": strings.Join})
 	if _, err := tm.Parse(bootstrapHostContainerTemplate); err != nil {
 		return nil, errors.Wrapf(err, "failed to parse hostContainer %s template", kind)
 	}
@@ -90,7 +94,12 @@ func generateNodeUserData(kind string, tpl string, data interface{}) ([]byte, er
 	if _, err := tm.Parse(networkInitTemplate); err != nil {
 		return nil, errors.Wrapf(err, "failed to parse networks %s template", kind)
 	}
-
+	if _, err := tm.Parse(registryMirrorTemplate); err != nil {
+		return nil, errors.Wrapf(err, "failed to parse registry mirror %s template", kind)
+	}
+	if _, err := tm.Parse(registryMirrorCACertTemplate); err != nil {
+		return nil, errors.Wrapf(err, "failed to parse registry mirror ca cert %s template", kind)
+	}
 	t, err := tm.Parse(tpl)
 	if err != nil {
 		return nil, errors.Wrapf(err, "failed to parse %s template", kind)
@@ -124,7 +133,15 @@ func getBottlerocketNodeUserData(bootstrapContainerUserData []byte, users []boot
 		BootstrapContainerSource:   fmt.Sprintf("%s:%s", config.BottlerocketBootstrap.ImageRepository, config.BottlerocketBootstrap.ImageTag),
 		PauseContainerSource:       fmt.Sprintf("%s:%s", config.Pause.ImageRepository, config.Pause.ImageTag),
 		HTTPSProxyEndpoint:         config.ProxyConfiguration.HTTPSProxy,
-		NoProxyEndpoints:           config.ProxyConfiguration.NoProxy,
+		RegistryMirrorEndpoint:     config.RegistryMirrorConfiguration.Endpoint,
+	}
+	if len(config.ProxyConfiguration.NoProxy) > 0 {
+		for _, noProxy := range config.ProxyConfiguration.NoProxy {
+			bottlerocketInput.NoProxyEndpoints = append(bottlerocketInput.NoProxyEndpoints, strconv.Quote(noProxy))
+		}
+	}
+	if config.RegistryMirrorConfiguration.CACert != "" {
+		bottlerocketInput.RegistryMirrorCACert = base64.StdEncoding.EncodeToString([]byte(config.RegistryMirrorConfiguration.CACert))
 	}
 
 	bottlerocketNodeUserData, err := generateNodeUserData("InitBottlerocketNode", bottlerocketNodeInitSettingsTemplate, bottlerocketInput)
diff --git a/bootstrap/kubeadm/internal/bottlerocket/controlplane_join.go b/bootstrap/kubeadm/internal/bottlerocket/controlplane_join.go
index b93e116..aecbda8 100644
--- a/bootstrap/kubeadm/internal/bottlerocket/controlplane_join.go
+++ b/bootstrap/kubeadm/internal/bottlerocket/controlplane_join.go
@@ -21,6 +21,12 @@ func NewJoinControlPlane(input *cloudinit.ControlPlaneJoinInput, config *Bottler
 	input.WriteFiles = input.Certificates.AsFiles()
 	input.ControlPlane = true
 	input.WriteFiles = append(input.WriteFiles, input.AdditionalFiles...)
+	var err error
+	input.WriteFiles, err = patchKubeVipFile(input.WriteFiles)
+	if err != nil {
+		return nil, errors.Wrap(err, "failed to patch kube-vip manifest file for control plane join")
+	}
+
 	bootstrapContainerUserData, err := generateBootstrapContainerUserData("JoinControlplane", controlPlaneJoinBottlerocketInit, input)
 	if err != nil {
 		return nil, errors.Wrapf(err, "failed to generate user data for machine joining control plane")
diff --git a/bootstrap/kubeadm/internal/controllers/kubeadmconfig_controller.go b/bootstrap/kubeadm/internal/controllers/kubeadmconfig_controller.go
index 086ef1e..130a0c4 100644
--- a/bootstrap/kubeadm/internal/controllers/kubeadmconfig_controller.go
+++ b/bootstrap/kubeadm/internal/controllers/kubeadmconfig_controller.go
@@ -569,6 +569,9 @@ func (r *KubeadmConfigReconciler) handleClusterNotInitialized(ctx context.Contex
 		if scope.Config.Spec.ClusterConfiguration.Proxy.HTTPSProxy != "" {
 			bottlerocketConfig.ProxyConfiguration = scope.Config.Spec.ClusterConfiguration.Proxy
 		}
+		if scope.Config.Spec.ClusterConfiguration.RegistryMirror.Endpoint != "" {
+			bottlerocketConfig.RegistryMirrorConfiguration = scope.Config.Spec.ClusterConfiguration.RegistryMirror
+		}
 	}
 
 	clusterdata, err := kubeadmtypes.MarshalClusterConfigurationForVersion(&scope.Config.Spec.ClusterConfiguration, parsedVersion, additionalData)
@@ -862,6 +865,9 @@ func (r *KubeadmConfigReconciler) joinWorker(ctx context.Context, scope *Scope)
 		if scope.Config.Spec.JoinConfiguration.Proxy.HTTPSProxy != "" {
 			bottlerocketConfig.ProxyConfiguration = scope.Config.Spec.JoinConfiguration.Proxy
 		}
+		if scope.Config.Spec.JoinConfiguration.RegistryMirror.Endpoint != "" {
+			bottlerocketConfig.RegistryMirrorConfiguration = scope.Config.Spec.JoinConfiguration.RegistryMirror
+		}
 		bootstrapJoinData, err = bottlerocket.NewNode(nodeInput, bottlerocketConfig)
 		if err != nil {
 			scope.Error(err, "Failed to create a worker bottlerocket join configuration")
@@ -1036,6 +1042,9 @@ func (r *KubeadmConfigReconciler) joinControlplane(ctx context.Context, scope *S
 		if scope.Config.Spec.JoinConfiguration.Proxy.HTTPSProxy != "" {
 			bottlerocketConfig.ProxyConfiguration = scope.Config.Spec.JoinConfiguration.Proxy
 		}
+		if scope.Config.Spec.ClusterConfiguration.RegistryMirror.Endpoint != "" {
+			bottlerocketConfig.RegistryMirrorConfiguration = scope.Config.Spec.ClusterConfiguration.RegistryMirror
+		}
 		bootstrapJoinData, err = bottlerocket.NewJoinControlPlane(controlPlaneJoinInput, bottlerocketConfig)
 		if err != nil {
 			scope.Error(err, "Failed to generate cloud init for bottlerocket bootstrap control plane")
diff --git a/bootstrap/kubeadm/types/upstreamv1beta3/conversion.go b/bootstrap/kubeadm/types/upstreamv1beta3/conversion.go
index bfa179c..6096463 100644
--- a/bootstrap/kubeadm/types/upstreamv1beta3/conversion.go
+++ b/bootstrap/kubeadm/types/upstreamv1beta3/conversion.go
@@ -420,6 +420,30 @@ func (src *ClusterConfiguration) GetAdditionalData(data *upstream.AdditionalData
 	}
 }
 
+func Convert_upstreamv1beta3_BottlerocketBootstrap_To_v1beta2_BottlerocketBootstrap(in *BottlerocketBootstrap, out *bootstrapv1.BottlerocketBootstrap, s apimachineryconversion.Scope) error {
+	out.ImageRepository = in.ImageRepository
+	out.ImageTag = in.ImageTag
+	return nil
+}
+
+func Convert_v1beta2_BottlerocketBootstrap_To_upstreamv1beta3_BottlerocketBootstrap(in *bootstrapv1.BottlerocketBootstrap, out *BottlerocketBootstrap, s apimachineryconversion.Scope) error {
+	out.ImageRepository = in.ImageRepository
+	out.ImageTag = in.ImageTag
+	return nil
+}
+
+func Convert_upstreamv1beta3_Pause_To_v1beta2_Pause(in *Pause, out *bootstrapv1.Pause, s apimachineryconversion.Scope) error {
+	out.ImageRepository = in.ImageRepository
+	out.ImageTag = in.ImageTag
+	return nil
+}
+
+func Convert_v1beta2_Pause_To_upstreamv1beta3_Pause(in *bootstrapv1.Pause, out *Pause, s apimachineryconversion.Scope) error {
+	out.ImageRepository = in.ImageRepository
+	out.ImageTag = in.ImageTag
+	return nil
+}
+
 func Convert_v1beta2_ClusterConfiguration_To_upstreamv1beta3_ClusterConfiguration(in *bootstrapv1.ClusterConfiguration, out *ClusterConfiguration, s apimachineryconversion.Scope) error {
 	return autoConvert_v1beta2_ClusterConfiguration_To_upstreamv1beta3_ClusterConfiguration(in, out, s)
 }
diff --git a/bootstrap/kubeadm/types/upstreamv1beta3/types.go b/bootstrap/kubeadm/types/upstreamv1beta3/types.go
index c251870..65371b8 100644
--- a/bootstrap/kubeadm/types/upstreamv1beta3/types.go
+++ b/bootstrap/kubeadm/types/upstreamv1beta3/types.go
@@ -73,6 +73,26 @@ type InitConfiguration struct {
 type ClusterConfiguration struct {
 	metav1.TypeMeta `json:",inline"`
 
+	// Pause holds the image source for pause container
+	// This is only for bottlerocket
+	// +optional
+	Pause Pause `json:"pause,omitempty"`
+
+	// BottlerocketBootstrap holds the image source for kubeadm bootstrap container
+	// This is only for bottlerocket
+	// +optional
+	BottlerocketBootstrap BottlerocketBootstrap `json:"bottlerocketBootstrap,omitempty"`
+
+	// Proxy holds the https and no proxy information
+	// This is only for bottlerocket
+	// +optional
+	Proxy ProxyConfiguration `json:"proxy,omitempty"`
+
+	// RegistryMirror holds the image registry mirror information
+	// This is only for bottlerocket
+	// +optional
+	RegistryMirror RegistryMirrorConfiguration `json:"registryMirror,omitempty"`
+
 	// Etcd holds configuration for etcd.
 	// +optional
 	Etcd Etcd `json:"etcd,omitempty"`
@@ -135,6 +155,38 @@ type ClusterConfiguration struct {
 	ClusterName string `json:"clusterName,omitempty"`
 }
 
+// Pause defines the pause image repo and tag that should be run on the bootstrapped nodes.
+// This setting is ONLY for bottlerocket nodes, as this needs to be set pre-boot time along with user-data
+type Pause struct {
+	// ImageMeta allows to customize the image used for the Pause component
+	ImageMeta `json:",inline"`
+}
+
+// BottlerocketBootstrap holds the settings of kubeadm bootstrap container for bottlerocket nodes
+// This setting is ONLY for bottlerocket nodes.
+type BottlerocketBootstrap struct {
+	// ImageMeta allows to customize the image used for the BottlerocketBootstrap component
+	ImageMeta `json:",inline"`
+}
+
+// ProxyConfiguration holds the settings for proxying bottlerocket services
+type ProxyConfiguration struct {
+	// HTTPS proxy
+	HTTPSProxy string `json:"httpsProxy,omitempty"`
+
+	// No proxy, list of ips that should not use proxy
+	NoProxy []string `json:"noProxy,omitempty"`
+}
+
+// RegistryMirrorConfiguration holds the settings for image registry mirror
+type RegistryMirrorConfiguration struct {
+	// Endpoint defines the registry mirror endpoint to use for pulling images
+	Endpoint string `json:"endpoint,omitempty"`
+
+	// CACert defines the CA cert for the registry mirror
+	CACert string `json:"caCert,omitempty"`
+}
+
 // ControlPlaneComponent holds settings common to control plane component of the cluster.
 type ControlPlaneComponent struct {
 	// ExtraArgs is an extra set of flags to pass to the control plane component.
@@ -334,6 +386,26 @@ type ExternalEtcd struct {
 type JoinConfiguration struct {
 	metav1.TypeMeta `json:",inline"`
 
+	// Pause holds the image source for pause container
+	// This is only for bottlerocket
+	// +optional
+	Pause Pause `json:"pause,omitempty"`
+
+	// BottlerocketBootstrap holds the image source for kubeadm bootstrap container
+	// This is only for bottlerocket
+	// +optional
+	BottlerocketBootstrap BottlerocketBootstrap `json:"bottlerocketBootstrap,omitempty"`
+
+	// Proxy holds the https and no proxy information
+	// This is only for bottlerocket
+	// +optional
+	Proxy ProxyConfiguration `json:"proxy,omitempty"`
+
+	// RegistryMirror holds the image registry mirror information
+	// This is only for bottlerocket
+	// +optional
+	RegistryMirror RegistryMirrorConfiguration `json:"registryMirror,omitempty"`
+
 	// NodeRegistration holds fields that relate to registering the new control-plane node to the cluster
 	// +optional
 	NodeRegistration NodeRegistrationOptions `json:"nodeRegistration,omitempty"`
diff --git a/bootstrap/kubeadm/types/upstreamv1beta3/zz_generated.conversion.go b/bootstrap/kubeadm/types/upstreamv1beta3/zz_generated.conversion.go
index 8cac4b9..99f0e1a 100644
--- a/bootstrap/kubeadm/types/upstreamv1beta3/zz_generated.conversion.go
+++ b/bootstrap/kubeadm/types/upstreamv1beta3/zz_generated.conversion.go
@@ -108,6 +108,26 @@ func RegisterConversions(s *runtime.Scheme) error {
 	}); err != nil {
 		return err
 	}
+	if err := s.AddGeneratedConversionFunc((*ProxyConfiguration)(nil), (*v1beta2.ProxyConfiguration)(nil), func(a, b interface{}, scope conversion.Scope) error {
+		return Convert_upstreamv1beta3_ProxyConfiguration_To_v1beta2_ProxyConfiguration(a.(*ProxyConfiguration), b.(*v1beta2.ProxyConfiguration), scope)
+	}); err != nil {
+		return err
+	}
+	if err := s.AddGeneratedConversionFunc((*v1beta2.ProxyConfiguration)(nil), (*ProxyConfiguration)(nil), func(a, b interface{}, scope conversion.Scope) error {
+		return Convert_v1beta2_ProxyConfiguration_To_upstreamv1beta3_ProxyConfiguration(a.(*v1beta2.ProxyConfiguration), b.(*ProxyConfiguration), scope)
+	}); err != nil {
+		return err
+	}
+	if err := s.AddGeneratedConversionFunc((*RegistryMirrorConfiguration)(nil), (*v1beta2.RegistryMirrorConfiguration)(nil), func(a, b interface{}, scope conversion.Scope) error {
+		return Convert_upstreamv1beta3_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(a.(*RegistryMirrorConfiguration), b.(*v1beta2.RegistryMirrorConfiguration), scope)
+	}); err != nil {
+		return err
+	}
+	if err := s.AddGeneratedConversionFunc((*v1beta2.RegistryMirrorConfiguration)(nil), (*RegistryMirrorConfiguration)(nil), func(a, b interface{}, scope conversion.Scope) error {
+		return Convert_v1beta2_RegistryMirrorConfiguration_To_upstreamv1beta3_RegistryMirrorConfiguration(a.(*v1beta2.RegistryMirrorConfiguration), b.(*RegistryMirrorConfiguration), scope)
+	}); err != nil {
+		return err
+	}
 	if err := s.AddConversionFunc((*APIServer)(nil), (*v1beta2.APIServer)(nil), func(a, b interface{}, scope conversion.Scope) error {
 		return Convert_upstreamv1beta3_APIServer_To_v1beta2_APIServer(a.(*APIServer), b.(*v1beta2.APIServer), scope)
 	}); err != nil {
@@ -118,6 +138,11 @@ func RegisterConversions(s *runtime.Scheme) error {
 	}); err != nil {
 		return err
 	}
+	if err := s.AddConversionFunc((*BottlerocketBootstrap)(nil), (*v1beta2.BottlerocketBootstrap)(nil), func(a, b interface{}, scope conversion.Scope) error {
+		return Convert_upstreamv1beta3_BottlerocketBootstrap_To_v1beta2_BottlerocketBootstrap(a.(*BottlerocketBootstrap), b.(*v1beta2.BottlerocketBootstrap), scope)
+	}); err != nil {
+		return err
+	}
 	if err := s.AddConversionFunc((*ClusterConfiguration)(nil), (*v1beta2.ClusterConfiguration)(nil), func(a, b interface{}, scope conversion.Scope) error {
 		return Convert_upstreamv1beta3_ClusterConfiguration_To_v1beta2_ClusterConfiguration(a.(*ClusterConfiguration), b.(*v1beta2.ClusterConfiguration), scope)
 	}); err != nil {
@@ -173,6 +198,11 @@ func RegisterConversions(s *runtime.Scheme) error {
 	}); err != nil {
 		return err
 	}
+	if err := s.AddConversionFunc((*Pause)(nil), (*v1beta2.Pause)(nil), func(a, b interface{}, scope conversion.Scope) error {
+		return Convert_upstreamv1beta3_Pause_To_v1beta2_Pause(a.(*Pause), b.(*v1beta2.Pause), scope)
+	}); err != nil {
+		return err
+	}
 	if err := s.AddConversionFunc((*v1beta2.APIServer)(nil), (*APIServer)(nil), func(a, b interface{}, scope conversion.Scope) error {
 		return Convert_v1beta2_APIServer_To_upstreamv1beta3_APIServer(a.(*v1beta2.APIServer), b.(*APIServer), scope)
 	}); err != nil {
@@ -183,6 +213,11 @@ func RegisterConversions(s *runtime.Scheme) error {
 	}); err != nil {
 		return err
 	}
+	if err := s.AddConversionFunc((*v1beta2.BottlerocketBootstrap)(nil), (*BottlerocketBootstrap)(nil), func(a, b interface{}, scope conversion.Scope) error {
+		return Convert_v1beta2_BottlerocketBootstrap_To_upstreamv1beta3_BottlerocketBootstrap(a.(*v1beta2.BottlerocketBootstrap), b.(*BottlerocketBootstrap), scope)
+	}); err != nil {
+		return err
+	}
 	if err := s.AddConversionFunc((*v1beta2.ClusterConfiguration)(nil), (*ClusterConfiguration)(nil), func(a, b interface{}, scope conversion.Scope) error {
 		return Convert_v1beta2_ClusterConfiguration_To_upstreamv1beta3_ClusterConfiguration(a.(*v1beta2.ClusterConfiguration), b.(*ClusterConfiguration), scope)
 	}); err != nil {
@@ -233,6 +268,11 @@ func RegisterConversions(s *runtime.Scheme) error {
 	}); err != nil {
 		return err
 	}
+	if err := s.AddConversionFunc((*v1beta2.Pause)(nil), (*Pause)(nil), func(a, b interface{}, scope conversion.Scope) error {
+		return Convert_v1beta2_Pause_To_upstreamv1beta3_Pause(a.(*v1beta2.Pause), b.(*Pause), scope)
+	}); err != nil {
+		return err
+	}
 	if err := s.AddConversionFunc((*v1beta2.Scheduler)(nil), (*ControlPlaneComponent)(nil), func(a, b interface{}, scope conversion.Scope) error {
 		return Convert_v1beta2_Scheduler_To_upstreamv1beta3_ControlPlaneComponent(a.(*v1beta2.Scheduler), b.(*ControlPlaneComponent), scope)
 	}); err != nil {
@@ -350,8 +390,31 @@ func Convert_v1beta2_BootstrapTokenString_To_upstreamv1beta3_BootstrapTokenStrin
 	return autoConvert_v1beta2_BootstrapTokenString_To_upstreamv1beta3_BootstrapTokenString(in, out, s)
 }
 
+func autoConvert_upstreamv1beta3_BottlerocketBootstrap_To_v1beta2_BottlerocketBootstrap(in *BottlerocketBootstrap, out *v1beta2.BottlerocketBootstrap, s conversion.Scope) error {
+	// WARNING: in.ImageMeta requires manual conversion: does not exist in peer-type
+	return nil
+}
+
+func autoConvert_v1beta2_BottlerocketBootstrap_To_upstreamv1beta3_BottlerocketBootstrap(in *v1beta2.BottlerocketBootstrap, out *BottlerocketBootstrap, s conversion.Scope) error {
+	// WARNING: in.ImageRepository requires manual conversion: does not exist in peer-type
+	// WARNING: in.ImageTag requires manual conversion: does not exist in peer-type
+	return nil
+}
+
 func autoConvert_upstreamv1beta3_ClusterConfiguration_To_v1beta2_ClusterConfiguration(in *ClusterConfiguration, out *v1beta2.ClusterConfiguration, s conversion.Scope) error {
 	// WARNING: in.TypeMeta requires manual conversion: does not exist in peer-type
+	if err := Convert_upstreamv1beta3_Pause_To_v1beta2_Pause(&in.Pause, &out.Pause, s); err != nil {
+		return err
+	}
+	if err := Convert_upstreamv1beta3_BottlerocketBootstrap_To_v1beta2_BottlerocketBootstrap(&in.BottlerocketBootstrap, &out.BottlerocketBootstrap, s); err != nil {
+		return err
+	}
+	if err := Convert_upstreamv1beta3_ProxyConfiguration_To_v1beta2_ProxyConfiguration(&in.Proxy, &out.Proxy, s); err != nil {
+		return err
+	}
+	if err := Convert_upstreamv1beta3_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(&in.RegistryMirror, &out.RegistryMirror, s); err != nil {
+		return err
+	}
 	if err := Convert_upstreamv1beta3_Etcd_To_v1beta2_Etcd(&in.Etcd, &out.Etcd, s); err != nil {
 		return err
 	}
@@ -378,9 +441,18 @@ func autoConvert_upstreamv1beta3_ClusterConfiguration_To_v1beta2_ClusterConfigur
 }
 
 func autoConvert_v1beta2_ClusterConfiguration_To_upstreamv1beta3_ClusterConfiguration(in *v1beta2.ClusterConfiguration, out *ClusterConfiguration, s conversion.Scope) error {
-	// WARNING: in.Pause requires manual conversion: does not exist in peer-type
-	// WARNING: in.BottlerocketBootstrap requires manual conversion: does not exist in peer-type
-	// WARNING: in.Proxy requires manual conversion: does not exist in peer-type
+	if err := Convert_v1beta2_Pause_To_upstreamv1beta3_Pause(&in.Pause, &out.Pause, s); err != nil {
+		return err
+	}
+	if err := Convert_v1beta2_BottlerocketBootstrap_To_upstreamv1beta3_BottlerocketBootstrap(&in.BottlerocketBootstrap, &out.BottlerocketBootstrap, s); err != nil {
+		return err
+	}
+	if err := Convert_v1beta2_ProxyConfiguration_To_upstreamv1beta3_ProxyConfiguration(&in.Proxy, &out.Proxy, s); err != nil {
+		return err
+	}
+	if err := Convert_v1beta2_RegistryMirrorConfiguration_To_upstreamv1beta3_RegistryMirrorConfiguration(&in.RegistryMirror, &out.RegistryMirror, s); err != nil {
+		return err
+	}
 	if err := Convert_v1beta2_Etcd_To_upstreamv1beta3_Etcd(&in.Etcd, &out.Etcd, s); err != nil {
 		return err
 	}
@@ -568,6 +640,18 @@ func autoConvert_v1beta2_InitConfiguration_To_upstreamv1beta3_InitConfiguration(
 
 func autoConvert_upstreamv1beta3_JoinConfiguration_To_v1beta2_JoinConfiguration(in *JoinConfiguration, out *v1beta2.JoinConfiguration, s conversion.Scope) error {
 	// WARNING: in.TypeMeta requires manual conversion: does not exist in peer-type
+	if err := Convert_upstreamv1beta3_Pause_To_v1beta2_Pause(&in.Pause, &out.Pause, s); err != nil {
+		return err
+	}
+	if err := Convert_upstreamv1beta3_BottlerocketBootstrap_To_v1beta2_BottlerocketBootstrap(&in.BottlerocketBootstrap, &out.BottlerocketBootstrap, s); err != nil {
+		return err
+	}
+	if err := Convert_upstreamv1beta3_ProxyConfiguration_To_v1beta2_ProxyConfiguration(&in.Proxy, &out.Proxy, s); err != nil {
+		return err
+	}
+	if err := Convert_upstreamv1beta3_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(&in.RegistryMirror, &out.RegistryMirror, s); err != nil {
+		return err
+	}
 	if err := Convert_upstreamv1beta3_NodeRegistrationOptions_To_v1beta2_NodeRegistrationOptions(&in.NodeRegistration, &out.NodeRegistration, s); err != nil {
 		return err
 	}
@@ -590,9 +674,18 @@ func autoConvert_upstreamv1beta3_JoinConfiguration_To_v1beta2_JoinConfiguration(
 }
 
 func autoConvert_v1beta2_JoinConfiguration_To_upstreamv1beta3_JoinConfiguration(in *v1beta2.JoinConfiguration, out *JoinConfiguration, s conversion.Scope) error {
-	// WARNING: in.Pause requires manual conversion: does not exist in peer-type
-	// WARNING: in.BottlerocketBootstrap requires manual conversion: does not exist in peer-type
-	// WARNING: in.Proxy requires manual conversion: does not exist in peer-type
+	if err := Convert_v1beta2_Pause_To_upstreamv1beta3_Pause(&in.Pause, &out.Pause, s); err != nil {
+		return err
+	}
+	if err := Convert_v1beta2_BottlerocketBootstrap_To_upstreamv1beta3_BottlerocketBootstrap(&in.BottlerocketBootstrap, &out.BottlerocketBootstrap, s); err != nil {
+		return err
+	}
+	if err := Convert_v1beta2_ProxyConfiguration_To_upstreamv1beta3_ProxyConfiguration(&in.Proxy, &out.Proxy, s); err != nil {
+		return err
+	}
+	if err := Convert_v1beta2_RegistryMirrorConfiguration_To_upstreamv1beta3_RegistryMirrorConfiguration(&in.RegistryMirror, &out.RegistryMirror, s); err != nil {
+		return err
+	}
 	if err := Convert_v1beta2_NodeRegistrationOptions_To_upstreamv1beta3_NodeRegistrationOptions(&in.NodeRegistration, &out.NodeRegistration, s); err != nil {
 		return err
 	}
@@ -695,3 +788,58 @@ func autoConvert_v1beta2_Patches_To_upstreamv1beta3_Patches(in *v1beta2.Patches,
 func Convert_v1beta2_Patches_To_upstreamv1beta3_Patches(in *v1beta2.Patches, out *Patches, s conversion.Scope) error {
 	return autoConvert_v1beta2_Patches_To_upstreamv1beta3_Patches(in, out, s)
 }
+
+func autoConvert_upstreamv1beta3_Pause_To_v1beta2_Pause(in *Pause, out *v1beta2.Pause, s conversion.Scope) error {
+	// WARNING: in.ImageMeta requires manual conversion: does not exist in peer-type
+	return nil
+}
+
+func autoConvert_v1beta2_Pause_To_upstreamv1beta3_Pause(in *v1beta2.Pause, out *Pause, s conversion.Scope) error {
+	// WARNING: in.ImageRepository requires manual conversion: does not exist in peer-type
+	// WARNING: in.ImageTag requires manual conversion: does not exist in peer-type
+	return nil
+}
+
+func autoConvert_upstreamv1beta3_ProxyConfiguration_To_v1beta2_ProxyConfiguration(in *ProxyConfiguration, out *v1beta2.ProxyConfiguration, s conversion.Scope) error {
+	out.HTTPSProxy = in.HTTPSProxy
+	out.NoProxy = *(*[]string)(unsafe.Pointer(&in.NoProxy))
+	return nil
+}
+
+// Convert_upstreamv1beta3_ProxyConfiguration_To_v1beta2_ProxyConfiguration is an autogenerated conversion function.
+func Convert_upstreamv1beta3_ProxyConfiguration_To_v1beta2_ProxyConfiguration(in *ProxyConfiguration, out *v1beta2.ProxyConfiguration, s conversion.Scope) error {
+	return autoConvert_upstreamv1beta3_ProxyConfiguration_To_v1beta2_ProxyConfiguration(in, out, s)
+}
+
+func autoConvert_v1beta2_ProxyConfiguration_To_upstreamv1beta3_ProxyConfiguration(in *v1beta2.ProxyConfiguration, out *ProxyConfiguration, s conversion.Scope) error {
+	out.HTTPSProxy = in.HTTPSProxy
+	out.NoProxy = *(*[]string)(unsafe.Pointer(&in.NoProxy))
+	return nil
+}
+
+// Convert_v1beta2_ProxyConfiguration_To_upstreamv1beta3_ProxyConfiguration is an autogenerated conversion function.
+func Convert_v1beta2_ProxyConfiguration_To_upstreamv1beta3_ProxyConfiguration(in *v1beta2.ProxyConfiguration, out *ProxyConfiguration, s conversion.Scope) error {
+	return autoConvert_v1beta2_ProxyConfiguration_To_upstreamv1beta3_ProxyConfiguration(in, out, s)
+}
+
+func autoConvert_upstreamv1beta3_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(in *RegistryMirrorConfiguration, out *v1beta2.RegistryMirrorConfiguration, s conversion.Scope) error {
+	out.Endpoint = in.Endpoint
+	out.CACert = in.CACert
+	return nil
+}
+
+// Convert_upstreamv1beta3_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration is an autogenerated conversion function.
+func Convert_upstreamv1beta3_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(in *RegistryMirrorConfiguration, out *v1beta2.RegistryMirrorConfiguration, s conversion.Scope) error {
+	return autoConvert_upstreamv1beta3_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(in, out, s)
+}
+
+func autoConvert_v1beta2_RegistryMirrorConfiguration_To_upstreamv1beta3_RegistryMirrorConfiguration(in *v1beta2.RegistryMirrorConfiguration, out *RegistryMirrorConfiguration, s conversion.Scope) error {
+	out.Endpoint = in.Endpoint
+	out.CACert = in.CACert
+	return nil
+}
+
+// Convert_v1beta2_RegistryMirrorConfiguration_To_upstreamv1beta3_RegistryMirrorConfiguration is an autogenerated conversion function.
+func Convert_v1beta2_RegistryMirrorConfiguration_To_upstreamv1beta3_RegistryMirrorConfiguration(in *v1beta2.RegistryMirrorConfiguration, out *RegistryMirrorConfiguration, s conversion.Scope) error {
+	return autoConvert_v1beta2_RegistryMirrorConfiguration_To_upstreamv1beta3_RegistryMirrorConfiguration(in, out, s)
+}
diff --git a/bootstrap/kubeadm/types/upstreamv1beta3/zz_generated.deepcopy.go b/bootstrap/kubeadm/types/upstreamv1beta3/zz_generated.deepcopy.go
index ded9eea..68734b7 100644
--- a/bootstrap/kubeadm/types/upstreamv1beta3/zz_generated.deepcopy.go
+++ b/bootstrap/kubeadm/types/upstreamv1beta3/zz_generated.deepcopy.go
@@ -141,10 +141,30 @@ func (in *BootstrapTokenString) DeepCopy() *BootstrapTokenString {
 	return out
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *BottlerocketBootstrap) DeepCopyInto(out *BottlerocketBootstrap) {
+	*out = *in
+	out.ImageMeta = in.ImageMeta
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BottlerocketBootstrap.
+func (in *BottlerocketBootstrap) DeepCopy() *BottlerocketBootstrap {
+	if in == nil {
+		return nil
+	}
+	out := new(BottlerocketBootstrap)
+	in.DeepCopyInto(out)
+	return out
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *ClusterConfiguration) DeepCopyInto(out *ClusterConfiguration) {
 	*out = *in
 	out.TypeMeta = in.TypeMeta
+	out.Pause = in.Pause
+	out.BottlerocketBootstrap = in.BottlerocketBootstrap
+	in.Proxy.DeepCopyInto(&out.Proxy)
+	out.RegistryMirror = in.RegistryMirror
 	in.Etcd.DeepCopyInto(&out.Etcd)
 	out.Networking = in.Networking
 	in.APIServer.DeepCopyInto(&out.APIServer)
@@ -388,6 +408,10 @@ func (in *InitConfiguration) DeepCopyObject() runtime.Object {
 func (in *JoinConfiguration) DeepCopyInto(out *JoinConfiguration) {
 	*out = *in
 	out.TypeMeta = in.TypeMeta
+	out.Pause = in.Pause
+	out.BottlerocketBootstrap = in.BottlerocketBootstrap
+	in.Proxy.DeepCopyInto(&out.Proxy)
+	out.RegistryMirror = in.RegistryMirror
 	in.NodeRegistration.DeepCopyInto(&out.NodeRegistration)
 	in.Discovery.DeepCopyInto(&out.Discovery)
 	if in.ControlPlane != nil {
@@ -537,3 +561,54 @@ func (in *Patches) DeepCopy() *Patches {
 	in.DeepCopyInto(out)
 	return out
 }
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *Pause) DeepCopyInto(out *Pause) {
+	*out = *in
+	out.ImageMeta = in.ImageMeta
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Pause.
+func (in *Pause) DeepCopy() *Pause {
+	if in == nil {
+		return nil
+	}
+	out := new(Pause)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ProxyConfiguration) DeepCopyInto(out *ProxyConfiguration) {
+	*out = *in
+	if in.NoProxy != nil {
+		in, out := &in.NoProxy, &out.NoProxy
+		*out = make([]string, len(*in))
+		copy(*out, *in)
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProxyConfiguration.
+func (in *ProxyConfiguration) DeepCopy() *ProxyConfiguration {
+	if in == nil {
+		return nil
+	}
+	out := new(ProxyConfiguration)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *RegistryMirrorConfiguration) DeepCopyInto(out *RegistryMirrorConfiguration) {
+	*out = *in
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RegistryMirrorConfiguration.
+func (in *RegistryMirrorConfiguration) DeepCopy() *RegistryMirrorConfiguration {
+	if in == nil {
+		return nil
+	}
+	out := new(RegistryMirrorConfiguration)
+	in.DeepCopyInto(out)
+	return out
+}
diff --git a/bootstrap/kubeadm/types/upstreamv1beta4/zz_generated.conversion.go b/bootstrap/kubeadm/types/upstreamv1beta4/zz_generated.conversion.go
index 44ec722..0c903b8 100644
--- a/bootstrap/kubeadm/types/upstreamv1beta4/zz_generated.conversion.go
+++ b/bootstrap/kubeadm/types/upstreamv1beta4/zz_generated.conversion.go
@@ -506,6 +506,7 @@ func autoConvert_v1beta2_ClusterConfiguration_To_upstreamv1beta4_ClusterConfigur
 	if err := Convert_v1beta2_ProxyConfiguration_To_upstreamv1beta4_Proxy(&in.Proxy, &out.Proxy, s); err != nil {
 		return err
 	}
+	// WARNING: in.RegistryMirror requires manual conversion: does not exist in peer-type
 	if err := Convert_v1beta2_Etcd_To_upstreamv1beta4_Etcd(&in.Etcd, &out.Etcd, s); err != nil {
 		return err
 	}
@@ -760,6 +761,7 @@ func autoConvert_v1beta2_JoinConfiguration_To_upstreamv1beta4_JoinConfiguration(
 	if err := Convert_v1beta2_ProxyConfiguration_To_upstreamv1beta4_Proxy(&in.Proxy, &out.Proxy, s); err != nil {
 		return err
 	}
+	// WARNING: in.RegistryMirror requires manual conversion: does not exist in peer-type
 	if err := Convert_v1beta2_NodeRegistrationOptions_To_upstreamv1beta4_NodeRegistrationOptions(&in.NodeRegistration, &out.NodeRegistration, s); err != nil {
 		return err
 	}
diff --git a/cmd/clusterctl/client/cluster/mover.go b/cmd/clusterctl/client/cluster/mover.go
index 08bf16d..7a39750 100644
--- a/cmd/clusterctl/client/cluster/mover.go
+++ b/cmd/clusterctl/client/cluster/mover.go
@@ -272,7 +272,10 @@ func (o *objectMover) checkProvisioningCompleted(ctx context.Context, graph *obj
 		}
 
 		if !machineObj.Status.NodeRef.IsDefined() {
-			errList = append(errList, errors.Errorf("cannot start the move operation while %q %s/%s is still provisioning the node", machineObj.GroupVersionKind(), machineObj.GetNamespace(), machineObj.GetName()))
+			_, isEtcdMachine := machineObj.Labels[clusterv1.MachineEtcdClusterLabelName]
+			if machineObj.Status.NodeRef.IsDefined() && !isEtcdMachine {
+				errList = append(errList, errors.Errorf("cannot start the move operation while %q %s/%s is still provisioning the node", machineObj.GroupVersionKind(), machineObj.GetNamespace(), machineObj.GetName()))
+			}
 		}
 	}
 
diff --git a/config/crd/bases/cluster.x-k8s.io_clusters.yaml b/config/crd/bases/cluster.x-k8s.io_clusters.yaml
index 6bae359..791dced 100644
--- a/config/crd/bases/cluster.x-k8s.io_clusters.yaml
+++ b/config/crd/bases/cluster.x-k8s.io_clusters.yaml
@@ -191,6 +191,51 @@ spec:
                     type: string
                 type: object
                 x-kubernetes-map-type: atomic
+              managedExternalEtcdRef:
+                description: |-
+                  ManagedExternalEtcdRef is an optional reference to an etcd provider resource that holds details
+                  for provisioning an external etcd cluster
+                properties:
+                  apiVersion:
+                    description: API version of the referent.
+                    type: string
+                  fieldPath:
+                    description: |-
+                      If referring to a piece of an object instead of an entire object, this string
+                      should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
+                      For example, if the object reference is to a container within a pod, this would take on a value like:
+                      "spec.containers{name}" (where "name" refers to the name of the container that triggered
+                      the event) or if no container name is specified "spec.containers[2]" (container with
+                      index 2 in this pod). This syntax is chosen only to have some well-defined way of
+                      referencing a part of an object.
+                    type: string
+                  kind:
+                    description: |-
+                      Kind of the referent.
+                      More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
+                    type: string
+                  name:
+                    description: |-
+                      Name of the referent.
+                      More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
+                    type: string
+                  namespace:
+                    description: |-
+                      Namespace of the referent.
+                      More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
+                    type: string
+                  resourceVersion:
+                    description: |-
+                      Specific resourceVersion to which this reference is made, if any.
+                      More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
+                    type: string
+                  uid:
+                    description: |-
+                      UID of the referent.
+                      More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
+                    type: string
+                type: object
+                x-kubernetes-map-type: atomic
               paused:
                 description: paused can be used to prevent controllers from processing
                   the Cluster and all its associated objects.
@@ -285,6 +330,15 @@ spec:
                 description: infrastructureReady is the state of the infrastructure
                   provider.
                 type: boolean
+              managedExternalEtcdInitialized:
+                description: |-
+                  ManagedExternalEtcdInitialized indicates that first etcd member's IP address is set by machine controller,
+                  so remaining etcd members can lookup the address to join the cluster
+                type: boolean
+              managedExternalEtcdReady:
+                description: ManagedExternalEtcdReady indicates external etcd cluster
+                  is fully provisioned
+                type: boolean
               observedGeneration:
                 description: observedGeneration is the latest generation observed
                   by the controller.
@@ -481,6 +535,51 @@ spec:
                     type: string
                 type: object
                 x-kubernetes-map-type: atomic
+              managedExternalEtcdRef:
+                description: |-
+                  ManagedExternalEtcdRef is an optional reference to an etcd provider resource that holds details
+                  for provisioning an external etcd cluster
+                properties:
+                  apiVersion:
+                    description: API version of the referent.
+                    type: string
+                  fieldPath:
+                    description: |-
+                      If referring to a piece of an object instead of an entire object, this string
+                      should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
+                      For example, if the object reference is to a container within a pod, this would take on a value like:
+                      "spec.containers{name}" (where "name" refers to the name of the container that triggered
+                      the event) or if no container name is specified "spec.containers[2]" (container with
+                      index 2 in this pod). This syntax is chosen only to have some well-defined way of
+                      referencing a part of an object.
+                    type: string
+                  kind:
+                    description: |-
+                      Kind of the referent.
+                      More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
+                    type: string
+                  name:
+                    description: |-
+                      Name of the referent.
+                      More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
+                    type: string
+                  namespace:
+                    description: |-
+                      Namespace of the referent.
+                      More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
+                    type: string
+                  resourceVersion:
+                    description: |-
+                      Specific resourceVersion to which this reference is made, if any.
+                      More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
+                    type: string
+                  uid:
+                    description: |-
+                      UID of the referent.
+                      More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
+                    type: string
+                type: object
+                x-kubernetes-map-type: atomic
               paused:
                 description: paused can be used to prevent controllers from processing
                   the Cluster and all its associated objects.
@@ -698,6 +797,15 @@ spec:
                 description: infrastructureReady is the state of the infrastructure
                   provider.
                 type: boolean
+              managedExternalEtcdInitialized:
+                description: |-
+                  ManagedExternalEtcdInitialized indicates that first etcd member's IP address is set by machine controller,
+                  so remaining etcd members can lookup the address to join the cluster
+                type: boolean
+              managedExternalEtcdReady:
+                description: ManagedExternalEtcdReady indicates external etcd cluster
+                  is fully provisioned
+                type: boolean
               observedGeneration:
                 description: observedGeneration is the latest generation observed
                   by the controller.
@@ -949,6 +1057,51 @@ spec:
                     type: string
                 type: object
                 x-kubernetes-map-type: atomic
+              managedExternalEtcdRef:
+                description: |-
+                  ManagedExternalEtcdRef is an optional reference to an etcd provider resource that holds details
+                  for provisioning an external etcd cluster
+                properties:
+                  apiVersion:
+                    description: API version of the referent.
+                    type: string
+                  fieldPath:
+                    description: |-
+                      If referring to a piece of an object instead of an entire object, this string
+                      should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
+                      For example, if the object reference is to a container within a pod, this would take on a value like:
+                      "spec.containers{name}" (where "name" refers to the name of the container that triggered
+                      the event) or if no container name is specified "spec.containers[2]" (container with
+                      index 2 in this pod). This syntax is chosen only to have some well-defined way of
+                      referencing a part of an object.
+                    type: string
+                  kind:
+                    description: |-
+                      Kind of the referent.
+                      More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
+                    type: string
+                  name:
+                    description: |-
+                      Name of the referent.
+                      More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
+                    type: string
+                  namespace:
+                    description: |-
+                      Namespace of the referent.
+                      More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
+                    type: string
+                  resourceVersion:
+                    description: |-
+                      Specific resourceVersion to which this reference is made, if any.
+                      More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
+                    type: string
+                  uid:
+                    description: |-
+                      UID of the referent.
+                      More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
+                    type: string
+                type: object
+                x-kubernetes-map-type: atomic
               paused:
                 description: paused can be used to prevent controllers from processing
                   the Cluster and all its associated objects.
@@ -1986,6 +2139,15 @@ spec:
                 description: infrastructureReady is the state of the infrastructure
                   provider.
                 type: boolean
+              managedExternalEtcdInitialized:
+                description: |-
+                  ManagedExternalEtcdInitialized indicates that first etcd member's IP address is set by machine controller,
+                  so remaining etcd members can lookup the address to join the cluster
+                type: boolean
+              managedExternalEtcdReady:
+                description: ManagedExternalEtcdReady indicates external etcd cluster
+                  is fully provisioned
+                type: boolean
               observedGeneration:
                 description: observedGeneration is the latest generation observed
                   by the controller.
@@ -2423,6 +2585,42 @@ spec:
                 - kind
                 - name
                 type: object
+              managedExternalEtcdRef:
+                description: |-
+                  ManagedExternalEtcdRef is an optional reference to an etcd provider resource that holds details
+                  for provisioning an external etcd cluster
+                properties:
+                  apiGroup:
+                    description: |-
+                      apiGroup is the group of the resource being referenced.
+                      apiGroup must be fully qualified domain name.
+                      The corresponding version for this reference will be looked up from the contract
+                      labels of the corresponding CRD of the resource being referenced.
+                    maxLength: 253
+                    minLength: 1
+                    pattern: ^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
+                    type: string
+                  kind:
+                    description: |-
+                      kind of the resource being referenced.
+                      kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
+                    maxLength: 63
+                    minLength: 1
+                    pattern: ^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$
+                    type: string
+                  name:
+                    description: |-
+                      name of the resource being referenced.
+                      name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
+                    maxLength: 253
+                    minLength: 1
+                    pattern: ^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
+                    type: string
+                required:
+                - apiGroup
+                - kind
+                - name
+                type: object
               paused:
                 description: paused can be used to prevent controllers from processing
                   the Cluster and all its associated objects.
@@ -3705,6 +3903,15 @@ spec:
                       The value of this field is never updated after provisioning is completed.
                     type: boolean
                 type: object
+              managedExternalEtcdInitialized:
+                description: |-
+                  ManagedExternalEtcdInitialized indicates that first etcd member's IP address is set by machine controller,
+                  so remaining etcd members can lookup the address to join the cluster
+                type: boolean
+              managedExternalEtcdReady:
+                description: ManagedExternalEtcdReady indicates external etcd cluster
+                  is fully provisioned
+                type: boolean
               observedGeneration:
                 description: observedGeneration is the latest generation observed
                   by the controller.
diff --git a/config/rbac/role.yaml b/config/rbac/role.yaml
index af20d5e..1d92684 100644
--- a/config/rbac/role.yaml
+++ b/config/rbac/role.yaml
@@ -54,6 +54,7 @@ rules:
   - addons.cluster.x-k8s.io
   - bootstrap.cluster.x-k8s.io
   - controlplane.cluster.x-k8s.io
+  - etcdcluster.cluster.x-k8s.io
   - infrastructure.cluster.x-k8s.io
   resources:
   - '*'
diff --git a/controllers/external/util.go b/controllers/external/util.go
index d2bc132..6ffec07 100644
--- a/controllers/external/util.go
+++ b/controllers/external/util.go
@@ -267,6 +267,16 @@ func FailuresFrom(obj *unstructured.Unstructured) (string, string, error) {
 	return failureReason, failureMessage, nil
 }
 
+// IsInitialized returns true if the Status.Initialized field on an external object is true.
+func IsInitialized(obj *unstructured.Unstructured) (bool, error) {
+	initialized, found, err := unstructured.NestedBool(obj.Object, "status", "initialized")
+	if err != nil {
+		return false, errors.Wrapf(err, "failed to determine %v %q initialized",
+			obj.GroupVersionKind(), obj.GetName())
+	}
+	return initialized && found, nil
+}
+
 // IsReady returns true if the Status.Ready field on an external object is true.
 func IsReady(obj *unstructured.Unstructured) (bool, error) {
 	ready, found, err := unstructured.NestedBool(obj.Object, "status", "ready")
@@ -276,3 +286,42 @@ func IsReady(obj *unstructured.Unstructured) (bool, error) {
 	}
 	return ready && found, nil
 }
+
+func GetExternalEtcdEndpoints(externalEtcd *unstructured.Unstructured) (string, bool, error) {
+	endpoints, found, err := unstructured.NestedString(externalEtcd.Object, "status", "endpoints")
+	if err != nil {
+		return "", false, errors.Wrapf(err, "failed to get external etcd endpoints from %v %q", externalEtcd.GroupVersionKind(),
+			externalEtcd.GetName())
+	}
+
+	return endpoints, found, nil
+}
+
+func IsExternalEtcdUpgrading(externalEtcd *unstructured.Unstructured) (bool, error) {
+	annotations, hasAnnotations, err := unstructured.NestedStringMap(externalEtcd.Object, "metadata", "annotations")
+	if err != nil {
+		return false, errors.Wrapf(err, "failed to check if external etcd is undergoing upgrade %v %q", externalEtcd.GroupVersionKind(),
+			externalEtcd.GetName())
+	}
+
+	if !hasAnnotations {
+		return false, nil
+	}
+
+	_, hasUpgradingAnnotation := annotations["etcdcluster.cluster.x-k8s.io/upgrading"]
+	return hasUpgradingAnnotation, nil
+}
+
+func SetKCPUpdateCompleteAnnotationOnEtcdadmCluster(externalEtcd *unstructured.Unstructured) error {
+	annotations, hasAnnotations, err := unstructured.NestedStringMap(externalEtcd.Object, "metadata", "annotations")
+	if err != nil {
+		return errors.Wrapf(err, "failed to update external etcd annotation after controlplane upgrade completed %v %q", externalEtcd.GroupVersionKind(),
+			externalEtcd.GetName())
+	}
+
+	if !hasAnnotations {
+		annotations = make(map[string]string)
+	}
+	annotations[clusterv1.ControlPlaneUpgradeCompletedAnnotation] = "true"
+	return unstructured.SetNestedStringMap(externalEtcd.UnstructuredContent(), annotations, "metadata", "annotations")
+}
diff --git a/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanes.yaml b/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanes.yaml
index 2a2d184..cf2e868 100644
--- a/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanes.yaml
+++ b/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanes.yaml
@@ -1594,6 +1594,20 @@ spec:
                               type: string
                             type: array
                         type: object
+                      registryMirror:
+                        description: |-
+                          RegistryMirror holds the image registry mirror information
+                          This is only for bottlerocket
+                        properties:
+                          caCert:
+                            description: CACert defines the CA cert for the registry
+                              mirror
+                            type: string
+                          endpoint:
+                            description: Endpoint defines the registry mirror endpoint
+                              to use for pulling images
+                            type: string
+                        type: object
                       scheduler:
                         description: scheduler contains extra settings for the scheduler
                           control plane component
@@ -2163,6 +2177,20 @@ spec:
                               type: string
                             type: array
                         type: object
+                      registryMirror:
+                        description: |-
+                          RegistryMirror holds the image registry mirror information
+                          This is only for bottlerocket
+                        properties:
+                          caCert:
+                            description: CACert defines the CA cert for the registry
+                              mirror
+                            type: string
+                          endpoint:
+                            description: Endpoint defines the registry mirror endpoint
+                              to use for pulling images
+                            type: string
+                        type: object
                     type: object
                   mounts:
                     description: mounts specifies a list of mount points to be setup.
@@ -3388,6 +3416,20 @@ spec:
                               type: string
                             type: array
                         type: object
+                      registryMirror:
+                        description: |-
+                          RegistryMirror holds the image registry mirror information
+                          This is only for bottlerocket
+                        properties:
+                          caCert:
+                            description: CACert defines the CA cert for the registry
+                              mirror
+                            type: string
+                          endpoint:
+                            description: Endpoint defines the registry mirror endpoint
+                              to use for pulling images
+                            type: string
+                        type: object
                       scheduler:
                         description: scheduler contains extra settings for the scheduler
                           control plane component
@@ -4440,6 +4482,20 @@ spec:
                               type: string
                             type: array
                         type: object
+                      registryMirror:
+                        description: |-
+                          RegistryMirror holds the image registry mirror information
+                          This is only for bottlerocket
+                        properties:
+                          caCert:
+                            description: CACert defines the CA cert for the registry
+                              mirror
+                            type: string
+                          endpoint:
+                            description: Endpoint defines the registry mirror endpoint
+                              to use for pulling images
+                            type: string
+                        type: object
                       skipPhases:
                         description: |-
                           skipPhases is a list of phases to skip during command execution.
@@ -6095,6 +6151,20 @@ spec:
                               type: string
                             type: array
                         type: object
+                      registryMirror:
+                        description: |-
+                          RegistryMirror holds the image registry mirror information
+                          This is only for bottlerocket
+                        properties:
+                          caCert:
+                            description: CACert defines the CA cert for the registry
+                              mirror
+                            type: string
+                          endpoint:
+                            description: Endpoint defines the registry mirror endpoint
+                              to use for pulling images
+                            type: string
+                        type: object
                       scheduler:
                         description: scheduler contains extra settings for the scheduler
                           control plane component
@@ -7295,6 +7365,20 @@ spec:
                               type: string
                             type: array
                         type: object
+                      registryMirror:
+                        description: |-
+                          RegistryMirror holds the image registry mirror information
+                          This is only for bottlerocket
+                        properties:
+                          caCert:
+                            description: CACert defines the CA cert for the registry
+                              mirror
+                            type: string
+                          endpoint:
+                            description: Endpoint defines the registry mirror endpoint
+                              to use for pulling images
+                            type: string
+                        type: object
                       skipPhases:
                         description: |-
                           skipPhases is a list of phases to skip during command execution.
diff --git a/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanetemplates.yaml b/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanetemplates.yaml
index 9d5b836..8b8d415 100644
--- a/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanetemplates.yaml
+++ b/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanetemplates.yaml
@@ -386,6 +386,20 @@ spec:
                                       type: string
                                     type: array
                                 type: object
+                              registryMirror:
+                                description: |-
+                                  RegistryMirror holds the image registry mirror information
+                                  This is only for bottlerocket
+                                properties:
+                                  caCert:
+                                    description: CACert defines the CA cert for the
+                                      registry mirror
+                                    type: string
+                                  endpoint:
+                                    description: Endpoint defines the registry mirror
+                                      endpoint to use for pulling images
+                                    type: string
+                                type: object
                               scheduler:
                                 description: scheduler contains extra settings for
                                   the scheduler control plane component
@@ -964,6 +978,20 @@ spec:
                                       type: string
                                     type: array
                                 type: object
+                              registryMirror:
+                                description: |-
+                                  RegistryMirror holds the image registry mirror information
+                                  This is only for bottlerocket
+                                properties:
+                                  caCert:
+                                    description: CACert defines the CA cert for the
+                                      registry mirror
+                                    type: string
+                                  endpoint:
+                                    description: Endpoint defines the registry mirror
+                                      endpoint to use for pulling images
+                                    type: string
+                                type: object
                             type: object
                           mounts:
                             description: mounts specifies a list of mount points to
@@ -2094,6 +2122,20 @@ spec:
                                       type: string
                                     type: array
                                 type: object
+                              registryMirror:
+                                description: |-
+                                  RegistryMirror holds the image registry mirror information
+                                  This is only for bottlerocket
+                                properties:
+                                  caCert:
+                                    description: CACert defines the CA cert for the
+                                      registry mirror
+                                    type: string
+                                  endpoint:
+                                    description: Endpoint defines the registry mirror
+                                      endpoint to use for pulling images
+                                    type: string
+                                type: object
                               scheduler:
                                 description: scheduler contains extra settings for
                                   the scheduler control plane component
@@ -3165,6 +3207,20 @@ spec:
                                       type: string
                                     type: array
                                 type: object
+                              registryMirror:
+                                description: |-
+                                  RegistryMirror holds the image registry mirror information
+                                  This is only for bottlerocket
+                                properties:
+                                  caCert:
+                                    description: CACert defines the CA cert for the
+                                      registry mirror
+                                    type: string
+                                  endpoint:
+                                    description: Endpoint defines the registry mirror
+                                      endpoint to use for pulling images
+                                    type: string
+                                type: object
                               skipPhases:
                                 description: |-
                                   skipPhases is a list of phases to skip during command execution.
@@ -4487,6 +4543,20 @@ spec:
                                       type: string
                                     type: array
                                 type: object
+                              registryMirror:
+                                description: |-
+                                  RegistryMirror holds the image registry mirror information
+                                  This is only for bottlerocket
+                                properties:
+                                  caCert:
+                                    description: CACert defines the CA cert for the
+                                      registry mirror
+                                    type: string
+                                  endpoint:
+                                    description: Endpoint defines the registry mirror
+                                      endpoint to use for pulling images
+                                    type: string
+                                type: object
                               scheduler:
                                 description: scheduler contains extra settings for
                                   the scheduler control plane component
@@ -5709,6 +5779,20 @@ spec:
                                       type: string
                                     type: array
                                 type: object
+                              registryMirror:
+                                description: |-
+                                  RegistryMirror holds the image registry mirror information
+                                  This is only for bottlerocket
+                                properties:
+                                  caCert:
+                                    description: CACert defines the CA cert for the
+                                      registry mirror
+                                    type: string
+                                  endpoint:
+                                    description: Endpoint defines the registry mirror
+                                      endpoint to use for pulling images
+                                    type: string
+                                type: object
                               skipPhases:
                                 description: |-
                                   skipPhases is a list of phases to skip during command execution.
diff --git a/controlplane/kubeadm/config/rbac/role.yaml b/controlplane/kubeadm/config/rbac/role.yaml
index ba9d19f..4f91c17 100644
--- a/controlplane/kubeadm/config/rbac/role.yaml
+++ b/controlplane/kubeadm/config/rbac/role.yaml
@@ -90,3 +90,12 @@ rules:
   - patch
   - update
   - watch
+- apiGroups:
+  - etcdcluster.cluster.x-k8s.io
+  resources:
+  - '*'
+  verbs:
+  - get
+  - list
+  - update
+  - watch
diff --git a/controlplane/kubeadm/internal/controllers/controller.go b/controlplane/kubeadm/internal/controllers/controller.go
index ec7502a..05f6f0d 100644
--- a/controlplane/kubeadm/internal/controllers/controller.go
+++ b/controlplane/kubeadm/internal/controllers/controller.go
@@ -19,11 +19,13 @@ package controllers
 import (
 	"context"
 	"fmt"
+	"reflect"
 	"sort"
 	"strings"
 	"time"
 
 	"github.com/blang/semver/v4"
+	"github.com/go-logr/logr"
 	"github.com/pkg/errors"
 	"go.uber.org/zap"
 	corev1 "k8s.io/api/core/v1"
@@ -45,6 +47,7 @@ import (
 	controlplanev1 "sigs.k8s.io/cluster-api/api/controlplane/kubeadm/v1beta2"
 	clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta2"
 	"sigs.k8s.io/cluster-api/controllers/clustercache"
+	"sigs.k8s.io/cluster-api/controllers/external"
 	"sigs.k8s.io/cluster-api/controlplane/kubeadm/internal"
 	"sigs.k8s.io/cluster-api/feature"
 	"sigs.k8s.io/cluster-api/internal/contract"
@@ -74,6 +77,7 @@ const (
 // +kubebuilder:rbac:groups=cluster.x-k8s.io,resources=machines;machines/status,verbs=get;list;watch;create;update;patch;delete
 // +kubebuilder:rbac:groups=cluster.x-k8s.io,resources=machinepools,verbs=get;list;watch
 // +kubebuilder:rbac:groups=apiextensions.k8s.io,resources=customresourcedefinitions,verbs=get;list;watch
+// +kubebuilder:rbac:groups=etcdcluster.cluster.x-k8s.io,resources=*,verbs=get;list;watch;update
 
 // KubeadmControlPlaneReconciler reconciles a KubeadmControlPlane object.
 type KubeadmControlPlaneReconciler struct {
@@ -197,6 +201,15 @@ func (r *KubeadmControlPlaneReconciler) Reconcile(ctx context.Context, req ctrl.
 		log.Error(err, "Failed to configure the patch helper")
 		return ctrl.Result{Requeue: true}, nil
 	}
+	if cluster.Spec.ManagedExternalEtcdRef.IsDefined() {
+		managedEtcdResult, err := r.updateManagedExternalEtcdEndpoints(ctx, log, patchHelper, cluster, kcp)
+		if err != nil {
+			return ctrl.Result{}, err
+		}
+		if !managedEtcdResult.IsZero() {
+			return managedEtcdResult, nil
+		}
+	}
 
 	if isPaused, requeue, err := paused.EnsurePausedCondition(ctx, r.Client, cluster, kcp); err != nil || isPaused || requeue {
 		return ctrl.Result{}, err
@@ -482,6 +495,25 @@ func (r *KubeadmControlPlaneReconciler) reconcile(ctx context.Context, controlPl
 		// NOTE: we are checking the condition already exists in order to avoid to set this condition at the first
 		// reconciliation/before a rolling upgrade actually starts.
 		if v1beta1conditions.Has(controlPlane.KCP, controlplanev1.MachinesSpecUpToDateV1Beta1Condition) {
+			if v1beta1conditions.IsFalse(controlPlane.KCP, controlplanev1.MachinesSpecUpToDateV1Beta1Condition) {
+				/* Once KCP upgrade has completed, the controller will annotate the external etcd object to indicate that the older KCP machines
+				are no longer part of the cluster, and so any older out-of-date etcd members and machines can be deleted
+				*/
+				if controlPlane.Cluster.Spec.ManagedExternalEtcdRef.IsDefined() {
+					etcdRef := controlPlane.Cluster.Spec.ManagedExternalEtcdRef
+					externalEtcd, err := external.GetObjectFromContractVersionedRef(ctx, r.Client, etcdRef, controlPlane.Cluster.Namespace)
+					if err != nil {
+						return ctrl.Result{}, err
+					}
+					log.Info("Adding upgrade complete annotation on etcdadmCluster")
+					if err := external.SetKCPUpdateCompleteAnnotationOnEtcdadmCluster(externalEtcd); err != nil {
+						return ctrl.Result{}, err
+					}
+					if err := r.Client.Update(ctx, externalEtcd); err != nil {
+						return ctrl.Result{}, err
+					}
+				}
+			}
 			v1beta1conditions.MarkTrue(controlPlane.KCP, controlplanev1.MachinesSpecUpToDateV1Beta1Condition)
 		}
 	}
@@ -584,6 +616,21 @@ func (r *KubeadmControlPlaneReconciler) reconcileDelete(ctx context.Context, con
 	log := ctrl.LoggerFrom(ctx)
 	log.Info("Reconcile KubeadmControlPlane deletion")
 
+	// Gets all machines, not just control plane machines.
+	allMachines, err := r.managementCluster.GetMachinesForCluster(ctx, controlPlane.Cluster)
+	if err != nil {
+		return ctrl.Result{}, err
+	}
+
+	if controlPlane.Cluster.Spec.ManagedExternalEtcdRef.IsDefined() {
+		for _, machine := range allMachines {
+			if util.IsEtcdMachine(machine) {
+				// remove external etcd-only machines from the "allMachines" collection so that the controlplane machines don't wait for etcd to be deleted first
+				delete(allMachines, machine.Name)
+			}
+		}
+	}
+
 	// If no control plane machines remain, remove the finalizer
 	if len(controlPlane.Machines) == 0 {
 		controlPlane.DeletingReason = controlplanev1.KubeadmControlPlaneDeletingDeletionCompletedReason
@@ -605,14 +652,6 @@ func (r *KubeadmControlPlaneReconciler) reconcileDelete(ctx context.Context, con
 	// all the machines are deleted in parallel.
 	v1beta1conditions.SetAggregate(controlPlane.KCP, controlplanev1.MachinesReadyV1Beta1Condition, controlPlane.Machines.ConditionGetters(), v1beta1conditions.AddSourceRef())
 
-	// Gets all machines, not just control plane machines.
-	allMachines, err := r.managementCluster.GetMachinesForCluster(ctx, controlPlane.Cluster)
-	if err != nil {
-		controlPlane.DeletingReason = controlplanev1.KubeadmControlPlaneDeletingInternalErrorReason
-		controlPlane.DeletingMessage = "Please check controller logs for errors" //nolint:goconst // Not making this a constant for now
-		return ctrl.Result{}, err
-	}
-
 	allMachinePools := &clusterv1.MachinePoolList{}
 	// Get all machine pools.
 	if feature.Gates.Enabled(feature.MachinePool) {
@@ -1449,3 +1488,76 @@ func (r *KubeadmControlPlaneReconciler) ensureCertificatesOwnerRef(ctx context.C
 	}
 	return nil
 }
+
+func (r *KubeadmControlPlaneReconciler) updateManagedExternalEtcdEndpoints(
+	ctx context.Context, log logr.Logger, patchHelper *patch.Helper, cluster *clusterv1.Cluster, kcp *controlplanev1.KubeadmControlPlane,
+) (ctrl.Result, error) {
+	if !kcp.Spec.KubeadmConfigSpec.ClusterConfiguration.IsDefined() || !kcp.Spec.KubeadmConfigSpec.ClusterConfiguration.Etcd.External.IsDefined() {
+		return ctrl.Result{}, errors.New("invalid kcp, external etcd not configured for cluster with managed external etcd")
+	}
+
+	etcdRef := cluster.Spec.ManagedExternalEtcdRef
+	externalEtcd, err := external.GetObjectFromContractVersionedRef(ctx, r.Client, etcdRef, cluster.Namespace)
+	if err != nil {
+		return ctrl.Result{}, err
+	}
+
+	externalEtcdReady, err := external.IsReady(externalEtcd)
+	if err != nil {
+		return ctrl.Result{}, err
+	}
+
+	if !externalEtcdReady {
+		log.Info("Managed external etcd is not ready yet, requeueing")
+		return ctrl.Result{RequeueAfter: 1 * time.Minute}, nil
+	}
+
+	endpoints, found, err := external.GetExternalEtcdEndpoints(externalEtcd)
+	if err != nil {
+		return ctrl.Result{}, errors.Wrapf(err, "failed to get endpoint field from %v", externalEtcd.GetName())
+	}
+	currentEtcdEndpoints := strings.Split(endpoints, ",")
+
+	if !found || areEndpointsEmpty(currentEtcdEndpoints) {
+		log.Info("Managed external etcd endpoints not available, requeueing")
+		return ctrl.Result{RequeueAfter: 1 * time.Minute}, nil
+	}
+
+	sort.Strings(currentEtcdEndpoints)
+	currentKCPEndpoints := kcp.Spec.KubeadmConfigSpec.ClusterConfiguration.Etcd.External.Endpoints
+	if !reflect.DeepEqual(currentEtcdEndpoints, currentKCPEndpoints) {
+		/* During upgrade, KCP spec's endpoints will again be an empty list, and will get populated by the cluster controller once the
+		external etcd controller has set them. If the KCP controller proceeds without checking whether the etcd cluster is undergoing upgrade,
+		there is a chance it will get the current un-updated endpoints from the etcd cluster object, and those would end up being endpoints of the
+		etcd members that will get deleted during upgrade. Hence the controller checks and stalls if the etcd cluster is undergoing upgrade and proceeds
+		only after the etcd upgrade is completed as that guarantees that the KCP has latest set of endpoints.
+		*/
+		etcdUpgradeInProgress, err := external.IsExternalEtcdUpgrading(externalEtcd)
+		if err != nil {
+			return ctrl.Result{}, err
+		}
+		if etcdUpgradeInProgress {
+			log.Info("Etcd undergoing upgrade, marking etcd endpoints available condition as false, since new endpoints will be available only after etcd upgrade")
+			if conditions.IsTrue(kcp, string(controlplanev1.ExternalEtcdEndpointsAvailable)) || conditions.IsUnknown(kcp, string(controlplanev1.ExternalEtcdEndpointsAvailable)) {
+				v1beta1conditions.MarkFalse(kcp, controlplanev1.ExternalEtcdEndpointsAvailable, controlplanev1.ExternalEtcdUndergoingUpgrade, clusterv1.ConditionSeverityInfo, "")
+				if err := patchKubeadmControlPlane(ctx, patchHelper, kcp); err != nil {
+					return ctrl.Result{}, err
+				}
+			}
+			return ctrl.Result{RequeueAfter: 1 * time.Minute}, nil
+		}
+		kcp.Spec.KubeadmConfigSpec.ClusterConfiguration.Etcd.External.Endpoints = currentEtcdEndpoints
+		if err := patchHelper.Patch(ctx, kcp); err != nil {
+			log.Error(err, "Failed to patch KubeadmControlPlane to update external etcd endpoints")
+			return ctrl.Result{}, err
+		}
+	}
+	if conditions.IsFalse(kcp, string(controlplanev1.ExternalEtcdEndpointsAvailable)) {
+		v1beta1conditions.MarkTrue(kcp, controlplanev1.ExternalEtcdEndpointsAvailable)
+	}
+	return ctrl.Result{}, nil
+}
+
+func areEndpointsEmpty(endpoints []string) bool {
+	return len(endpoints) == 0 || len(endpoints) == 1 && endpoints[0] == ""
+}
diff --git a/controlplane/kubeadm/internal/controllers/controller_test.go b/controlplane/kubeadm/internal/controllers/controller_test.go
index 4f2f820..ea598f3 100644
--- a/controlplane/kubeadm/internal/controllers/controller_test.go
+++ b/controlplane/kubeadm/internal/controllers/controller_test.go
@@ -25,6 +25,7 @@ import (
 	"fmt"
 	"math/big"
 	"path"
+	"strings"
 	"sync"
 	"testing"
 	"time"
@@ -58,6 +59,7 @@ import (
 	"sigs.k8s.io/cluster-api/internal/util/ssa"
 	"sigs.k8s.io/cluster-api/internal/webhooks"
 	"sigs.k8s.io/cluster-api/util"
+	"sigs.k8s.io/cluster-api/util/annotations"
 	"sigs.k8s.io/cluster-api/util/certs"
 	"sigs.k8s.io/cluster-api/util/collections"
 	"sigs.k8s.io/cluster-api/util/conditions"
@@ -3308,9 +3310,9 @@ func TestKubeadmControlPlaneReconciler_reconcilePreTerminateHook(t *testing.T) {
 				Client: fakeClient,
 			}
 
-			workloadCluster := fakeWorkloadCluster{}
+			workloadCluster := &fakeWorkloadCluster{}
 			tt.controlPlane.InjectTestManagementCluster(&fakeManagementCluster{
-				Workload: &workloadCluster,
+				Workload: workloadCluster,
 			})
 
 			res, err := r.reconcilePreTerminateHook(ctx, tt.controlPlane)
@@ -3872,6 +3874,214 @@ func TestKubeadmControlPlaneReconciler_reconcileDelete(t *testing.T) {
 	})
 }
 
+func TestKubeadmControlPlaneReconciler_updateManagedExternalEtcdEndpoints(t *testing.T) {
+	setup := func() (*clusterv1.Cluster, *controlplanev1.KubeadmControlPlane, *unstructured.Unstructured) {
+		ns := "my-ns"
+		endpoints := []string{"1.1.1.1", "2.2.2.2", "0.0.0.0"}
+		managedEtcd := builder.Etcd(ns, "test-7-my-etcd").Build()
+		unstructured.SetNestedField(managedEtcd.Object, true, "status", "ready")
+		unstructured.SetNestedField(managedEtcd.Object, strings.Join(endpoints, ","), "status", "endpoints")
+		cluster, kcp, _ := createClusterWithControlPlane(ns)
+		cluster.Spec.ManagedExternalEtcdRef = clusterv1.ContractVersionedObjectReference{
+			APIGroup: managedEtcd.GroupVersionKind().Group,
+			Kind:     managedEtcd.GetKind(),
+			Name:     managedEtcd.GetName(),
+		}
+		kcp.Spec.KubeadmConfigSpec.ClusterConfiguration = bootstrapv1.ClusterConfiguration{
+			Etcd: bootstrapv1.Etcd{External: bootstrapv1.ExternalEtcd{}},
+		}
+
+		return cluster, kcp, managedEtcd
+	}
+	t.Run("should update the endpoints in the kcp", func(t *testing.T) {
+		g := NewWithT(t)
+		cluster, kcp, managedEtcd := setup()
+		v1beta1conditions.MarkFalse(kcp, controlplanev1.ExternalEtcdEndpointsAvailable, "", "", "")
+
+		fClient := newFakeClient(
+			builder.GenericEtcdCRD.DeepCopy(),
+			managedEtcd.DeepCopy(),
+			cluster.DeepCopy(),
+			kcp.DeepCopy(),
+		)
+
+		r := &KubeadmControlPlaneReconciler{
+			Client: fClient,
+			managementCluster: &fakeManagementCluster{
+				Management: &internal.Management{Client: fClient},
+				Workload:   &fakeWorkloadCluster{},
+			},
+			recorder: record.NewFakeRecorder(32),
+		}
+
+		result, err := r.Reconcile(
+			ctx,
+			ctrl.Request{client.ObjectKeyFromObject(kcp)},
+		)
+		g.Expect(result).To(Equal(ctrl.Result{}))
+		g.Expect(err).NotTo(HaveOccurred())
+		g.Eventually(func(g Gomega) {
+			cp := &controlplanev1.KubeadmControlPlane{}
+			g.Expect(fClient.Get(ctx, client.ObjectKeyFromObject(kcp), cp)).To(Succeed())
+			g.Expect(
+				cp.Spec.KubeadmConfigSpec.ClusterConfiguration.Etcd.External.Endpoints,
+			).To(Equal([]string{"0.0.0.0", "1.1.1.1", "2.2.2.2"}))
+			conditions.IsTrue(kcp, string(controlplanev1.ExternalEtcdEndpointsAvailable))
+		}, 5*time.Second).Should(Succeed())
+	})
+
+	t.Run("should requeue and not update kcp when endpoints in external etcd are not set", func(t *testing.T) {
+		g := NewWithT(t)
+		cluster, kcp, managedEtcd := setup()
+		unstructured.RemoveNestedField(managedEtcd.Object, "status", "endpoints")
+		kcp.Spec.KubeadmConfigSpec.ClusterConfiguration.Etcd.External.Endpoints = []string{"0.0.0.0", "1.1.1.1", "3.3.3.3"}
+
+		fClient := newFakeClient(
+			builder.GenericEtcdCRD.DeepCopy(),
+			managedEtcd.DeepCopy(),
+			cluster.DeepCopy(),
+			kcp.DeepCopy(),
+		)
+
+		r := &KubeadmControlPlaneReconciler{
+			Client: fClient,
+			managementCluster: &fakeManagementCluster{
+				Management: &internal.Management{Client: fClient},
+				Workload:   &fakeWorkloadCluster{},
+			},
+			recorder: record.NewFakeRecorder(32),
+		}
+
+		result, err := r.Reconcile(
+			ctx,
+			ctrl.Request{client.ObjectKeyFromObject(kcp)},
+		)
+		g.Expect(result).To(Equal(ctrl.Result{RequeueAfter: 1 * time.Minute}))
+		g.Expect(err).NotTo(HaveOccurred())
+		g.Eventually(func(g Gomega) {
+			cp := &controlplanev1.KubeadmControlPlane{}
+			g.Expect(fClient.Get(ctx, client.ObjectKeyFromObject(kcp), cp)).To(Succeed())
+			g.Expect(
+				cp.Spec.KubeadmConfigSpec.ClusterConfiguration.Etcd.External.Endpoints,
+			).To(Equal([]string{"0.0.0.0", "1.1.1.1", "3.3.3.3"}))
+		}, 5*time.Second).Should(Succeed())
+	})
+
+	t.Run("should requeue and not update kcp when endpoints in external etcd are empty", func(t *testing.T) {
+		g := NewWithT(t)
+		cluster, kcp, managedEtcd := setup()
+		unstructured.SetNestedField(managedEtcd.Object, "", "status", "endpoints")
+		kcp.Spec.KubeadmConfigSpec.ClusterConfiguration.Etcd.External.Endpoints = []string{"0.0.0.0", "1.1.1.1", "3.3.3.3"}
+
+		fClient := newFakeClient(
+			builder.GenericEtcdCRD.DeepCopy(),
+			managedEtcd.DeepCopy(),
+			cluster.DeepCopy(),
+			kcp.DeepCopy(),
+		)
+
+		r := &KubeadmControlPlaneReconciler{
+			Client: fClient,
+			managementCluster: &fakeManagementCluster{
+				Management: &internal.Management{Client: fClient},
+				Workload:   &fakeWorkloadCluster{},
+			},
+			recorder: record.NewFakeRecorder(32),
+		}
+
+		result, err := r.Reconcile(
+			ctx,
+			ctrl.Request{client.ObjectKeyFromObject(kcp)},
+		)
+		g.Expect(result).To(Equal(ctrl.Result{RequeueAfter: 1 * time.Minute}))
+		g.Expect(err).NotTo(HaveOccurred())
+		g.Eventually(func(g Gomega) {
+			cp := &controlplanev1.KubeadmControlPlane{}
+			g.Expect(fClient.Get(ctx, client.ObjectKeyFromObject(kcp), cp)).To(Succeed())
+			g.Expect(
+				cp.Spec.KubeadmConfigSpec.ClusterConfiguration.Etcd.External.Endpoints,
+			).To(Equal([]string{"0.0.0.0", "1.1.1.1", "3.3.3.3"}))
+		}, 5*time.Second).Should(Succeed())
+	})
+
+	t.Run("should requeue and not update kcp when endpoints in external etcd is not ready", func(t *testing.T) {
+		g := NewWithT(t)
+		cluster, kcp, managedEtcd := setup()
+		unstructured.SetNestedField(managedEtcd.Object, "0.0.0.0", "status", "endpoints")
+		unstructured.SetNestedField(managedEtcd.Object, false, "status", "ready")
+		kcp.Spec.KubeadmConfigSpec.ClusterConfiguration.Etcd.External.Endpoints = []string{"0.0.0.0", "1.1.1.1", "3.3.3.3"}
+
+		fClient := newFakeClient(
+			builder.GenericEtcdCRD.DeepCopy(),
+			managedEtcd.DeepCopy(),
+			cluster.DeepCopy(),
+			kcp.DeepCopy(),
+		)
+
+		r := &KubeadmControlPlaneReconciler{
+			Client: fClient,
+			managementCluster: &fakeManagementCluster{
+				Management: &internal.Management{Client: fClient},
+				Workload:   &fakeWorkloadCluster{},
+			},
+			recorder: record.NewFakeRecorder(32),
+		}
+
+		result, err := r.Reconcile(
+			ctx,
+			ctrl.Request{client.ObjectKeyFromObject(kcp)},
+		)
+		g.Expect(result).To(Equal(ctrl.Result{RequeueAfter: 1 * time.Minute}))
+		g.Expect(err).NotTo(HaveOccurred())
+		g.Eventually(func(g Gomega) {
+			cp := &controlplanev1.KubeadmControlPlane{}
+			g.Expect(fClient.Get(ctx, client.ObjectKeyFromObject(kcp), cp)).To(Succeed())
+			g.Expect(
+				cp.Spec.KubeadmConfigSpec.ClusterConfiguration.Etcd.External.Endpoints,
+			).To(Equal([]string{"0.0.0.0", "1.1.1.1", "3.3.3.3"}))
+		}, 5*time.Second).Should(Succeed())
+	})
+
+	t.Run("should requeue and not update kcp when etcd is ongoing an upgrade in external etcd is going through an upgrade", func(t *testing.T) {
+		g := NewWithT(t)
+		cluster, kcp, managedEtcd := setup()
+		unstructured.SetNestedField(managedEtcd.Object, "0.0.0.0", "status", "endpoints")
+		annotations.AddAnnotations(managedEtcd, map[string]string{"etcdcluster.cluster.x-k8s.io/upgrading": "true"})
+		kcp.Spec.KubeadmConfigSpec.ClusterConfiguration.Etcd.External.Endpoints = []string{"0.0.0.0", "1.1.1.1", "3.3.3.3"}
+
+		fClient := newFakeClient(
+			builder.GenericEtcdCRD.DeepCopy(),
+			managedEtcd.DeepCopy(),
+			cluster.DeepCopy(),
+			kcp.DeepCopy(),
+		)
+
+		r := &KubeadmControlPlaneReconciler{
+			Client: fClient,
+			managementCluster: &fakeManagementCluster{
+				Management: &internal.Management{Client: fClient},
+				Workload:   &fakeWorkloadCluster{},
+			},
+			recorder: record.NewFakeRecorder(32),
+		}
+
+		result, err := r.Reconcile(
+			ctx,
+			ctrl.Request{client.ObjectKeyFromObject(kcp)},
+		)
+		g.Expect(result).To(Equal(ctrl.Result{RequeueAfter: 1 * time.Minute}))
+		g.Expect(err).NotTo(HaveOccurred())
+		g.Eventually(func(g Gomega) {
+			cp := &controlplanev1.KubeadmControlPlane{}
+			g.Expect(fClient.Get(ctx, client.ObjectKeyFromObject(kcp), cp)).To(Succeed())
+			g.Expect(
+				cp.Spec.KubeadmConfigSpec.ClusterConfiguration.Etcd.External.Endpoints,
+			).To(Equal([]string{"0.0.0.0", "1.1.1.1", "3.3.3.3"}))
+			conditions.IsFalse(cp, string(controlplanev1.ExternalEtcdEndpointsAvailable))
+		}, 5*time.Second).Should(Succeed())
+	})
+}
+
 func TestObjectsPendingDelete(t *testing.T) {
 	c := &clusterv1.Cluster{
 		ObjectMeta: metav1.ObjectMeta{
diff --git a/controlplane/kubeadm/internal/webhooks/kubeadm_control_plane.go b/controlplane/kubeadm/internal/webhooks/kubeadm_control_plane.go
index a132bd9..6fb18f7 100644
--- a/controlplane/kubeadm/internal/webhooks/kubeadm_control_plane.go
+++ b/controlplane/kubeadm/internal/webhooks/kubeadm_control_plane.go
@@ -140,6 +140,8 @@ func (webhook *KubeadmControlPlane) ValidateUpdate(_ context.Context, oldObj, ne
 		// metadata
 		{"metadata", "*"},
 		// spec.kubeadmConfigSpec.clusterConfiguration
+		{spec, kubeadmConfigSpec, clusterConfiguration, "bottlerocketBootstrap", "*"},
+		{spec, kubeadmConfigSpec, clusterConfiguration, "pause", "*"},
 		{spec, kubeadmConfigSpec, clusterConfiguration, "etcd"},
 		{spec, kubeadmConfigSpec, clusterConfiguration, "etcd", "*"},
 		{spec, kubeadmConfigSpec, clusterConfiguration, "etcd", "local"},
@@ -169,6 +171,8 @@ func (webhook *KubeadmControlPlane) ValidateUpdate(_ context.Context, oldObj, ne
 		{spec, kubeadmConfigSpec, initConfiguration, timeouts},
 		{spec, kubeadmConfigSpec, initConfiguration, timeouts, "*"},
 		// spec.kubeadmConfigSpec.joinConfiguration
+		{spec, kubeadmConfigSpec, joinConfiguration, "bottlerocketBootstrap", "*"},
+		{spec, kubeadmConfigSpec, joinConfiguration, "pause", "*"},
 		{spec, kubeadmConfigSpec, joinConfiguration, nodeRegistration},
 		{spec, kubeadmConfigSpec, joinConfiguration, nodeRegistration, "*"},
 		{spec, kubeadmConfigSpec, joinConfiguration, patches, directory},
diff --git a/controlplane/kubeadm/internal/webhooks/kubeadm_control_plane_test.go b/controlplane/kubeadm/internal/webhooks/kubeadm_control_plane_test.go
index 1d73869..19d4876 100644
--- a/controlplane/kubeadm/internal/webhooks/kubeadm_control_plane_test.go
+++ b/controlplane/kubeadm/internal/webhooks/kubeadm_control_plane_test.go
@@ -755,6 +755,18 @@ func TestKubeadmControlPlaneValidateUpdate(t *testing.T) {
 		CACertificateValidityPeriodDays: 730,
 	}
 
+	validUpdateClusterConfPauseImage := before.DeepCopy()
+	validUpdateClusterConfPauseImage.Spec.KubeadmConfigSpec.ClusterConfiguration.Pause = bootstrapv1.Pause{ImageRepository: "registry.k8s.io/pause", ImageTag: "v1.1.0+new"}
+
+	validUpdateClusterConfBRBootstrapImage := before.DeepCopy()
+	validUpdateClusterConfBRBootstrapImage.Spec.KubeadmConfigSpec.ClusterConfiguration.BottlerocketBootstrap = bootstrapv1.BottlerocketBootstrap{ImageRepository: "registry.k8s.io/bottlerocketbootstrap", ImageTag: "v1.1.0+new"}
+
+	validUpdateJoinConfPauseImage := before.DeepCopy()
+	validUpdateJoinConfPauseImage.Spec.KubeadmConfigSpec.JoinConfiguration.Pause = bootstrapv1.Pause{ImageRepository: "registry.k8s.io/pause", ImageTag: "v1.1.0+new"}
+
+	validUpdateJoinConfBRBootstrapImage := before.DeepCopy()
+	validUpdateJoinConfBRBootstrapImage.Spec.KubeadmConfigSpec.JoinConfiguration.BottlerocketBootstrap = bootstrapv1.BottlerocketBootstrap{ImageRepository: "registry.k8s.io/bottlerocketbootstrap", ImageTag: "v1.1.0+new"}
+
 	tests := []struct {
 		name                  string
 		enableIgnitionFeature bool
@@ -1118,6 +1130,30 @@ func TestKubeadmControlPlaneValidateUpdate(t *testing.T) {
 			before:    before,
 			kcp:       invalidUpdateCACertificateValidityPeriodDays,
 		},
+		{
+			name:      "should allow changes to cluster configuration pause image",
+			expectErr: false,
+			before:    before,
+			kcp:       validUpdateClusterConfPauseImage,
+		},
+		{
+			name:      "should allow changes to cluster configuration bottlerocket bootstrap image",
+			expectErr: false,
+			before:    before,
+			kcp:       validUpdateClusterConfBRBootstrapImage,
+		},
+		{
+			name:      "should allow changes to join configuration pause image",
+			expectErr: false,
+			before:    before,
+			kcp:       validUpdateJoinConfPauseImage,
+		},
+		{
+			name:      "should allow changes to join configuration bottlerocket bootstrap image",
+			expectErr: false,
+			before:    before,
+			kcp:       validUpdateJoinConfBRBootstrapImage,
+		},
 	}
 
 	for _, tt := range tests {
diff --git a/controlplane/kubeadm/internal/workload_cluster.go b/controlplane/kubeadm/internal/workload_cluster.go
index 80d497b..2533b77 100644
--- a/controlplane/kubeadm/internal/workload_cluster.go
+++ b/controlplane/kubeadm/internal/workload_cluster.go
@@ -90,6 +90,7 @@ type WorkloadCluster interface {
 	UpdateImageRepositoryInKubeadmConfigMap(imageRepository string) func(*bootstrapv1.ClusterConfiguration)
 	UpdateFeatureGatesInKubeadmConfigMap(kubeadmConfigSpec bootstrapv1.KubeadmConfigSpec, kubernetesVersion semver.Version) func(*bootstrapv1.ClusterConfiguration)
 	UpdateEtcdLocalInKubeadmConfigMap(localEtcd bootstrapv1.LocalEtcd) func(*bootstrapv1.ClusterConfiguration)
+	UpdateExternalEtcdEndpointsInKubeadmConfigMap(ctx context.Context, endpoints []string, version semver.Version) error
 	UpdateEtcdExternalInKubeadmConfigMap(externalEtcd bootstrapv1.ExternalEtcd) func(*bootstrapv1.ClusterConfiguration)
 	UpdateAPIServerInKubeadmConfigMap(apiServer bootstrapv1.APIServer) func(*bootstrapv1.ClusterConfiguration)
 	UpdateControllerManagerInKubeadmConfigMap(controllerManager bootstrapv1.ControllerManager) func(*bootstrapv1.ClusterConfiguration)
diff --git a/controlplane/kubeadm/internal/workload_cluster_etcd.go b/controlplane/kubeadm/internal/workload_cluster_etcd.go
index 66adc4e..e70df16 100644
--- a/controlplane/kubeadm/internal/workload_cluster_etcd.go
+++ b/controlplane/kubeadm/internal/workload_cluster_etcd.go
@@ -19,6 +19,7 @@ package internal
 import (
 	"context"
 
+	"github.com/blang/semver/v4"
 	"github.com/pkg/errors"
 	kerrors "k8s.io/apimachinery/pkg/util/errors"
 
@@ -83,6 +84,14 @@ func (w *Workload) UpdateEtcdExternalInKubeadmConfigMap(etcdExternal bootstrapv1
 	}
 }
 
+func (w *Workload) UpdateExternalEtcdEndpointsInKubeadmConfigMap(ctx context.Context, endpoints []string, version semver.Version) error {
+	return w.UpdateClusterConfiguration(ctx, version, func(c *bootstrapv1.ClusterConfiguration) {
+		if c.Etcd.External.IsDefined() {
+			c.Etcd.External.Endpoints = endpoints
+		}
+	})
+}
+
 // RemoveEtcdMemberForMachine removes the etcd member from the target cluster's etcd cluster.
 // Removing the last remaining member of the cluster is not supported.
 func (w *Workload) RemoveEtcdMemberForMachine(ctx context.Context, machine *clusterv1.Machine) error {
diff --git a/internal/api/bootstrap/kubeadm/v1alpha3/zz_generated.conversion.go b/internal/api/bootstrap/kubeadm/v1alpha3/zz_generated.conversion.go
index a075d2c..0effa71 100644
--- a/internal/api/bootstrap/kubeadm/v1alpha3/zz_generated.conversion.go
+++ b/internal/api/bootstrap/kubeadm/v1alpha3/zz_generated.conversion.go
@@ -543,6 +543,7 @@ func autoConvert_v1beta2_ClusterConfiguration_To_v1alpha3_ClusterConfiguration(i
 	// WARNING: in.Pause requires manual conversion: does not exist in peer-type
 	// WARNING: in.BottlerocketBootstrap requires manual conversion: does not exist in peer-type
 	// WARNING: in.Proxy requires manual conversion: does not exist in peer-type
+	// WARNING: in.RegistryMirror requires manual conversion: does not exist in peer-type
 	if err := Convert_v1beta2_Etcd_To_v1alpha3_Etcd(&in.Etcd, &out.Etcd, s); err != nil {
 		return err
 	}
@@ -890,6 +891,7 @@ func autoConvert_v1beta2_JoinConfiguration_To_v1alpha3_JoinConfiguration(in *v1b
 	// WARNING: in.Pause requires manual conversion: does not exist in peer-type
 	// WARNING: in.BottlerocketBootstrap requires manual conversion: does not exist in peer-type
 	// WARNING: in.Proxy requires manual conversion: does not exist in peer-type
+	// WARNING: in.RegistryMirror requires manual conversion: does not exist in peer-type
 	if err := Convert_v1beta2_NodeRegistrationOptions_To_v1alpha3_NodeRegistrationOptions(&in.NodeRegistration, &out.NodeRegistration, s); err != nil {
 		return err
 	}
diff --git a/internal/api/bootstrap/kubeadm/v1alpha4/kubeadm_types.go b/internal/api/bootstrap/kubeadm/v1alpha4/kubeadm_types.go
index a147649..68c3729 100644
--- a/internal/api/bootstrap/kubeadm/v1alpha4/kubeadm_types.go
+++ b/internal/api/bootstrap/kubeadm/v1alpha4/kubeadm_types.go
@@ -76,6 +76,11 @@ type ClusterConfiguration struct {
 	// +optional
 	Proxy ProxyConfiguration `json:"proxy,omitempty"`
 
+	// RegistryMirror holds the image registry mirror information
+	// This is only for bottlerocket
+	// +optional
+	RegistryMirror RegistryMirrorConfiguration `json:"registryMirror,omitempty"`
+
 	// etcd holds configuration for etcd.
 	// NB: This value defaults to a Local (stacked) etcd
 	// +optional
@@ -166,6 +171,15 @@ type ProxyConfiguration struct {
 	NoProxy []string `json:"noProxy,omitempty"`
 }
 
+// RegistryMirrorConfiguration holds the settings for image registry mirror
+type RegistryMirrorConfiguration struct {
+	// Endpoint defines the registry mirror endpoint to use for pulling images
+	Endpoint string `json:"endpoint,omitempty"`
+
+	// CACert defines the CA cert for the registry mirror
+	CACert string `json:"caCert,omitempty"`
+}
+
 // ControlPlaneComponent holds settings common to control plane component of the cluster.
 type ControlPlaneComponent struct {
 	// extraArgs is an extra set of flags to pass to the control plane component.
@@ -375,6 +389,11 @@ type JoinConfiguration struct {
 	// +optional
 	Proxy ProxyConfiguration `json:"proxy,omitempty"`
 
+	// RegistryMirror holds the image registry mirror information
+	// This is only for bottlerocket
+	// +optional
+	RegistryMirror RegistryMirrorConfiguration `json:"registryMirror,omitempty"`
+
 	// nodeRegistration holds fields that relate to registering the new control-plane node to the cluster.
 	// When used in the context of control plane nodes, NodeRegistration should remain consistent
 	// across both InitConfiguration and JoinConfiguration
diff --git a/internal/api/bootstrap/kubeadm/v1alpha4/zz_generated.conversion.go b/internal/api/bootstrap/kubeadm/v1alpha4/zz_generated.conversion.go
index c64093b..0294483 100644
--- a/internal/api/bootstrap/kubeadm/v1alpha4/zz_generated.conversion.go
+++ b/internal/api/bootstrap/kubeadm/v1alpha4/zz_generated.conversion.go
@@ -219,6 +219,16 @@ func RegisterConversions(s *runtime.Scheme) error {
 	}); err != nil {
 		return err
 	}
+	if err := s.AddGeneratedConversionFunc((*RegistryMirrorConfiguration)(nil), (*v1beta2.RegistryMirrorConfiguration)(nil), func(a, b interface{}, scope conversion.Scope) error {
+		return Convert_v1alpha4_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(a.(*RegistryMirrorConfiguration), b.(*v1beta2.RegistryMirrorConfiguration), scope)
+	}); err != nil {
+		return err
+	}
+	if err := s.AddGeneratedConversionFunc((*v1beta2.RegistryMirrorConfiguration)(nil), (*RegistryMirrorConfiguration)(nil), func(a, b interface{}, scope conversion.Scope) error {
+		return Convert_v1beta2_RegistryMirrorConfiguration_To_v1alpha4_RegistryMirrorConfiguration(a.(*v1beta2.RegistryMirrorConfiguration), b.(*RegistryMirrorConfiguration), scope)
+	}); err != nil {
+		return err
+	}
 	if err := s.AddGeneratedConversionFunc((*SecretFileSource)(nil), (*v1beta2.SecretFileSource)(nil), func(a, b interface{}, scope conversion.Scope) error {
 		return Convert_v1alpha4_SecretFileSource_To_v1beta2_SecretFileSource(a.(*SecretFileSource), b.(*v1beta2.SecretFileSource), scope)
 	}); err != nil {
@@ -563,6 +573,9 @@ func autoConvert_v1alpha4_ClusterConfiguration_To_v1beta2_ClusterConfiguration(i
 	if err := Convert_v1alpha4_ProxyConfiguration_To_v1beta2_ProxyConfiguration(&in.Proxy, &out.Proxy, s); err != nil {
 		return err
 	}
+	if err := Convert_v1alpha4_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(&in.RegistryMirror, &out.RegistryMirror, s); err != nil {
+		return err
+	}
 	if err := Convert_v1alpha4_Etcd_To_v1beta2_Etcd(&in.Etcd, &out.Etcd, s); err != nil {
 		return err
 	}
@@ -598,6 +611,9 @@ func autoConvert_v1beta2_ClusterConfiguration_To_v1alpha4_ClusterConfiguration(i
 	if err := Convert_v1beta2_ProxyConfiguration_To_v1alpha4_ProxyConfiguration(&in.Proxy, &out.Proxy, s); err != nil {
 		return err
 	}
+	if err := Convert_v1beta2_RegistryMirrorConfiguration_To_v1alpha4_RegistryMirrorConfiguration(&in.RegistryMirror, &out.RegistryMirror, s); err != nil {
+		return err
+	}
 	if err := Convert_v1beta2_Etcd_To_v1alpha4_Etcd(&in.Etcd, &out.Etcd, s); err != nil {
 		return err
 	}
@@ -938,6 +954,9 @@ func autoConvert_v1alpha4_JoinConfiguration_To_v1beta2_JoinConfiguration(in *Joi
 	if err := Convert_v1alpha4_ProxyConfiguration_To_v1beta2_ProxyConfiguration(&in.Proxy, &out.Proxy, s); err != nil {
 		return err
 	}
+	if err := Convert_v1alpha4_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(&in.RegistryMirror, &out.RegistryMirror, s); err != nil {
+		return err
+	}
 	if err := Convert_v1alpha4_NodeRegistrationOptions_To_v1beta2_NodeRegistrationOptions(&in.NodeRegistration, &out.NodeRegistration, s); err != nil {
 		return err
 	}
@@ -959,6 +978,9 @@ func autoConvert_v1beta2_JoinConfiguration_To_v1alpha4_JoinConfiguration(in *v1b
 	if err := Convert_v1beta2_ProxyConfiguration_To_v1alpha4_ProxyConfiguration(&in.Proxy, &out.Proxy, s); err != nil {
 		return err
 	}
+	if err := Convert_v1beta2_RegistryMirrorConfiguration_To_v1alpha4_RegistryMirrorConfiguration(&in.RegistryMirror, &out.RegistryMirror, s); err != nil {
+		return err
+	}
 	if err := Convert_v1beta2_NodeRegistrationOptions_To_v1alpha4_NodeRegistrationOptions(&in.NodeRegistration, &out.NodeRegistration, s); err != nil {
 		return err
 	}
@@ -1430,6 +1452,28 @@ func Convert_v1beta2_ProxyConfiguration_To_v1alpha4_ProxyConfiguration(in *v1bet
 	return autoConvert_v1beta2_ProxyConfiguration_To_v1alpha4_ProxyConfiguration(in, out, s)
 }
 
+func autoConvert_v1alpha4_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(in *RegistryMirrorConfiguration, out *v1beta2.RegistryMirrorConfiguration, s conversion.Scope) error {
+	out.Endpoint = in.Endpoint
+	out.CACert = in.CACert
+	return nil
+}
+
+// Convert_v1alpha4_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration is an autogenerated conversion function.
+func Convert_v1alpha4_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(in *RegistryMirrorConfiguration, out *v1beta2.RegistryMirrorConfiguration, s conversion.Scope) error {
+	return autoConvert_v1alpha4_RegistryMirrorConfiguration_To_v1beta2_RegistryMirrorConfiguration(in, out, s)
+}
+
+func autoConvert_v1beta2_RegistryMirrorConfiguration_To_v1alpha4_RegistryMirrorConfiguration(in *v1beta2.RegistryMirrorConfiguration, out *RegistryMirrorConfiguration, s conversion.Scope) error {
+	out.Endpoint = in.Endpoint
+	out.CACert = in.CACert
+	return nil
+}
+
+// Convert_v1beta2_RegistryMirrorConfiguration_To_v1alpha4_RegistryMirrorConfiguration is an autogenerated conversion function.
+func Convert_v1beta2_RegistryMirrorConfiguration_To_v1alpha4_RegistryMirrorConfiguration(in *v1beta2.RegistryMirrorConfiguration, out *RegistryMirrorConfiguration, s conversion.Scope) error {
+	return autoConvert_v1beta2_RegistryMirrorConfiguration_To_v1alpha4_RegistryMirrorConfiguration(in, out, s)
+}
+
 func autoConvert_v1alpha4_SecretFileSource_To_v1beta2_SecretFileSource(in *SecretFileSource, out *v1beta2.SecretFileSource, s conversion.Scope) error {
 	out.Name = in.Name
 	out.Key = in.Key
diff --git a/internal/api/bootstrap/kubeadm/v1alpha4/zz_generated.deepcopy.go b/internal/api/bootstrap/kubeadm/v1alpha4/zz_generated.deepcopy.go
index b6a144d..ed9b9e0 100644
--- a/internal/api/bootstrap/kubeadm/v1alpha4/zz_generated.deepcopy.go
+++ b/internal/api/bootstrap/kubeadm/v1alpha4/zz_generated.deepcopy.go
@@ -165,6 +165,7 @@ func (in *ClusterConfiguration) DeepCopyInto(out *ClusterConfiguration) {
 	out.Pause = in.Pause
 	out.BottlerocketBootstrap = in.BottlerocketBootstrap
 	in.Proxy.DeepCopyInto(&out.Proxy)
+	out.RegistryMirror = in.RegistryMirror
 	in.Etcd.DeepCopyInto(&out.Etcd)
 	out.Networking = in.Networking
 	in.APIServer.DeepCopyInto(&out.APIServer)
@@ -501,6 +502,7 @@ func (in *JoinConfiguration) DeepCopyInto(out *JoinConfiguration) {
 	out.Pause = in.Pause
 	out.BottlerocketBootstrap = in.BottlerocketBootstrap
 	in.Proxy.DeepCopyInto(&out.Proxy)
+	out.RegistryMirror = in.RegistryMirror
 	in.NodeRegistration.DeepCopyInto(&out.NodeRegistration)
 	in.Discovery.DeepCopyInto(&out.Discovery)
 	if in.ControlPlane != nil {
@@ -987,6 +989,21 @@ func (in *ProxyConfiguration) DeepCopy() *ProxyConfiguration {
 	return out
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *RegistryMirrorConfiguration) DeepCopyInto(out *RegistryMirrorConfiguration) {
+	*out = *in
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RegistryMirrorConfiguration.
+func (in *RegistryMirrorConfiguration) DeepCopy() *RegistryMirrorConfiguration {
+	if in == nil {
+		return nil
+	}
+	out := new(RegistryMirrorConfiguration)
+	in.DeepCopyInto(out)
+	return out
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *SecretFileSource) DeepCopyInto(out *SecretFileSource) {
 	*out = *in
diff --git a/internal/api/core/v1alpha3/cluster_types.go b/internal/api/core/v1alpha3/cluster_types.go
index d9a2abd..7a4f525 100644
--- a/internal/api/core/v1alpha3/cluster_types.go
+++ b/internal/api/core/v1alpha3/cluster_types.go
@@ -55,6 +55,11 @@ type ClusterSpec struct {
 	// +optional
 	ControlPlaneRef *corev1.ObjectReference `json:"controlPlaneRef,omitempty"`
 
+	// ManagedExternalEtcdRef is an optional reference to an etcd provider resource that holds details
+	// for provisioning an external etcd cluster
+	// +optional
+	ManagedExternalEtcdRef *corev1.ObjectReference `json:"managedExternalEtcdRef,omitempty"`
+
 	// infrastructureRef is a reference to a provider-specific resource that holds the details
 	// for provisioning infrastructure for a cluster in said provider.
 	// +optional
@@ -147,6 +152,15 @@ type ClusterStatus struct {
 	// observedGeneration is the latest generation observed by the controller.
 	// +optional
 	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
+
+	// ManagedExternalEtcdInitialized indicates that first etcd member's IP address is set by machine controller,
+	// so remaining etcd members can lookup the address to join the cluster
+	// +optional
+	ManagedExternalEtcdInitialized bool `json:"managedExternalEtcdInitialized"`
+
+	// ManagedExternalEtcdReady indicates external etcd cluster is fully provisioned
+	// +optional
+	ManagedExternalEtcdReady bool `json:"managedExternalEtcdReady"`
 }
 
 // ANCHOR_END: ClusterStatus
diff --git a/internal/api/core/v1alpha3/common_types.go b/internal/api/core/v1alpha3/common_types.go
index a4f921c..689da58 100644
--- a/internal/api/core/v1alpha3/common_types.go
+++ b/internal/api/core/v1alpha3/common_types.go
@@ -70,6 +70,13 @@ const (
 
 	// ClusterSecretType defines the type of secret created by core components.
 	ClusterSecretType corev1.SecretType = "cluster.x-k8s.io/secret" //nolint:gosec
+
+	// ControlPlaneUpgradeCompletedAnnotation is set by the controlplane on the external etcd object after controlplane upgrade is completed.
+	ControlPlaneUpgradeCompletedAnnotation = "controlplane.cluster.x-k8s.io/upgrade-complete"
+
+	// SkipControlPlanePauseManagedEtcdAnnotation indicates that the cluster controller should not pause or unpause
+	// the control plane after the managed etcd cluster becomes not-ready/ready.
+	SkipControlPlanePauseManagedEtcdAnnotation = "cluster.x-k8s.io/skip-pause-cp-managed-etcd"
 )
 
 // MachineAddressType describes a valid MachineAddress type.
diff --git a/internal/api/core/v1alpha3/condition_consts.go b/internal/api/core/v1alpha3/condition_consts.go
index 3c0b619..8685009 100644
--- a/internal/api/core/v1alpha3/condition_consts.go
+++ b/internal/api/core/v1alpha3/condition_consts.go
@@ -184,3 +184,29 @@ const (
 	// from making any further remediations.
 	TooManyUnhealthyReason = "TooManyUnhealthy"
 )
+
+// Conditions used by the Etcd provider objects
+const (
+	// ManagedExternalEtcdClusterInitializedCondition is set once the first member of an etcd cluster is provisioned and running
+	ManagedExternalEtcdClusterInitializedCondition ConditionType = "ManagedEtcdInitialized"
+
+	// ManagedExternalEtcdClusterReadyCondition indicates if the etcd cluster is ready and all members have passed healthchecks.
+	ManagedExternalEtcdClusterReadyCondition ConditionType = "ManagedEtcdReady"
+
+	// WaitingForEtcdClusterInitializedReason (Severity=Info) documents a cluster waiting for the etcd cluster
+	// to report successful etcd cluster initialization.
+	WaitingForEtcdClusterInitializedReason = "WaitingForEtcdClusterProviderInitialized"
+
+	// EtcdHealthCheckFailedReason (Severity=Error) documents that healthcheck on an etcd member failed
+	EtcdHealthCheckFailedReason = "EtcdMemberHealthCheckFailed"
+)
+
+const (
+	// ExternalEtcdEndpointsAvailable documents that the external etcd cluster's endpoints are available, and if KCP spec has changed
+	// then a KCP rollout can progress.
+	ExternalEtcdEndpointsAvailable ConditionType = "ExternalEtcdEndpointsAvailable"
+
+	// ExternalEtcdUndergoingUpgrade (Severity=Info) documents the external etcd cluster being used by current KCP object is
+	// undergoing an upgrade and that the etcd endpoints will change once the upgrade completes
+	ExternalEtcdUndergoingUpgrade = "ExternalEtcdUndergoingUpgrade"
+)
diff --git a/internal/api/core/v1alpha3/conversion.go b/internal/api/core/v1alpha3/conversion.go
index 8cda6f6..00235d4 100644
--- a/internal/api/core/v1alpha3/conversion.go
+++ b/internal/api/core/v1alpha3/conversion.go
@@ -92,6 +92,14 @@ func (src *Cluster) ConvertTo(dstRaw conversion.Hub) error {
 		v1beta1conditions.MarkTrue(dst, clusterv1.ControlPlaneInitializedV1Beta1Condition)
 	}
 
+	if src.Status.ManagedExternalEtcdInitialized {
+		v1beta1conditions.MarkTrue(dst, clusterv1.ManagedExternalEtcdClusterInitializedCondition)
+	}
+
+	if src.Status.ManagedExternalEtcdReady {
+		v1beta1conditions.MarkTrue(dst, clusterv1.ManagedExternalEtcdClusterReadyCondition)
+	}
+
 	// Manually restore data.
 	restored := &clusterv1.Cluster{}
 	ok, err := utilconversion.UnmarshalData(src, restored)
@@ -134,6 +142,7 @@ func (src *Cluster) ConvertTo(dstRaw conversion.Hub) error {
 		dst.Status.Conditions = restored.Status.Conditions
 		dst.Status.ControlPlane = restored.Status.ControlPlane
 		dst.Status.Workers = restored.Status.Workers
+		dst.Spec.ManagedExternalEtcdRef = restored.Spec.ManagedExternalEtcdRef
 	}
 
 	return nil
diff --git a/internal/api/core/v1alpha3/machine_types.go b/internal/api/core/v1alpha3/machine_types.go
index 4cf7877..67f09f6 100644
--- a/internal/api/core/v1alpha3/machine_types.go
+++ b/internal/api/core/v1alpha3/machine_types.go
@@ -30,6 +30,9 @@ const (
 	// MachineControlPlaneLabelName is the label set on machines or related objects that are part of a control plane.
 	MachineControlPlaneLabelName = "cluster.x-k8s.io/control-plane"
 
+	//MachineEtcdClusterLabelName is the label set on machines or related objects that are part of an etcd cluster
+	MachineEtcdClusterLabelName = "cluster.x-k8s.io/etcd-cluster"
+
 	// ExcludeNodeDrainingAnnotation annotation explicitly skips node draining if set.
 	ExcludeNodeDrainingAnnotation = "machine.cluster.x-k8s.io/exclude-node-draining"
 
diff --git a/internal/api/core/v1alpha3/zz_generated.conversion.go b/internal/api/core/v1alpha3/zz_generated.conversion.go
index 0c9c762..6a47e2c 100644
--- a/internal/api/core/v1alpha3/zz_generated.conversion.go
+++ b/internal/api/core/v1alpha3/zz_generated.conversion.go
@@ -520,6 +520,7 @@ func autoConvert_v1alpha3_ClusterSpec_To_v1beta2_ClusterSpec(in *ClusterSpec, ou
 		return err
 	}
 	// WARNING: in.ControlPlaneRef requires manual conversion: inconvertible types (*k8s.io/api/core/v1.ObjectReference vs sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference)
+	// WARNING: in.ManagedExternalEtcdRef requires manual conversion: inconvertible types (*k8s.io/api/core/v1.ObjectReference vs sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference)
 	// WARNING: in.InfrastructureRef requires manual conversion: inconvertible types (*k8s.io/api/core/v1.ObjectReference vs sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference)
 	return nil
 }
@@ -533,6 +534,7 @@ func autoConvert_v1beta2_ClusterSpec_To_v1alpha3_ClusterSpec(in *v1beta2.Cluster
 		return err
 	}
 	// WARNING: in.ControlPlaneRef requires manual conversion: inconvertible types (sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference vs *k8s.io/api/core/v1.ObjectReference)
+	// WARNING: in.ManagedExternalEtcdRef requires manual conversion: inconvertible types (sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference vs *k8s.io/api/core/v1.ObjectReference)
 	// WARNING: in.InfrastructureRef requires manual conversion: inconvertible types (sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference vs *k8s.io/api/core/v1.ObjectReference)
 	// WARNING: in.Topology requires manual conversion: does not exist in peer-type
 	// WARNING: in.AvailabilityGates requires manual conversion: does not exist in peer-type
@@ -559,6 +561,8 @@ func autoConvert_v1alpha3_ClusterStatus_To_v1beta2_ClusterStatus(in *ClusterStat
 		out.Conditions = nil
 	}
 	out.ObservedGeneration = in.ObservedGeneration
+	out.ManagedExternalEtcdInitialized = in.ManagedExternalEtcdInitialized
+	out.ManagedExternalEtcdReady = in.ManagedExternalEtcdReady
 	return nil
 }
 
@@ -580,6 +584,8 @@ func autoConvert_v1beta2_ClusterStatus_To_v1alpha3_ClusterStatus(in *v1beta2.Clu
 	// WARNING: in.FailureDomains requires manual conversion: inconvertible types ([]sigs.k8s.io/cluster-api/api/core/v1beta2.FailureDomain vs sigs.k8s.io/cluster-api/internal/api/core/v1alpha3.FailureDomains)
 	out.Phase = in.Phase
 	out.ObservedGeneration = in.ObservedGeneration
+	out.ManagedExternalEtcdInitialized = in.ManagedExternalEtcdInitialized
+	out.ManagedExternalEtcdReady = in.ManagedExternalEtcdReady
 	// WARNING: in.Deprecated requires manual conversion: does not exist in peer-type
 	return nil
 }
diff --git a/internal/api/core/v1alpha3/zz_generated.deepcopy.go b/internal/api/core/v1alpha3/zz_generated.deepcopy.go
index ac0ffaa..2eec9af 100644
--- a/internal/api/core/v1alpha3/zz_generated.deepcopy.go
+++ b/internal/api/core/v1alpha3/zz_generated.deepcopy.go
@@ -176,6 +176,11 @@ func (in *ClusterSpec) DeepCopyInto(out *ClusterSpec) {
 		*out = new(v1.ObjectReference)
 		**out = **in
 	}
+	if in.ManagedExternalEtcdRef != nil {
+		in, out := &in.ManagedExternalEtcdRef, &out.ManagedExternalEtcdRef
+		*out = new(v1.ObjectReference)
+		**out = **in
+	}
 	if in.InfrastructureRef != nil {
 		in, out := &in.InfrastructureRef, &out.InfrastructureRef
 		*out = new(v1.ObjectReference)
diff --git a/internal/api/core/v1alpha4/cluster_types.go b/internal/api/core/v1alpha4/cluster_types.go
index 607205a..6553756 100644
--- a/internal/api/core/v1alpha4/cluster_types.go
+++ b/internal/api/core/v1alpha4/cluster_types.go
@@ -56,6 +56,11 @@ type ClusterSpec struct {
 	// +optional
 	ControlPlaneRef *corev1.ObjectReference `json:"controlPlaneRef,omitempty"`
 
+	// ManagedExternalEtcdRef is an optional reference to an etcd provider resource that holds details
+	// for provisioning an external etcd cluster
+	// +optional
+	ManagedExternalEtcdRef *corev1.ObjectReference `json:"managedExternalEtcdRef,omitempty"`
+
 	// infrastructureRef is a reference to a provider-specific resource that holds the details
 	// for provisioning infrastructure for a cluster in said provider.
 	// +optional
@@ -223,6 +228,15 @@ type ClusterStatus struct {
 	// observedGeneration is the latest generation observed by the controller.
 	// +optional
 	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
+
+	// ManagedExternalEtcdInitialized indicates that first etcd member's IP address is set by machine controller,
+	// so remaining etcd members can lookup the address to join the cluster
+	// +optional
+	ManagedExternalEtcdInitialized bool `json:"managedExternalEtcdInitialized"`
+
+	// ManagedExternalEtcdReady indicates external etcd cluster is fully provisioned
+	// +optional
+	ManagedExternalEtcdReady bool `json:"managedExternalEtcdReady"`
 }
 
 // ANCHOR_END: ClusterStatus
diff --git a/internal/api/core/v1alpha4/common_types.go b/internal/api/core/v1alpha4/common_types.go
index e623c11..86b5fc7 100644
--- a/internal/api/core/v1alpha4/common_types.go
+++ b/internal/api/core/v1alpha4/common_types.go
@@ -104,6 +104,13 @@ const (
 	// An external controller must fulfill the contract of the InfraCluster resource.
 	// External infrastructure providers should ensure that the annotation, once set, cannot be removed.
 	ManagedByAnnotation = "cluster.x-k8s.io/managed-by"
+
+	// ControlPlaneUpgradeCompletedAnnotation is set by the controlplane on the external etcd object after controlplane upgrade is completed.
+	ControlPlaneUpgradeCompletedAnnotation = "controlplane.cluster.x-k8s.io/upgrade-complete"
+
+	// SkipControlPlanePauseManagedEtcdAnnotation indicates that the cluster controller should not pause or unpause
+	// the control plane after the managed etcd cluster becomes not-ready/ready.
+	SkipControlPlanePauseManagedEtcdAnnotation = "cluster.x-k8s.io/skip-pause-cp-managed-etcd"
 )
 
 const (
diff --git a/internal/api/core/v1alpha4/condition_consts.go b/internal/api/core/v1alpha4/condition_consts.go
index d3c84b6..021cd9e 100644
--- a/internal/api/core/v1alpha4/condition_consts.go
+++ b/internal/api/core/v1alpha4/condition_consts.go
@@ -251,3 +251,29 @@ const (
 	// ScalingDownReason (Severity=Info) documents a MachineSet is decreasing the number of replicas.
 	ScalingDownReason = "ScalingDown"
 )
+
+// Conditions used by the Etcd provider objects
+const (
+	// ManagedExternalEtcdClusterInitializedCondition is set once the first member of an etcd cluster is provisioned and running
+	ManagedExternalEtcdClusterInitializedCondition ConditionType = "ManagedEtcdInitialized"
+
+	// ManagedExternalEtcdClusterReadyCondition indicates if the etcd cluster is ready and all members have passed healthchecks.
+	ManagedExternalEtcdClusterReadyCondition ConditionType = "ManagedEtcdReady"
+
+	// WaitingForEtcdClusterInitializedReason (Severity=Info) documents a cluster waiting for the etcd cluster
+	// to report successful etcd cluster initialization.
+	WaitingForEtcdClusterInitializedReason = "WaitingForEtcdClusterProviderInitialized"
+
+	// EtcdHealthCheckFailedReason (Severity=Error) documents that healthcheck on an etcd member failed
+	EtcdHealthCheckFailedReason = "EtcdMemberHealthCheckFailed"
+)
+
+const (
+	// ExternalEtcdEndpointsAvailable documents that the external etcd cluster's endpoints are available, and if KCP spec has changed
+	// then a KCP rollout can progress.
+	ExternalEtcdEndpointsAvailable ConditionType = "ExternalEtcdEndpointsAvailable"
+
+	// ExternalEtcdUndergoingUpgrade (Severity=Info) documents the external etcd cluster being used by current KCP object is
+	// undergoing an upgrade and that the etcd endpoints will change once the upgrade completes
+	ExternalEtcdUndergoingUpgrade = "ExternalEtcdUndergoingUpgrade"
+)
diff --git a/internal/api/core/v1alpha4/machine_types.go b/internal/api/core/v1alpha4/machine_types.go
index 9928bfc..209de02 100644
--- a/internal/api/core/v1alpha4/machine_types.go
+++ b/internal/api/core/v1alpha4/machine_types.go
@@ -30,6 +30,9 @@ const (
 	// MachineControlPlaneLabelName is the label set on machines or related objects that are part of a control plane.
 	MachineControlPlaneLabelName = "cluster.x-k8s.io/control-plane"
 
+	//MachineEtcdClusterLabelName is the label set on machines or related objects that are part of an etcd cluster
+	MachineEtcdClusterLabelName = "cluster.x-k8s.io/etcd-cluster"
+
 	// ExcludeNodeDrainingAnnotation annotation explicitly skips node draining if set.
 	ExcludeNodeDrainingAnnotation = "machine.cluster.x-k8s.io/exclude-node-draining"
 
diff --git a/internal/api/core/v1alpha4/zz_generated.conversion.go b/internal/api/core/v1alpha4/zz_generated.conversion.go
index 308061f..d34a5f8 100644
--- a/internal/api/core/v1alpha4/zz_generated.conversion.go
+++ b/internal/api/core/v1alpha4/zz_generated.conversion.go
@@ -757,6 +757,7 @@ func autoConvert_v1alpha4_ClusterSpec_To_v1beta2_ClusterSpec(in *ClusterSpec, ou
 		return err
 	}
 	// WARNING: in.ControlPlaneRef requires manual conversion: inconvertible types (*k8s.io/api/core/v1.ObjectReference vs sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference)
+	// WARNING: in.ManagedExternalEtcdRef requires manual conversion: inconvertible types (*k8s.io/api/core/v1.ObjectReference vs sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference)
 	// WARNING: in.InfrastructureRef requires manual conversion: inconvertible types (*k8s.io/api/core/v1.ObjectReference vs sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference)
 	// WARNING: in.Topology requires manual conversion: inconvertible types (*sigs.k8s.io/cluster-api/internal/api/core/v1alpha4.Topology vs sigs.k8s.io/cluster-api/api/core/v1beta2.Topology)
 	return nil
@@ -771,6 +772,7 @@ func autoConvert_v1beta2_ClusterSpec_To_v1alpha4_ClusterSpec(in *v1beta2.Cluster
 		return err
 	}
 	// WARNING: in.ControlPlaneRef requires manual conversion: inconvertible types (sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference vs *k8s.io/api/core/v1.ObjectReference)
+	// WARNING: in.ManagedExternalEtcdRef requires manual conversion: inconvertible types (sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference vs *k8s.io/api/core/v1.ObjectReference)
 	// WARNING: in.InfrastructureRef requires manual conversion: inconvertible types (sigs.k8s.io/cluster-api/api/core/v1beta2.ContractVersionedObjectReference vs *k8s.io/api/core/v1.ObjectReference)
 	// WARNING: in.Topology requires manual conversion: inconvertible types (sigs.k8s.io/cluster-api/api/core/v1beta2.Topology vs *sigs.k8s.io/cluster-api/internal/api/core/v1alpha4.Topology)
 	// WARNING: in.AvailabilityGates requires manual conversion: does not exist in peer-type
@@ -796,6 +798,8 @@ func autoConvert_v1alpha4_ClusterStatus_To_v1beta2_ClusterStatus(in *ClusterStat
 		out.Conditions = nil
 	}
 	out.ObservedGeneration = in.ObservedGeneration
+	out.ManagedExternalEtcdInitialized = in.ManagedExternalEtcdInitialized
+	out.ManagedExternalEtcdReady = in.ManagedExternalEtcdReady
 	return nil
 }
 
@@ -817,6 +821,8 @@ func autoConvert_v1beta2_ClusterStatus_To_v1alpha4_ClusterStatus(in *v1beta2.Clu
 	// WARNING: in.FailureDomains requires manual conversion: inconvertible types ([]sigs.k8s.io/cluster-api/api/core/v1beta2.FailureDomain vs sigs.k8s.io/cluster-api/internal/api/core/v1alpha4.FailureDomains)
 	out.Phase = in.Phase
 	out.ObservedGeneration = in.ObservedGeneration
+	out.ManagedExternalEtcdInitialized = in.ManagedExternalEtcdInitialized
+	out.ManagedExternalEtcdReady = in.ManagedExternalEtcdReady
 	// WARNING: in.Deprecated requires manual conversion: does not exist in peer-type
 	return nil
 }
diff --git a/internal/api/core/v1alpha4/zz_generated.deepcopy.go b/internal/api/core/v1alpha4/zz_generated.deepcopy.go
index 6d3e29c..835b147 100644
--- a/internal/api/core/v1alpha4/zz_generated.deepcopy.go
+++ b/internal/api/core/v1alpha4/zz_generated.deepcopy.go
@@ -247,6 +247,11 @@ func (in *ClusterSpec) DeepCopyInto(out *ClusterSpec) {
 		*out = new(v1.ObjectReference)
 		**out = **in
 	}
+	if in.ManagedExternalEtcdRef != nil {
+		in, out := &in.ManagedExternalEtcdRef, &out.ManagedExternalEtcdRef
+		*out = new(v1.ObjectReference)
+		**out = **in
+	}
 	if in.InfrastructureRef != nil {
 		in, out := &in.InfrastructureRef, &out.InfrastructureRef
 		*out = new(v1.ObjectReference)
diff --git a/internal/controllers/cluster/cluster_controller.go b/internal/controllers/cluster/cluster_controller.go
index 7e66695..c668578 100644
--- a/internal/controllers/cluster/cluster_controller.go
+++ b/internal/controllers/cluster/cluster_controller.go
@@ -19,6 +19,7 @@ package cluster
 import (
 	"context"
 	"fmt"
+	"path"
 	"sort"
 	"strings"
 	"time"
@@ -69,7 +70,7 @@ const (
 //
 // +kubebuilder:rbac:groups=core,resources=events,verbs=create;patch
 // +kubebuilder:rbac:groups=core,resources=secrets,verbs=get;list;watch;create;patch;update
-// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io;bootstrap.cluster.x-k8s.io;controlplane.cluster.x-k8s.io,resources=*,verbs=get;list;watch;create;update;patch;delete
+// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io;bootstrap.cluster.x-k8s.io;controlplane.cluster.x-k8s.io;etcdcluster.cluster.x-k8s.io,resources=*,verbs=get;list;watch;create;update;patch;delete
 // +kubebuilder:rbac:groups=cluster.x-k8s.io,resources=clusters;clusters/status;clusters/finalizers,verbs=get;list;watch;update;patch
 // +kubebuilder:rbac:groups=apiextensions.k8s.io,resources=customresourcedefinitions,verbs=get;list;watch
 
@@ -104,6 +105,11 @@ func (r *Reconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, opt
 			handler.EnqueueRequestsFromMapFunc(r.controlPlaneMachineToCluster),
 			builder.WithPredicates(predicates.ResourceIsChanged(mgr.GetScheme(), predicateLog)),
 		).
+		Watches(
+			&clusterv1.Machine{},
+			handler.EnqueueRequestsFromMapFunc(r.etcdMachineToCluster),
+			builder.WithPredicates(predicates.ResourceIsChanged(mgr.GetScheme(), predicateLog)),
+		).
 		Watches(
 			&clusterv1.MachineDeployment{},
 			handler.EnqueueRequestsFromMapFunc(r.machineDeploymentToCluster),
@@ -202,6 +208,7 @@ func (r *Reconciler) Reconcile(ctx context.Context, req ctrl.Request) (retRes ct
 
 	alwaysReconcile := []clusterReconcileFunc{
 		r.reconcileInfrastructure,
+		r.reconcileEtcdCluster,
 		r.reconcileControlPlane,
 		r.getDescendants,
 	}
@@ -250,6 +257,7 @@ func patchCluster(ctx context.Context, patchHelper *patch.Helper, cluster *clust
 			clusterv1.ReadyV1Beta1Condition,
 			clusterv1.ControlPlaneReadyV1Beta1Condition,
 			clusterv1.InfrastructureReadyV1Beta1Condition,
+			clusterv1.ManagedExternalEtcdClusterReadyCondition,
 		}},
 		patch.WithOwnedConditions{Conditions: []string{
 			clusterv1.PausedCondition,
@@ -452,6 +460,37 @@ func (r *Reconciler) reconcileDelete(ctx context.Context, s *scope) (reconcile.R
 		}
 	}
 
+	if cluster.Spec.ManagedExternalEtcdRef.IsDefined() {
+		obj, err := external.GetObjectFromContractVersionedRef(ctx, r.Client, cluster.Spec.ManagedExternalEtcdRef, cluster.Namespace)
+		switch {
+		case apierrors.IsNotFound(errors.Cause(err)):
+			// Etcd cluster has been deleted
+			v1beta1conditions.MarkFalse(cluster, clusterv1.ManagedExternalEtcdClusterReadyCondition, clusterv1.DeletedV1Beta1Reason, clusterv1.ConditionSeverityInfo, "")
+		case err != nil:
+			return ctrl.Result{}, errors.Wrapf(err, "failed to get %s %q for Cluster %s/%s",
+				path.Join(cluster.Spec.ManagedExternalEtcdRef.APIGroup, cluster.Spec.ManagedExternalEtcdRef.Kind),
+				cluster.Spec.ManagedExternalEtcdRef.Name, cluster.Namespace, cluster.Name)
+		default:
+			// Report a summary of current status of the external etcd object defined for this cluster.
+			v1beta1conditions.SetMirror(cluster, clusterv1.ManagedExternalEtcdClusterReadyCondition,
+				v1beta1conditions.UnstructuredGetter(obj),
+				v1beta1conditions.WithFallbackValue(false, clusterv1.DeletingReason, clusterv1.ConditionSeverityInfo, ""),
+			)
+
+			// Issue a deletion request for the infrastructure object.
+			// Once it's been deleted, the cluster will get processed again.
+			if err := r.Client.Delete(ctx, obj); err != nil {
+				return ctrl.Result{}, errors.Wrapf(err,
+					"failed to delete %v %q for Cluster %q in namespace %q",
+					obj.GroupVersionKind(), obj.GetName(), cluster.Name, cluster.Namespace)
+			}
+
+			// Return here so we don't remove the finalizer yet.
+			log.Info("Cluster still has descendants - need to requeue", "managedExternalEtcdRef", cluster.Spec.ManagedExternalEtcdRef.Name)
+			return ctrl.Result{}, nil
+		}
+	}
+
 	if cluster.Spec.InfrastructureRef.IsDefined() {
 		if s.infraCluster == nil {
 			if !s.infraClusterIsNotFound {
@@ -509,6 +548,7 @@ type clusterDescendants struct {
 	machinesToBeRemediated collections.Machines
 	unhealthyMachines      collections.Machines
 	machinePools           clusterv1.MachinePoolList
+	etcdMachines           collections.Machines
 }
 
 // objectsPendingDeleteCount returns the number of descendants pending delete.
@@ -540,6 +580,13 @@ func (c *clusterDescendants) objectsPendingDeleteNames(cluster *clusterv1.Cluste
 			descendants = append(descendants, "Control plane Machines: "+clog.StringListToString(controlPlaneMachineNames))
 		}
 	}
+	etcdMachines := make([]string, len(collections.ToMachineList(c.etcdMachines).Items))
+	for i, etcdMachine := range collections.ToMachineList(c.etcdMachines).Items {
+		etcdMachines[i] = etcdMachine.Name
+	}
+	if len(etcdMachines) > 0 {
+		descendants = append(descendants, "Etcd machines: "+strings.Join(etcdMachines, ","))
+	}
 	machineDeploymentNames := make([]string, len(c.machineDeployments.Items))
 	for i, machineDeployment := range c.machineDeployments.Items {
 		machineDeploymentNames[i] = machineDeployment.Name
@@ -608,7 +655,8 @@ func (r *Reconciler) getDescendants(ctx context.Context, s *scope) (reconcile.Re
 	// Split machines into control plane and worker machines
 	descendants.allMachines = collections.FromMachineList(&machines)
 	descendants.controlPlaneMachines = descendants.allMachines.Filter(collections.ControlPlaneMachines(cluster.Name))
-	descendants.workerMachines = descendants.allMachines.Difference(descendants.controlPlaneMachines)
+	descendants.etcdMachines = descendants.allMachines.Filter(collections.EtcdMachines(cluster.Name))
+	descendants.workerMachines = descendants.allMachines.Difference(descendants.controlPlaneMachines).Difference(descendants.etcdMachines)
 	descendants.machinesToBeRemediated = descendants.allMachines.Filter(collections.IsUnhealthyAndOwnerRemediated)
 	descendants.unhealthyMachines = descendants.allMachines.Filter(collections.IsUnhealthy)
 
@@ -654,6 +702,9 @@ func (c *clusterDescendants) filterOwnedDescendants(cluster *clusterv1.Cluster)
 		&c.machineSets,
 		toObjectList(c.workerMachines),
 	}
+	if cluster.Spec.ManagedExternalEtcdRef.IsDefined() {
+		lists = append(lists, toObjectList(c.etcdMachines))
+	}
 	if feature.Gates.Enabled(feature.MachinePool) {
 		lists = append([]client.ObjectList{&c.machinePools}, lists...)
 	}
@@ -744,6 +795,36 @@ func (r *Reconciler) controlPlaneMachineToCluster(ctx context.Context, o client.
 	}}
 }
 
+// etcdMachineToCluster is a handler.ToRequestsFunc to be used to enqueue requests for reconciliation
+// for Cluster to update its status.ManagedExternalEtcdInitialized field
+func (r *Reconciler) etcdMachineToCluster(ctx context.Context, o client.Object) []ctrl.Request {
+	m, ok := o.(*clusterv1.Machine)
+	if !ok {
+		panic(fmt.Sprintf("Expected a Machine but got a %T", o))
+	}
+	if !util.IsEtcdMachine(m) {
+		return nil
+	}
+	// address has not been set, so ManagedExternalEtcdInitialized would not be true
+	if len(m.Status.Addresses) == 0 {
+		return nil
+	}
+
+	cluster, err := util.GetClusterByName(context.TODO(), r.Client, m.Namespace, m.Spec.ClusterName)
+	if err != nil {
+		return nil
+	}
+
+	if cluster.Status.ManagedExternalEtcdInitialized {
+		// no need to enqueue cluster for reconcile based on machine changes
+		return nil
+	}
+
+	return []ctrl.Request{{
+		NamespacedName: util.ObjectKey(cluster),
+	}}
+}
+
 // machineDeploymentToCluster is a handler.ToRequestsFunc to be used to enqueue requests for reconciliation
 // for Cluster to update when one of its own MachineDeployments gets updated.
 func (r *Reconciler) machineDeploymentToCluster(_ context.Context, o client.Object) []ctrl.Request {
diff --git a/internal/controllers/cluster/cluster_controller_phases.go b/internal/controllers/cluster/cluster_controller_phases.go
index 531c470..ea5a97e 100644
--- a/internal/controllers/cluster/cluster_controller_phases.go
+++ b/internal/controllers/cluster/cluster_controller_phases.go
@@ -22,6 +22,7 @@ import (
 	"strings"
 	"time"
 
+	"github.com/go-logr/logr"
 	"github.com/pkg/errors"
 	corev1 "k8s.io/api/core/v1"
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
@@ -39,6 +40,8 @@ import (
 	capierrors "sigs.k8s.io/cluster-api/errors"
 	"sigs.k8s.io/cluster-api/internal/contract"
 	"sigs.k8s.io/cluster-api/util"
+	"sigs.k8s.io/cluster-api/util/annotations"
+	"sigs.k8s.io/cluster-api/util/conditions"
 	v1beta1conditions "sigs.k8s.io/cluster-api/util/conditions/deprecated/v1beta1"
 	"sigs.k8s.io/cluster-api/util/kubeconfig"
 	"sigs.k8s.io/cluster-api/util/patch"
@@ -249,6 +252,14 @@ func (r *Reconciler) reconcileControlPlane(ctx context.Context, s *scope) (ctrl.
 		return ctrl.Result{}, nil
 	}
 
+	if cluster.Spec.ManagedExternalEtcdRef.IsDefined() {
+		if result, err := r.handlePauseControlPlaneWithExternalManagedEtcd(ctx, log, s); err != nil {
+			return ctrl.Result{}, err
+		} else if !result.IsZero() {
+			return result, nil
+		}
+	}
+
 	// Call generic external reconciler.
 	obj, err := r.reconcileExternal(ctx, cluster, cluster.Spec.ControlPlaneRef)
 	if err != nil {
@@ -342,6 +353,122 @@ func (r *Reconciler) reconcileControlPlane(ctx context.Context, s *scope) (ctrl.
 	return ctrl.Result{}, nil
 }
 
+// handlePauseControlPlaneWithExternalManagedEtcd pauses or unpauses the control plane through the pause
+// annotation based on the readiness of the external managed etcd (not-ready -> pause or ready -> unpause)
+func (r *Reconciler) handlePauseControlPlaneWithExternalManagedEtcd(ctx context.Context, log logr.Logger, s *scope) (ctrl.Result, error) {
+	cluster := s.cluster
+	controlPlane, err := external.GetObjectFromContractVersionedRef(ctx, r.Client, cluster.Spec.ControlPlaneRef, cluster.Namespace)
+	if apierrors.IsNotFound(errors.Cause(err)) {
+		log.Info("Could not find control plane object for cluster, requeuing", "refGroupVersionKind",
+			cluster.Spec.ControlPlaneRef.GroupKind(), "refName", cluster.Spec.ControlPlaneRef.Name,
+		)
+		s.controlPlane = nil
+		s.controlPlaneIsNotFound = true
+		return ctrl.Result{RequeueAfter: 30 * time.Second}, nil
+	}
+	if err != nil {
+		return ctrl.Result{}, err
+	}
+
+	// If user has opt-out from the pause/unpause functionality, just exit
+	if annotations.HasAnnotation(controlPlane, clusterv1.SkipControlPlanePauseManagedEtcdAnnotation) {
+		return ctrl.Result{}, nil
+	}
+
+	etcdRef := cluster.Spec.ManagedExternalEtcdRef
+	externalEtcd, err := external.GetObjectFromContractVersionedRef(ctx, r.Client, etcdRef, cluster.Namespace)
+	if err != nil {
+		if apierrors.IsNotFound(errors.Cause(err)) {
+			log.Info("Could not find external object for cluster, requeuing", "refGroupVersionKind", etcdRef.GroupKind(), "refName", etcdRef.Name)
+			return ctrl.Result{RequeueAfter: 30 * time.Second}, nil
+		}
+		return ctrl.Result{}, err
+	}
+
+	externalEtcdReady, err := external.IsReady(externalEtcd)
+	if err != nil {
+		return ctrl.Result{}, err
+	}
+
+	if externalEtcdReady && annotations.HasPaused(controlPlane) {
+		unstructured.RemoveNestedField(controlPlane.Object, "metadata", "annotations", clusterv1.PausedAnnotation)
+		if err := r.Client.Update(ctx, controlPlane); err != nil {
+			return ctrl.Result{Requeue: true}, errors.Wrap(err, "resuming control plane reconcile")
+		}
+	} else if !externalEtcdReady && !annotations.HasPaused(controlPlane) {
+		annotations.AddAnnotations(controlPlane, map[string]string{clusterv1.PausedAnnotation: "true"})
+		if err := r.Client.Update(ctx, controlPlane); err != nil {
+			return ctrl.Result{}, errors.Wrap(err, "pausing control plane reconcile")
+		}
+	}
+
+	return ctrl.Result{}, nil
+}
+
+func (r *Reconciler) reconcileEtcdCluster(ctx context.Context, s *scope) (ctrl.Result, error) {
+	log := ctrl.LoggerFrom(ctx)
+	cluster := s.cluster
+
+	if !cluster.Spec.ManagedExternalEtcdRef.IsDefined() {
+		return ctrl.Result{}, nil
+	}
+	// Call generic external reconciler.
+	obj, err := r.reconcileExternal(ctx, cluster, cluster.Spec.ManagedExternalEtcdRef)
+	etcdPlaneReconcileResult := external.ReconcileOutput{Result: obj}
+	if err != nil {
+		return ctrl.Result{}, err
+	}
+	// Return early if we need to requeue.
+	if etcdPlaneReconcileResult.RequeueAfter > 0 {
+		return ctrl.Result{RequeueAfter: etcdPlaneReconcileResult.RequeueAfter}, nil
+	}
+
+	etcdPlaneConfig := etcdPlaneReconcileResult.Result
+
+	// There's no need to go any further if the etcd cluster resource is marked for deletion.
+	if !etcdPlaneConfig.GetDeletionTimestamp().IsZero() {
+		return ctrl.Result{}, nil
+	}
+
+	// Determine if the etcd cluster is ready.
+	ready, err := external.IsReady(etcdPlaneConfig)
+	if err != nil {
+		return ctrl.Result{}, err
+	}
+	cluster.Status.ManagedExternalEtcdReady = ready
+
+	// Report a summary of current status of the etcd cluster object defined for this cluster.
+	v1beta1conditions.SetMirror(cluster, clusterv1.ManagedExternalEtcdClusterReadyCondition,
+		v1beta1conditions.UnstructuredGetter(etcdPlaneConfig),
+		v1beta1conditions.WithFallbackValue(ready, clusterv1.WaitingForEtcdClusterInitializedReason, clusterv1.ConditionSeverityInfo, ""),
+	)
+
+	// Update cluster.Status.ManagedExternalEtcdClusterInitializedCondition if it hasn't already been set
+	if !conditions.IsTrue(cluster, string(clusterv1.ManagedExternalEtcdClusterInitializedCondition)) {
+		initialized, err := external.IsInitialized(etcdPlaneConfig)
+		if err != nil {
+			return ctrl.Result{}, err
+		}
+		if initialized {
+			log.Info("reconcileEtcdCluster: Marking etcd cluster initialized setting it to true")
+			cluster.Status.ManagedExternalEtcdInitialized = true
+			conditions.Set(cluster, metav1.Condition{
+				Type: string(clusterv1.ManagedExternalEtcdClusterInitializedCondition),
+				Status: metav1.ConditionTrue,
+				Reason: clusterv1.ManagedExternalEtcdClusterInitializedReason,
+			})
+		} else {
+			conditions.Set(cluster, metav1.Condition{
+				Type: string(clusterv1.ManagedExternalEtcdClusterInitializedCondition),
+				Status: metav1.ConditionFalse,
+				Reason: clusterv1.WaitingForEtcdClusterInitializedReason,
+				Message: "Waiting for etcd cluster provider to indicate the etcd has been initialized",
+			})
+		}
+	}
+	return ctrl.Result{}, nil
+}
+
 func (r *Reconciler) reconcileKubeconfig(ctx context.Context, s *scope) (ctrl.Result, error) {
 	log := ctrl.LoggerFrom(ctx)
 	cluster := s.cluster
diff --git a/internal/controllers/cluster/cluster_controller_test.go b/internal/controllers/cluster/cluster_controller_test.go
index 645adb5..a627b9f 100644
--- a/internal/controllers/cluster/cluster_controller_test.go
+++ b/internal/controllers/cluster/cluster_controller_test.go
@@ -18,23 +18,28 @@ package cluster
 
 import (
 	"testing"
+	"time"
 
 	. "github.com/onsi/gomega"
 	corev1 "k8s.io/api/core/v1"
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
 	"k8s.io/client-go/tools/record"
 	utilfeature "k8s.io/component-base/featuregate/testing"
 	"k8s.io/utils/ptr"
 	ctrl "sigs.k8s.io/controller-runtime"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/client/fake"
+	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
+	"sigs.k8s.io/controller-runtime/pkg/reconcile"
 
 	clusterv1 "sigs.k8s.io/cluster-api/api/core/v1beta2"
 	runtimev1 "sigs.k8s.io/cluster-api/api/runtime/v1beta2"
 	"sigs.k8s.io/cluster-api/feature"
 	"sigs.k8s.io/cluster-api/internal/contract"
 	"sigs.k8s.io/cluster-api/util"
+	"sigs.k8s.io/cluster-api/util/annotations"
 	"sigs.k8s.io/cluster-api/util/collections"
 	"sigs.k8s.io/cluster-api/util/conditions"
 	v1beta1conditions "sigs.k8s.io/cluster-api/util/conditions/deprecated/v1beta1"
@@ -682,6 +687,124 @@ func TestClusterReconcilerNodeRef(t *testing.T) {
 	})
 }
 
+func TestClusterReconcilerEtcdMachineToCluster(t *testing.T) {
+	t.Run("machine to cluster", func(t *testing.T) {
+		clusterEtcdNotInitialized := &clusterv1.Cluster{
+			TypeMeta: metav1.TypeMeta{
+				Kind: "Cluster",
+			},
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      "test-cluster",
+				Namespace: "test",
+			},
+			Spec:   clusterv1.ClusterSpec{},
+			Status: clusterv1.ClusterStatus{},
+		}
+		clusterEtcdInitialized := &clusterv1.Cluster{
+			TypeMeta: metav1.TypeMeta{
+				Kind: "Cluster",
+			},
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      "test-cluster-etcd-init",
+				Namespace: "test",
+			},
+			Spec:   clusterv1.ClusterSpec{},
+			Status: clusterv1.ClusterStatus{ManagedExternalEtcdInitialized: true},
+		}
+		etcdMachineWithAddress := &clusterv1.Machine{
+			TypeMeta: metav1.TypeMeta{
+				Kind: "Machine",
+			},
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      "etcdWithAddress",
+				Namespace: "test",
+				Labels: map[string]string{
+					clusterv1.ClusterNameLabel:            clusterEtcdNotInitialized.Name,
+					clusterv1.MachineEtcdClusterLabelName: "",
+				},
+			},
+			Spec: clusterv1.MachineSpec{
+				ClusterName: "test-cluster",
+			},
+			Status: clusterv1.MachineStatus{
+				Addresses: clusterv1.MachineAddresses{clusterv1.MachineAddress{Type: clusterv1.MachineExternalIP, Address: "test"}},
+			},
+		}
+		etcdMachineNoAddress := &clusterv1.Machine{
+			TypeMeta: metav1.TypeMeta{
+				Kind: "Machine",
+			},
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      "etcdNoAddress",
+				Namespace: "test",
+				Labels: map[string]string{
+					clusterv1.ClusterNameLabel:            clusterEtcdNotInitialized.Name,
+					clusterv1.MachineEtcdClusterLabelName: "",
+				},
+			},
+			Spec: clusterv1.MachineSpec{
+				ClusterName: "test-cluster",
+			},
+			Status: clusterv1.MachineStatus{},
+		}
+		etcdMachineNoAddressForInitializedCluster := &clusterv1.Machine{
+			TypeMeta: metav1.TypeMeta{
+				Kind: "Machine",
+			},
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      "etcdNoAddressClusterEtcdInitialized",
+				Namespace: "test",
+				Labels: map[string]string{
+					clusterv1.ClusterNameLabel:            clusterEtcdInitialized.Name,
+					clusterv1.MachineEtcdClusterLabelName: "",
+				},
+			},
+			Spec: clusterv1.MachineSpec{
+				ClusterName: "test-cluster-etcd-init",
+			},
+			Status: clusterv1.MachineStatus{},
+		}
+
+		tests := []struct {
+			name string
+			o    client.Object
+			want []ctrl.Request
+		}{
+			{
+				name: "etcd machine, address is set, should return cluster",
+				o:    etcdMachineWithAddress,
+				want: []ctrl.Request{
+					{
+						NamespacedName: util.ObjectKey(clusterEtcdNotInitialized),
+					},
+				},
+			},
+			{
+				name: "etcd machine, address is not set, should not return cluster",
+				o:    etcdMachineNoAddress,
+				want: nil,
+			},
+			{
+				name: "etcd machine, address is not set, but etcd is initialized, should not return cluster",
+				o:    etcdMachineNoAddressForInitializedCluster,
+				want: nil,
+			},
+		}
+		for _, tt := range tests {
+			t.Run(tt.name, func(t *testing.T) {
+				g := NewWithT(t)
+
+				r := &Reconciler{
+					Client: fake.NewClientBuilder().WithObjects(clusterEtcdNotInitialized, clusterEtcdInitialized, etcdMachineNoAddress, etcdMachineWithAddress, etcdMachineNoAddressForInitializedCluster).Build(),
+				}
+
+				requests := r.etcdMachineToCluster(ctx, tt.o)
+				g.Expect(requests).To(Equal(tt.want))
+			})
+		}
+	})
+}
+
 type machineDeploymentBuilder struct {
 	md clusterv1.MachineDeployment
 }
@@ -761,6 +884,11 @@ func (b *machineBuilder) controlPlane() *machineBuilder {
 	return b
 }
 
+func (b *machineBuilder) etcd() *machineBuilder {
+	b.m.Labels = map[string]string{clusterv1.MachineEtcdClusterLabelName: ""}
+	return b
+}
+
 func (b *machineBuilder) build() clusterv1.Machine {
 	return b.m
 }
@@ -802,6 +930,9 @@ func TestFilterOwnedDescendants(t *testing.T) {
 		ObjectMeta: metav1.ObjectMeta{
 			Name: "c",
 		},
+		Spec: clusterv1.ClusterSpec{
+			ManagedExternalEtcdRef: clusterv1.ContractVersionedObjectReference{},
+		},
 	}
 
 	md1NotOwnedByCluster := newMachineDeploymentBuilder().named("md1").build()
@@ -826,6 +957,9 @@ func TestFilterOwnedDescendants(t *testing.T) {
 	mp3NotOwnedByCluster := newMachinePoolBuilder().named("mp3").build()
 	mp4OwnedByCluster := newMachinePoolBuilder().named("mp4").ownedBy(&c).build()
 
+	me1EtcdOwnedByCluster := newMachineBuilder().named("me1").ownedBy(&c).etcd().build()
+	me2EtcdNotOwnedByCluster := newMachineBuilder().named("me2").build()
+
 	d := clusterDescendants{
 		machineDeployments: clusterv1.MachineDeploymentList{
 			Items: []clusterv1.MachineDeployment{
@@ -865,6 +999,12 @@ func TestFilterOwnedDescendants(t *testing.T) {
 				mp4OwnedByCluster,
 			},
 		},
+		etcdMachines: collections.FromMachineList(&clusterv1.MachineList{
+			Items: []clusterv1.Machine{
+				me1EtcdOwnedByCluster,
+				me2EtcdNotOwnedByCluster,
+			},
+		}),
 	}
 
 	t.Run("Without a control plane object", func(t *testing.T) {
@@ -884,6 +1024,7 @@ func TestFilterOwnedDescendants(t *testing.T) {
 			&m5OwnedByCluster,
 			&m3ControlPlaneOwnedByCluster,
 			&m6ControlPlaneOwnedByCluster,
+			&me1EtcdOwnedByCluster,
 		))
 	})
 
@@ -995,3 +1136,254 @@ func TestReconcileV1Beta1ControlPlaneInitializedControlPlaneRef(t *testing.T) {
 	g.Expect(err).ToNot(HaveOccurred())
 	g.Expect(v1beta1conditions.Has(c, clusterv1.ControlPlaneInitializedV1Beta1Condition)).To(BeFalse())
 }
+
+func TestReconcileWithManagedEtcd(t *testing.T) {
+	t.Run("Should pause the ControlPlane when the external etcd becomes NotReady", func(t *testing.T) {
+		g := NewWithT(t)
+		ns := "my-ns"
+
+		managedEtcd := builder.Etcd(ns, "test-7-my-etcd").Build()
+		controlPlane := builder.TestControlPlane(ns, "test-7-my-cp").Build()
+		cluster := builder.Cluster(ns, "test-7-my-cluster").
+			WithControlPlane(controlPlane).
+			WithManagedEtcd(managedEtcd).
+			Build()
+		controllerutil.AddFinalizer(cluster, clusterv1.ClusterFinalizer)
+
+		c := fake.NewClientBuilder().
+			WithObjects(
+				builder.GenericEtcdCRD.DeepCopy(),
+				builder.TestControlPlaneCRD.DeepCopy(),
+				managedEtcd,
+				controlPlane,
+				cluster,
+			).Build()
+
+		r := &Reconciler{
+			Client:   c,
+			recorder: record.NewFakeRecorder(32),
+		}
+
+		result, err := r.Reconcile(
+			ctx,
+			reconcile.Request{NamespacedName: client.ObjectKeyFromObject(cluster)},
+		)
+		g.Expect(result).To(BeZero())
+		g.Expect(err).NotTo(HaveOccurred())
+
+		g.Eventually(func(g Gomega) {
+			cp := builder.TestControlPlane("", "").Build()
+			g.Expect(c.Get(ctx, client.ObjectKeyFromObject(controlPlane), cp)).To(Succeed())
+			g.Expect(annotations.HasPaused(cp)).To(BeTrue())
+		}, 5*time.Second).Should(Succeed())
+	})
+
+	t.Run("Should unpause the ControlPlane when the external etcd becomes Ready", func(t *testing.T) {
+		g := NewWithT(t)
+		ns := "my-ns"
+
+		managedEtcd := builder.Etcd(ns, "test-7-my-etcd").Build()
+		unstructured.SetNestedField(managedEtcd.Object, true, "status", "ready")
+		controlPlane := builder.TestControlPlane(ns, "test-7-my-cp").Build()
+		annotations.AddAnnotations(controlPlane, map[string]string{clusterv1.PausedAnnotation: "true"})
+		g.Expect(annotations.HasPaused(controlPlane)).To(BeTrue())
+		cluster := builder.Cluster(ns, "test-7-my-cluster").
+			WithControlPlane(controlPlane).
+			WithManagedEtcd(managedEtcd).
+			Build()
+		controllerutil.AddFinalizer(cluster, clusterv1.ClusterFinalizer)
+
+		c := fake.NewClientBuilder().
+			WithObjects(
+				builder.GenericEtcdCRD.DeepCopy(),
+				builder.TestControlPlaneCRD.DeepCopy(),
+				managedEtcd,
+				controlPlane,
+				cluster,
+			).Build()
+
+		r := &Reconciler{
+			Client:   c,
+			recorder: record.NewFakeRecorder(32),
+		}
+
+		result, err := r.Reconcile(
+			ctx,
+			reconcile.Request{NamespacedName: client.ObjectKeyFromObject(cluster)},
+		)
+		g.Expect(result).To(BeZero())
+		g.Expect(err).NotTo(HaveOccurred())
+
+		g.Eventually(func(g Gomega) {
+			cp := builder.TestControlPlane("", "").Build()
+			g.Expect(c.Get(ctx, client.ObjectKeyFromObject(controlPlane), cp)).To(Succeed())
+			g.Expect(annotations.HasPaused(cp)).To(BeFalse())
+		}, 5*time.Second).Should(Succeed())
+	})
+
+	t.Run("Should keep the ControlPlane unpaused when the external etcd is Ready", func(t *testing.T) {
+		g := NewWithT(t)
+		ns := "my-ns"
+
+		managedEtcd := builder.Etcd(ns, "test-7-my-etcd").Build()
+		unstructured.SetNestedField(managedEtcd.Object, true, "status", "ready")
+		controlPlane := builder.TestControlPlane(ns, "test-7-my-cp").Build()
+		cluster := builder.Cluster(ns, "test-7-my-cluster").
+			WithControlPlane(controlPlane).
+			WithManagedEtcd(managedEtcd).
+			Build()
+		controllerutil.AddFinalizer(cluster, clusterv1.ClusterFinalizer)
+
+		c := fake.NewClientBuilder().
+			WithObjects(
+				builder.GenericEtcdCRD.DeepCopy(),
+				builder.TestControlPlaneCRD.DeepCopy(),
+				managedEtcd,
+				controlPlane,
+				cluster,
+			).Build()
+
+		r := &Reconciler{
+			Client:   c,
+			recorder: record.NewFakeRecorder(32),
+		}
+
+		result, err := r.Reconcile(
+			ctx,
+			reconcile.Request{NamespacedName: client.ObjectKeyFromObject(cluster)},
+		)
+		g.Expect(result).To(BeZero())
+		g.Expect(err).NotTo(HaveOccurred())
+
+		g.Eventually(func(g Gomega) {
+			cp := builder.TestControlPlane("", "").Build()
+			g.Expect(c.Get(ctx, client.ObjectKeyFromObject(controlPlane), cp)).To(Succeed())
+			g.Expect(annotations.HasPaused(cp)).To(BeFalse())
+		}, 5*time.Second).Should(Succeed())
+	})
+
+	t.Run("Should not pause the ControlPlane with the skip annotation when the external etcd becomes NotReady", func(t *testing.T) {
+		g := NewWithT(t)
+		ns := "my-ns"
+
+		managedEtcd := builder.Etcd(ns, "test-7-my-etcd").Build()
+		controlPlane := builder.TestControlPlane(ns, "test-7-my-cp").Build()
+		annotations.AddAnnotations(
+			controlPlane,
+			map[string]string{clusterv1.SkipControlPlanePauseManagedEtcdAnnotation: "true"},
+		)
+		cluster := builder.Cluster(ns, "test-7-my-cluster").
+			WithControlPlane(controlPlane).
+			WithManagedEtcd(managedEtcd).
+			Build()
+		controllerutil.AddFinalizer(cluster, clusterv1.ClusterFinalizer)
+
+		c := fake.NewClientBuilder().
+			WithObjects(
+				builder.GenericEtcdCRD.DeepCopy(),
+				builder.TestControlPlaneCRD.DeepCopy(),
+				managedEtcd,
+				controlPlane,
+				cluster,
+			).Build()
+
+		r := &Reconciler{
+			Client:   c,
+			recorder: record.NewFakeRecorder(32),
+		}
+
+		result, err := r.Reconcile(
+			ctx,
+			reconcile.Request{NamespacedName: client.ObjectKeyFromObject(cluster)},
+		)
+		g.Expect(result).To(BeZero())
+		g.Expect(err).NotTo(HaveOccurred())
+
+		g.Eventually(func(g Gomega) {
+			cp := builder.TestControlPlane("", "").Build()
+			g.Expect(c.Get(ctx, client.ObjectKeyFromObject(controlPlane), cp)).To(Succeed())
+			g.Expect(annotations.HasPaused(cp)).To(BeFalse())
+		}, 5*time.Second).Should(Succeed())
+	})
+
+	t.Run("Should not unpause the ControlPlane with skip annotation when the external etcd becomes Ready", func(t *testing.T) {
+		g := NewWithT(t)
+		ns := "my-ns"
+
+		managedEtcd := builder.Etcd(ns, "test-7-my-etcd").Build()
+		unstructured.SetNestedField(managedEtcd.Object, true, "status", "ready")
+		controlPlane := builder.TestControlPlane(ns, "test-7-my-cp").Build()
+		annotations.AddAnnotations(controlPlane, map[string]string{clusterv1.PausedAnnotation: "true"})
+		annotations.AddAnnotations(
+			controlPlane,
+			map[string]string{clusterv1.SkipControlPlanePauseManagedEtcdAnnotation: "true"},
+		)
+		g.Expect(annotations.HasPaused(controlPlane)).To(BeTrue())
+		cluster := builder.Cluster(ns, "test-7-my-cluster").
+			WithControlPlane(controlPlane).
+			WithManagedEtcd(managedEtcd).
+			Build()
+		controllerutil.AddFinalizer(cluster, clusterv1.ClusterFinalizer)
+
+		c := fake.NewClientBuilder().
+			WithObjects(
+				builder.GenericEtcdCRD.DeepCopy(),
+				builder.TestControlPlaneCRD.DeepCopy(),
+				managedEtcd,
+				controlPlane,
+				cluster,
+			).Build()
+
+		r := &Reconciler{
+			Client:   c,
+			recorder: record.NewFakeRecorder(32),
+		}
+
+		result, err := r.Reconcile(
+			ctx,
+			reconcile.Request{NamespacedName: client.ObjectKeyFromObject(cluster)},
+		)
+		g.Expect(result).To(BeZero())
+		g.Expect(err).NotTo(HaveOccurred())
+
+		g.Eventually(func(g Gomega) {
+			cp := builder.TestControlPlane("", "").Build()
+			g.Expect(c.Get(ctx, client.ObjectKeyFromObject(controlPlane), cp)).To(Succeed())
+			g.Expect(annotations.HasPaused(cp)).To(BeTrue())
+		}, 5*time.Second).Should(Succeed())
+	})
+
+	t.Run("Should requeue when etcd is not found", func(t *testing.T) {
+		g := NewWithT(t)
+		ns := "my-ns"
+
+		managedEtcd := builder.Etcd(ns, "test-7-my-etcd").Build()
+		unstructured.SetNestedField(managedEtcd.Object, true, "status", "ready")
+		controlPlane := builder.TestControlPlane(ns, "test-7-my-cp").Build()
+		cluster := builder.Cluster(ns, "test-7-my-cluster").
+			WithControlPlane(controlPlane).
+			WithManagedEtcd(managedEtcd).
+			Build()
+		controllerutil.AddFinalizer(cluster, clusterv1.ClusterFinalizer)
+
+		c := fake.NewClientBuilder().
+			WithObjects(
+				builder.GenericEtcdCRD.DeepCopy(),
+				builder.TestControlPlaneCRD.DeepCopy(),
+				controlPlane,
+				cluster,
+			).Build()
+
+		r := &Reconciler{
+			Client:   c,
+			recorder: record.NewFakeRecorder(32),
+		}
+
+		result, err := r.Reconcile(
+			ctx,
+			reconcile.Request{NamespacedName: client.ObjectKeyFromObject(cluster)},
+		)
+		g.Expect(result).To(Equal(ctrl.Result{RequeueAfter: 30 * time.Second}))
+		g.Expect(err).NotTo(HaveOccurred())
+	})
+}
diff --git a/internal/controllers/machine/machine_controller_noderef.go b/internal/controllers/machine/machine_controller_noderef.go
index 7d1a62a..9b82463 100644
--- a/internal/controllers/machine/machine_controller_noderef.go
+++ b/internal/controllers/machine/machine_controller_noderef.go
@@ -67,6 +67,14 @@ func (r *Reconciler) reconcileNode(ctx context.Context, s *scope) (ctrl.Result,
 		return ctrl.Result{}, err
 	}
 
+	if _, ok := machine.Labels[clusterv1.MachineEtcdClusterLabelName]; ok {
+		// Etcd member Machines do not correspond to Kubernetes v1 Nodes; cannot get k8s node to set nodeRef
+		// This prevents the MachineNodeHealthyCondition from being set in etcd machines, neither true nor false.
+		// It makes sense since etcd machines are not kubernetes nodes and it doesn't present any issues since the
+		// summary ready condition doesn't depend on it.
+		return ctrl.Result{}, nil
+	}
+
 	// Check that the Machine has a valid ProviderID.
 	if machine.Spec.ProviderID == "" {
 		log.Info("Waiting for infrastructure provider to report spec.providerID", machine.Spec.InfrastructureRef.Kind, klog.KRef(machine.Namespace, machine.Spec.InfrastructureRef.Name))
diff --git a/internal/controllers/machine/machine_controller_noderef_test.go b/internal/controllers/machine/machine_controller_noderef_test.go
index 100cdfc..469ccdb 100644
--- a/internal/controllers/machine/machine_controller_noderef_test.go
+++ b/internal/controllers/machine/machine_controller_noderef_test.go
@@ -41,6 +41,7 @@ import (
 	"sigs.k8s.io/cluster-api/controllers/remote"
 	"sigs.k8s.io/cluster-api/internal/topology/ownerrefs"
 	"sigs.k8s.io/cluster-api/util"
+	"sigs.k8s.io/cluster-api/util/conditions"
 	"sigs.k8s.io/cluster-api/util/kubeconfig"
 	"sigs.k8s.io/cluster-api/util/test/builder"
 )
@@ -1489,3 +1490,47 @@ func Test_shouldNodeHaveOutdatedTaint(t *testing.T) {
 		})
 	}
 }
+
+func TestReconcileNodeForEtcdMachines(t *testing.T) {
+	testCases := []struct {
+		name    string
+		machine *clusterv1.Machine
+	}{
+		{
+			name: "with providerID",
+			machine: &clusterv1.Machine{
+				ObjectMeta: metav1.ObjectMeta{
+					Labels: map[string]string{
+						clusterv1.MachineEtcdClusterLabelName: "true",
+					},
+				},
+				Spec: clusterv1.MachineSpec{
+					ProviderID: "ID",
+				},
+			},
+		},
+		{
+			name: "without providerID",
+			machine: &clusterv1.Machine{
+				ObjectMeta: metav1.ObjectMeta{
+					Labels: map[string]string{
+						clusterv1.MachineEtcdClusterLabelName: "true",
+					},
+				},
+				Spec: clusterv1.MachineSpec{},
+			},
+		},
+	}
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			g := NewWithT(t)
+			r := Reconciler{Client: env}
+			s := &scope{
+				cluster: &clusterv1.Cluster{},
+				machine: tc.machine,
+			}
+			g.Expect(r.reconcileNode(ctx, s)).To(Equal(ctrl.Result{}))
+			g.Expect(conditions.Get(tc.machine, clusterv1.MachineNodeHealthyCondition)).To(BeNil())
+		})
+	}
+}
diff --git a/internal/controllers/machine/machine_controller_phases.go b/internal/controllers/machine/machine_controller_phases.go
index 27380dc..e823b58 100644
--- a/internal/controllers/machine/machine_controller_phases.go
+++ b/internal/controllers/machine/machine_controller_phases.go
@@ -22,6 +22,7 @@ import (
 	"time"
 
 	"github.com/pkg/errors"
+	corev1 "k8s.io/api/core/v1"
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
@@ -29,6 +30,7 @@ import (
 	"k8s.io/klog/v2"
 	"k8s.io/utils/ptr"
 	ctrl "sigs.k8s.io/controller-runtime"
+	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
 	"sigs.k8s.io/controller-runtime/pkg/handler"
 
@@ -337,6 +339,121 @@ func (r *Reconciler) reconcileInfrastructure(ctx context.Context, s *scope) (ctr
 		m.Status.Addresses = *addresses
 	}
 
+	if cluster.Spec.ManagedExternalEtcdRef.IsDefined() {
+		// set first node's IP address on EtcdCluster
+		// get etcd cluster
+		ref := cluster.Spec.ManagedExternalEtcdRef
+		obj, err := external.GetObjectFromContractVersionedRef(ctx, r.Client, ref, cluster.Namespace)
+		if err != nil {
+			if apierrors.IsNotFound(errors.Cause(err)) {
+				return ctrl.Result{}, err
+			}
+			return ctrl.Result{}, err
+		}
+		// Initialize the patch helper.
+		patchHelper, err := patch.NewHelper(obj, r.Client)
+		if err != nil {
+			return ctrl.Result{}, err
+		}
+		address, addressSet, err := unstructured.NestedFieldNoCopy(obj.Object, "status", "initMachineAddress")
+		if err != nil {
+			return ctrl.Result{}, err
+		}
+
+		if !addressSet || address == "" {
+			etcdSecretName := fmt.Sprintf("%v-%v", cluster.Name, "etcd-init")
+			existingSecret := &corev1.Secret{}
+			if err := r.Client.Get(ctx, client.ObjectKey{Namespace: cluster.Namespace, Name: etcdSecretName}, existingSecret); err != nil {
+				if apierrors.IsNotFound(err) {
+					// secret doesn't exist, so create it for the init machine
+					var internalIP, internalDNS, externalIP, externalDNS, machineIP string
+					for _, address := range m.Status.Addresses {
+						switch address.Type {
+						case clusterv1.MachineInternalIP:
+							internalIP = address.Address
+						case clusterv1.MachineInternalDNS:
+							internalDNS = address.Address
+						case clusterv1.MachineExternalIP:
+							externalIP = address.Address
+						case clusterv1.MachineExternalDNS:
+							externalDNS = address.Address
+						}
+					}
+
+					// The order of these checks determines the precedence of the address to use
+					if externalDNS != "" {
+						machineIP = externalDNS
+					} else if externalIP != "" {
+						machineIP = externalIP
+					} else if internalDNS != "" {
+						machineIP = internalDNS
+					} else if internalIP != "" {
+						machineIP = internalIP
+					}
+
+					if machineIP == "" {
+						return ctrl.Result{}, fmt.Errorf("error getting etcd init IP address: %v", err)
+					}
+
+					secret := &corev1.Secret{
+						ObjectMeta: metav1.ObjectMeta{
+							Name:      etcdSecretName,
+							Namespace: cluster.Namespace,
+							Labels: map[string]string{
+								clusterv1.ClusterNameLabel: cluster.Name,
+							},
+							OwnerReferences: []metav1.OwnerReference{
+								{
+									APIVersion: clusterv1.GroupVersion.String(),
+									Kind:       cluster.Kind,
+									Name:       cluster.Name,
+									UID:        cluster.UID,
+								},
+							},
+						},
+						Data: map[string][]byte{
+							"address": []byte(machineIP),
+						},
+						Type: clusterv1.ClusterSecretType,
+					}
+					if err := r.Client.Create(ctx, secret); err != nil && !apierrors.IsAlreadyExists(err) {
+						return ctrl.Result{}, err
+					}
+
+					// set the Secret name on etcdCluster and update it so it receives a sync
+					if err := unstructured.SetNestedField(obj.Object, etcdSecretName, "status", "initMachineAddress"); err != nil {
+						return ctrl.Result{}, err
+					}
+					// set Initialized to true on etcdCluster and update it so it receives a sync
+					if err := unstructured.SetNestedField(obj.Object, true, "status", "initialized"); err != nil {
+						return ctrl.Result{}, err
+					}
+					// Always attempt to Patch the external object.
+					if err := patchHelper.Patch(ctx, obj); err != nil {
+						return ctrl.Result{}, err
+					}
+				} else {
+					log.Error(err, "error getting etcd init secret containing address")
+					return ctrl.Result{}, err
+				}
+			} else {
+				// secret exists but etcdcluster status field doesn't contain the secret name: can happen only after move
+				// set the Secret name on etcdCluster and update it so it receives a sync
+				if err := unstructured.SetNestedField(obj.Object, etcdSecretName, "status", "initMachineAddress"); err != nil {
+					return ctrl.Result{}, err
+				}
+				// set Initialized to true on etcdCluster and update it so it receives a sync
+				if err := unstructured.SetNestedField(obj.Object, true, "status", "initialized"); err != nil {
+					return ctrl.Result{}, err
+				}
+				// Always attempt to Patch the external object.
+				if err := patchHelper.Patch(ctx, obj); err != nil {
+					return ctrl.Result{}, err
+				}
+			}
+		}
+	}
+
 	// Get and set failureDomain from the InfrastructureMachine.
 	failureDomain, err := contract.InfrastructureMachine().FailureDomain().Get(s.infraMachine)
 	switch {
diff --git a/internal/controllers/machine/machine_controller_status.go b/internal/controllers/machine/machine_controller_status.go
index 59c70ca..a0bc536 100644
--- a/internal/controllers/machine/machine_controller_status.go
+++ b/internal/controllers/machine/machine_controller_status.go
@@ -818,6 +818,13 @@ func setMachinePhaseAndLastUpdated(_ context.Context, m *clusterv1.Machine) {
 		m.Status.SetTypedPhase(clusterv1.MachinePhaseRunning)
 	}
 
+	if _, ok := m.Labels[clusterv1.MachineEtcdClusterLabelName]; ok {
+		// Status.NodeRef does not get set for etcd machines since they don't correspond to k8s node objects
+		if ptr.Deref(m.Status.Initialization.InfrastructureProvisioned, false) {
+			m.Status.SetTypedPhase(clusterv1.MachinePhaseRunning)
+		}
+	}
+
 	// Set the phase to "deleting" if the deletion timestamp is set.
 	if !m.DeletionTimestamp.IsZero() {
 		m.Status.SetTypedPhase(clusterv1.MachinePhaseDeleting)
diff --git a/util/annotations/helpers.go b/util/annotations/helpers.go
index c378fa2..1a71cfe 100644
--- a/util/annotations/helpers.go
+++ b/util/annotations/helpers.go
@@ -120,6 +120,11 @@ func GetManagedAnnotations(m *clusterv1.Machine, additionalSyncMachineAnnotation
 	return managedAnnotations
 }
 
+// HasAnnotation returns true if the object has the specified annotation.
+func HasAnnotation(o metav1.Object, annotation string) bool {
+	return hasAnnotation(o, annotation)
+}
+
 // hasAnnotation returns true if the object has the specified annotation.
 func hasAnnotation(o metav1.Object, annotation string) bool {
 	annotations := o.GetAnnotations()
diff --git a/util/collections/machine_filters.go b/util/collections/machine_filters.go
index 4f73406..5961ad4 100644
--- a/util/collections/machine_filters.go
+++ b/util/collections/machine_filters.go
@@ -122,6 +122,18 @@ func ControlPlaneMachines(clusterName string) func(machine *clusterv1.Machine) b
 	}
 }
 
+// EtcdMachines returns a filter to find all etcd machines for a cluster, regardless of ownership.
+// Usage: GetFilteredMachinesForCluster(ctx, client, cluster, EtcdMachines(cluster.Name)).
+func EtcdMachines(clusterName string) func(machine *clusterv1.Machine) bool {
+	selector := EtcdSelectorForCluster(clusterName)
+	return func(machine *clusterv1.Machine) bool {
+		if machine == nil {
+			return false
+		}
+		return selector.Matches(labels.Set(machine.Labels))
+	}
+}
+
 // AdoptableControlPlaneMachines returns a filter to find all un-controlled control plane machines.
 // Usage: GetFilteredMachinesForCluster(ctx, client, cluster, AdoptableControlPlaneMachines(cluster.Name, controlPlane)).
 func AdoptableControlPlaneMachines(clusterName string) func(machine *clusterv1.Machine) bool {
@@ -271,6 +283,20 @@ func ControlPlaneSelectorForCluster(clusterName string) labels.Selector {
 	)
 }
 
+// EtcdSelectorForCluster returns the label selector necessary to get etcd machines for a given cluster.
+func EtcdSelectorForCluster(clusterName string) labels.Selector {
+	must := func(r *labels.Requirement, err error) labels.Requirement {
+		if err != nil {
+			panic(err)
+		}
+		return *r
+	}
+	return labels.NewSelector().Add(
+		must(labels.NewRequirement(clusterv1.ClusterNameLabel, selection.Equals, []string{clusterName})),
+		must(labels.NewRequirement(clusterv1.MachineEtcdClusterLabelName, selection.Exists, []string{})),
+	)
+}
+
 // MatchesKubernetesVersion returns a filter to find all machines that match a given Kubernetes version.
 func MatchesKubernetesVersion(kubernetesVersion string) Func {
 	return func(machine *clusterv1.Machine) bool {
diff --git a/util/secret/certificates.go b/util/secret/certificates.go
index 8af1c12..3e43069 100644
--- a/util/secret/certificates.go
+++ b/util/secret/certificates.go
@@ -445,6 +445,9 @@ func (c Certificates) AsFiles() []bootstrapv1.File {
 	if serviceAccountKey := c.GetByPurpose(ServiceAccount); serviceAccountKey != nil {
 		certFiles = append(certFiles, serviceAccountKey.AsFiles()...)
 	}
+	if managedEtcdCACertKey := c.GetByPurpose(ManagedExternalEtcdCA); managedEtcdCACertKey != nil {
+		certFiles = append(certFiles, managedEtcdCACertKey.AsFiles()...)
+	}
 
 	// these will only exist if external etcd was defined and supplied by the user
 	if apiserverEtcdClientCert := c.GetByPurpose(APIServerEtcdClient); apiserverEtcdClientCert != nil {
diff --git a/util/secret/consts.go b/util/secret/consts.go
index d50062d..0437643 100644
--- a/util/secret/consts.go
+++ b/util/secret/consts.go
@@ -48,6 +48,8 @@ const (
 
 	// APIServerEtcdClient is the secret name of user-supplied secret containing the apiserver-etcd-client key/cert.
 	APIServerEtcdClient = Purpose("apiserver-etcd-client")
+
+	ManagedExternalEtcdCA = Purpose("managed-etcd")
 )
 
 var (
diff --git a/util/test/builder/builders.go b/util/test/builder/builders.go
index 042b975..61ed45c 100644
--- a/util/test/builder/builders.go
+++ b/util/test/builder/builders.go
@@ -40,6 +40,7 @@ type ClusterBuilder struct {
 	infrastructureCluster *unstructured.Unstructured
 	controlPlane          *unstructured.Unstructured
 	network               clusterv1.ClusterNetwork
+	etcd                  *unstructured.Unstructured
 }
 
 // Cluster returns a ClusterBuilder with the given name and namespace.
@@ -80,6 +81,12 @@ func (c *ClusterBuilder) WithControlPlane(t *unstructured.Unstructured) *Cluster
 	return c
 }
 
+// WithManagedEtcd adds the passed etcd to the ClusterBuilder.
+func (c *ClusterBuilder) WithManagedEtcd(t *unstructured.Unstructured) *ClusterBuilder {
+	c.etcd = t
+	return c
+}
+
 // WithTopology adds the passed Topology object to the ClusterBuilder.
 func (c *ClusterBuilder) WithTopology(topology *clusterv1.Topology) *ClusterBuilder {
 	c.topology = topology
diff --git a/util/test/builder/etcd.go b/util/test/builder/etcd.go
new file mode 100644
index 0000000..9c18757
--- /dev/null
+++ b/util/test/builder/etcd.go
@@ -0,0 +1,80 @@
+/*
+Copyright 2021 The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package builder
+
+import (
+	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+)
+
+var (
+	// EtcdGroupVersion is group version used for control plane objects.
+	EtcdGroupVersion = schema.GroupVersion{Group: "etcd.cluster.x-k8s.io", Version: "v1beta1"}
+
+	// GenericEtcdKind is the Kind for the GenericEtcd.
+	GenericEtcdKind = "GenericEtcd"
+	// GenericEtcdCRD is a generic control plane CRD.
+	GenericEtcdCRD = testEtcdCRD(EtcdGroupVersion.WithKind(GenericEtcdKind))
+)
+
+func testEtcdCRD(gvk schema.GroupVersionKind) *apiextensionsv1.CustomResourceDefinition {
+	return generateCRD(gvk, map[string]apiextensionsv1.JSONSchemaProps{
+		"metadata": {
+			// NOTE: in CRD there is only a partial definition of metadata schema.
+			// Ref https://github.com/kubernetes-sigs/controller-tools/blob/59485af1c1f6a664655dad49543c474bb4a0d2a2/pkg/crd/gen.go#L185
+			Type: "object",
+		},
+		"spec": etcdSpecSchema,
+		"status": {
+			Type: "object",
+			Properties: map[string]apiextensionsv1.JSONSchemaProps{
+				// mandatory fields from the Cluster API contract
+				"ready":       {Type: "boolean"},
+				"initialized": {Type: "boolean"},
+				"endpoints":   {Type: "string"},
+			},
+		},
+	})
+}
+
+var etcdSpecSchema = apiextensionsv1.JSONSchemaProps{
+	Type:       "object",
+	Properties: map[string]apiextensionsv1.JSONSchemaProps{},
+}
+
+// EtcdPlaneBuilder holds the variables and objects needed to build a generic object for cluster.spec.ManagedExternalEtcdRef.
+type EtcdPlaneBuilder struct {
+	obj *unstructured.Unstructured
+}
+
+// Etcd returns a EtcdBuilder with the given name and Namespace.
+func Etcd(namespace, name string) *EtcdPlaneBuilder {
+	obj := &unstructured.Unstructured{}
+	obj.SetAPIVersion(EtcdGroupVersion.String())
+	obj.SetKind(GenericEtcdKind)
+	obj.SetNamespace(namespace)
+	obj.SetName(name)
+	return &EtcdPlaneBuilder{
+		obj: obj,
+	}
+}
+
+// Build generates an Unstructured object from the information passed to the EtcdPlaneBuilder.
+func (c *EtcdPlaneBuilder) Build() *unstructured.Unstructured {
+	return c.obj
+}
diff --git a/util/test/builder/zz_generated.deepcopy.go b/util/test/builder/zz_generated.deepcopy.go
index 426f5dc..d69fdd8 100644
--- a/util/test/builder/zz_generated.deepcopy.go
+++ b/util/test/builder/zz_generated.deepcopy.go
@@ -96,6 +96,10 @@ func (in *ClusterBuilder) DeepCopyInto(out *ClusterBuilder) {
 		*out = (*in).DeepCopy()
 	}
 	in.network.DeepCopyInto(&out.network)
+	if in.etcd != nil {
+		in, out := &in.etcd, &out.etcd
+		*out = (*in).DeepCopy()
+	}
 }
 
 // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterBuilder.
@@ -282,6 +286,25 @@ func (in *ControlPlaneTemplateBuilder) DeepCopy() *ControlPlaneTemplateBuilder {
 	return out
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *EtcdPlaneBuilder) DeepCopyInto(out *EtcdPlaneBuilder) {
+	*out = *in
+	if in.obj != nil {
+		in, out := &in.obj, &out.obj
+		*out = (*in).DeepCopy()
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EtcdPlaneBuilder.
+func (in *EtcdPlaneBuilder) DeepCopy() *EtcdPlaneBuilder {
+	if in == nil {
+		return nil
+	}
+	out := new(EtcdPlaneBuilder)
+	in.DeepCopyInto(out)
+	return out
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *InfrastructureClusterBuilder) DeepCopyInto(out *InfrastructureClusterBuilder) {
 	*out = *in
diff --git a/util/util.go b/util/util.go
index 684ef3d..3566067 100644
--- a/util/util.go
+++ b/util/util.go
@@ -145,6 +145,12 @@ func IsNodeReady(node *corev1.Node) bool {
 	return false
 }
 
+// IsEtcdMachine checks if machine is an etcd machine.
+func IsEtcdMachine(machine *clusterv1.Machine) bool {
+	_, ok := machine.ObjectMeta.Labels[clusterv1.MachineEtcdClusterLabelName]
+	return ok
+}
+
 // GetClusterFromMetadata returns the Cluster object (if present) using the object metadata.
 func GetClusterFromMetadata(ctx context.Context, c client.Client, obj metav1.ObjectMeta) (*clusterv1.Cluster, error) {
 	if obj.Labels[clusterv1.ClusterNameLabel] == "" {
-- 
2.50.1 (Apple Git-155)

