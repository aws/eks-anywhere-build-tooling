From 5a3e60a9ae0b1ac2a8c53b0de01d48e4b8372105 Mon Sep 17 00:00:00 2001
From: Guillermo Gaston <gaslor@amazon.com>
Date: Fri, 4 Nov 2022 13:55:39 +0000
Subject: [PATCH 20/27] Implement Reconcile mode for ClusterResourceSet

---
 ....cluster.x-k8s.io_clusterresourcesets.yaml |   1 +
 .../cluster-resource-set.md                   |   5 +
 .../api/v1beta1/clusterresourceset_types.go   |   5 +-
 .../clusterresourcesetbinding_types.go        |  12 +-
 .../clusterresourcesetbinding_types_test.go   |  60 ++++
 .../clusterresourceset_controller.go          |  66 +---
 .../clusterresourceset_controller_test.go     | 291 +++++++++++++++---
 .../controllers/clusterresourceset_helpers.go | 133 +++++---
 .../controllers/clusterresourceset_scope.go   | 185 +++++++++++
 .../clusterresourceset_scope_test.go          | 251 +++++++++++++++
 .../predicates/resource_predicates.go         |   6 +-
 11 files changed, 862 insertions(+), 153 deletions(-)
 create mode 100644 exp/addons/internal/controllers/clusterresourceset_scope.go
 create mode 100644 exp/addons/internal/controllers/clusterresourceset_scope_test.go

diff --git a/config/crd/bases/addons.cluster.x-k8s.io_clusterresourcesets.yaml b/config/crd/bases/addons.cluster.x-k8s.io_clusterresourcesets.yaml
index d495f3aa2..8080f7d8f 100644
--- a/config/crd/bases/addons.cluster.x-k8s.io_clusterresourcesets.yaml
+++ b/config/crd/bases/addons.cluster.x-k8s.io_clusterresourcesets.yaml
@@ -438,6 +438,7 @@ spec:
                   Defaults to ApplyOnce. This field is immutable.
                 enum:
                 - ApplyOnce
+                - Reconcile
                 type: string
             required:
             - clusterSelector
diff --git a/docs/book/src/tasks/experimental-features/cluster-resource-set.md b/docs/book/src/tasks/experimental-features/cluster-resource-set.md
index 6b40739c3..ec7321567 100644
--- a/docs/book/src/tasks/experimental-features/cluster-resource-set.md
+++ b/docs/book/src/tasks/experimental-features/cluster-resource-set.md
@@ -8,3 +8,8 @@ The `ClusterResourceSet` feature is introduced to provide a way to automatically
 
 More details on `ClusterResourceSet` and an example to test it can be found at:
 [ClusterResourceSet CAEP](https://github.com/kubernetes-sigs/cluster-api/blob/main/docs/proposals/20200220-cluster-resource-set.md)
+
+## Update from `ApplyOnce` to `Reconcile`
+
+The `strategy` field is immutable so existing CRS can't be updated directly. However, CAPI won't delete the managed resources in the target cluster when the CRS is deleted.
+So if you want to start using the `Reconcile` strategy, delete your existing CRS and create it again with the updated `strategy`.
diff --git a/exp/addons/api/v1beta1/clusterresourceset_types.go b/exp/addons/api/v1beta1/clusterresourceset_types.go
index 77fd7dcc5..e64dccd29 100644
--- a/exp/addons/api/v1beta1/clusterresourceset_types.go
+++ b/exp/addons/api/v1beta1/clusterresourceset_types.go
@@ -46,7 +46,7 @@ type ClusterResourceSetSpec struct {
 	Resources []ResourceRef `json:"resources,omitempty"`
 
 	// Strategy is the strategy to be used during applying resources. Defaults to ApplyOnce. This field is immutable.
-	// +kubebuilder:validation:Enum=ApplyOnce
+	// +kubebuilder:validation:Enum=ApplyOnce;Reconcile
 	// +optional
 	Strategy string `json:"strategy,omitempty"`
 }
@@ -80,6 +80,9 @@ const (
 	// ClusterResourceSetStrategyApplyOnce is the default strategy a ClusterResourceSet strategy is assigned by
 	// ClusterResourceSet controller after being created if not specified by user.
 	ClusterResourceSetStrategyApplyOnce ClusterResourceSetStrategy = "ApplyOnce"
+	// ClusterResourceSetStrategyReconcile reapplies the resources managed by a ClusterResourceSet
+	// if their normalized hash changes.
+	ClusterResourceSetStrategyReconcile ClusterResourceSetStrategy = "Reconcile"
 )
 
 // SetTypedStrategy sets the Strategy field to the string representation of ClusterResourceSetStrategy.
diff --git a/exp/addons/api/v1beta1/clusterresourcesetbinding_types.go b/exp/addons/api/v1beta1/clusterresourcesetbinding_types.go
index 8a88cff99..47f8762ec 100644
--- a/exp/addons/api/v1beta1/clusterresourcesetbinding_types.go
+++ b/exp/addons/api/v1beta1/clusterresourcesetbinding_types.go
@@ -58,14 +58,18 @@ type ResourceSetBinding struct {
 
 // IsApplied returns true if the resource is applied to the cluster by checking the cluster's binding.
 func (r *ResourceSetBinding) IsApplied(resourceRef ResourceRef) bool {
+	resourceBinding := r.GetResource(resourceRef)
+	return resourceBinding != nil && resourceBinding.Applied
+}
+
+// GetResource returns a ResourceBinding for a resource ref if present.
+func (r *ResourceSetBinding) GetResource(resourceRef ResourceRef) *ResourceBinding {
 	for _, resource := range r.Resources {
 		if reflect.DeepEqual(resource.ResourceRef, resourceRef) {
-			if resource.Applied {
-				return true
-			}
+			return &resource
 		}
 	}
-	return false
+	return nil
 }
 
 // SetBinding sets resourceBinding for a resource in resourceSetbinding either by updating the existing one or
diff --git a/exp/addons/api/v1beta1/clusterresourcesetbinding_types_test.go b/exp/addons/api/v1beta1/clusterresourcesetbinding_types_test.go
index 5c59e40f5..8e6111c44 100644
--- a/exp/addons/api/v1beta1/clusterresourcesetbinding_types_test.go
+++ b/exp/addons/api/v1beta1/clusterresourcesetbinding_types_test.go
@@ -90,6 +90,66 @@ func TestIsResourceApplied(t *testing.T) {
 	}
 }
 
+func TestResourceSetBindingGetResourceBinding(t *testing.T) {
+	resourceRefApplyFailed := ResourceRef{
+		Name: "applyFailed",
+		Kind: "Secret",
+	}
+	resourceRefApplySucceeded := ResourceRef{
+		Name: "ApplySucceeded",
+		Kind: "Secret",
+	}
+	resourceRefNotExist := ResourceRef{
+		Name: "notExist",
+		Kind: "Secret",
+	}
+
+	resourceRefApplyFailedBinding := ResourceBinding{
+		ResourceRef:     resourceRefApplyFailed,
+		Applied:         false,
+		Hash:            "",
+		LastAppliedTime: &metav1.Time{Time: time.Now().UTC()},
+	}
+	crsBinding := &ResourceSetBinding{
+		ClusterResourceSetName: "test-clusterResourceSet",
+		Resources: []ResourceBinding{
+			{
+				ResourceRef:     resourceRefApplySucceeded,
+				Applied:         true,
+				Hash:            "xyz",
+				LastAppliedTime: &metav1.Time{Time: time.Now().UTC()},
+			},
+			resourceRefApplyFailedBinding,
+		},
+	}
+
+	tests := []struct {
+		name               string
+		resourceSetBinding *ResourceSetBinding
+		resourceRef        ResourceRef
+		want               *ResourceBinding
+	}{
+		{
+			name:               "does't exist",
+			resourceSetBinding: crsBinding,
+			resourceRef:        resourceRefNotExist,
+			want:               nil,
+		},
+		{
+			name:               "does't exist",
+			resourceSetBinding: crsBinding,
+			resourceRef:        resourceRefApplyFailed,
+			want:               &resourceRefApplyFailedBinding,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			gs := NewWithT(t)
+			gs.Expect(tt.resourceSetBinding.GetResource(tt.resourceRef)).To(Equal(tt.want))
+		})
+	}
+}
+
 func TestSetResourceBinding(t *testing.T) {
 	resourceRefApplyFailed := ResourceRef{
 		Name: "applyFailed",
diff --git a/exp/addons/internal/controllers/clusterresourceset_controller.go b/exp/addons/internal/controllers/clusterresourceset_controller.go
index 513609224..2d3cd72a1 100644
--- a/exp/addons/internal/controllers/clusterresourceset_controller.go
+++ b/exp/addons/internal/controllers/clusterresourceset_controller.go
@@ -18,9 +18,7 @@ package controllers
 
 import (
 	"context"
-	"encoding/base64"
 	"fmt"
-	"sort"
 	"time"
 
 	"github.com/pkg/errors"
@@ -51,10 +49,8 @@ import (
 	"sigs.k8s.io/cluster-api/util/predicates"
 )
 
-var (
-	// ErrSecretTypeNotSupported signals that a Secret is not supported.
-	ErrSecretTypeNotSupported = errors.New("unsupported secret type")
-)
+// ErrSecretTypeNotSupported signals that a Secret is not supported.
+var ErrSecretTypeNotSupported = errors.New("unsupported secret type")
 
 // +kubebuilder:rbac:groups=core,resources=secrets,verbs=get;list;watch;patch
 // +kubebuilder:rbac:groups=core,resources=configmaps,verbs=get;list;watch;patch
@@ -82,7 +78,7 @@ func (r *ClusterResourceSetReconciler) SetupWithManager(ctx context.Context, mgr
 			handler.EnqueueRequestsFromMapFunc(r.resourceToClusterResourceSet),
 			builder.OnlyMetadata,
 			builder.WithPredicates(
-				resourcepredicates.ResourceCreate(ctrl.LoggerFrom(ctx)),
+				resourcepredicates.ResourceCreateOrUpdate(ctrl.LoggerFrom(ctx)),
 			),
 		).
 		Watches(
@@ -90,13 +86,12 @@ func (r *ClusterResourceSetReconciler) SetupWithManager(ctx context.Context, mgr
 			handler.EnqueueRequestsFromMapFunc(r.resourceToClusterResourceSet),
 			builder.OnlyMetadata,
 			builder.WithPredicates(
-				resourcepredicates.ResourceCreate(ctrl.LoggerFrom(ctx)),
+				resourcepredicates.ResourceCreateOrUpdate(ctrl.LoggerFrom(ctx)),
 			),
 		).
 		WithOptions(options).
 		WithEventFilter(predicates.ResourceNotPausedAndHasFilterLabel(ctrl.LoggerFrom(ctx), r.WatchFilterValue)).
 		Complete(r)
-
 	if err != nil {
 		return errors.Wrap(err, "failed setting up with a controller manager")
 	}
@@ -241,6 +236,8 @@ func (r *ClusterResourceSetReconciler) getClustersByClusterResourceSetSelector(c
 // cluster's ClusterResourceSetBinding.
 // In ApplyOnce strategy, resources are applied only once to a particular cluster. ClusterResourceSetBinding is used to check if a resource is applied before.
 // It applies resources best effort and continue on scenarios like: unsupported resource types, failure during creation, missing resources.
+// In Reconcile strategy, resources are re-applied to a particular cluster when their definition changes. The hash in ClusterResourceSetBinding is used to check
+// if a resource has changed or not.
 // TODO: If a resource already exists in the cluster but not applied by ClusterResourceSet, the resource will be updated ?
 func (r *ClusterResourceSetReconciler) ApplyClusterResourceSet(ctx context.Context, cluster *clusterv1.Cluster, clusterResourceSet *addonsv1.ClusterResourceSet) error {
 	log := ctrl.LoggerFrom(ctx, "Cluster", klog.KObj(cluster))
@@ -301,8 +298,8 @@ func (r *ClusterResourceSetReconciler) ApplyClusterResourceSet(ctx context.Conte
 			errList = append(errList, err)
 		}
 
-		// If resource is already applied successfully and clusterResourceSet mode is "ApplyOnce", continue. (No need to check hash changes here)
-		if resourceSetBinding.IsApplied(resource) {
+		resourceScope, err := reconcileScopeForResource(clusterResourceSet, resource, resourceSetBinding, unstructuredObj)
+		if err == nil && !resourceScope.needsApply() {
 			continue
 		}
 
@@ -314,54 +311,25 @@ func (r *ClusterResourceSetReconciler) ApplyClusterResourceSet(ctx context.Conte
 			Applied:         false,
 			LastAppliedTime: &metav1.Time{Time: time.Now().UTC()},
 		})
-		// Since maps are not ordered, we need to order them to get the same hash at each reconcile.
-		keys := make([]string, 0)
-		data, ok := unstructuredObj.UnstructuredContent()["data"]
-		if !ok {
-			errList = append(errList, errors.New("failed to get data field from the resource"))
-			continue
-		}
-
-		unstructuredData := data.(map[string]interface{})
-		for key := range unstructuredData {
-			keys = append(keys, key)
-		}
-		sort.Strings(keys)
-
-		dataList := make([][]byte, 0)
-		for _, key := range keys {
-			val, ok, err := unstructured.NestedString(unstructuredData, key)
-			if !ok || err != nil {
-				errList = append(errList, errors.New("failed to get value field from the resource"))
-				continue
-			}
 
-			byteArr := []byte(val)
-			// If the resource is a Secret, data needs to be decoded.
-			if unstructuredObj.GetKind() == string(addonsv1.SecretClusterResourceSetResourceKind) {
-				byteArr, _ = base64.StdEncoding.DecodeString(val)
-			}
-
-			dataList = append(dataList, byteArr)
+		if err != nil {
+			errList = append(errList, err)
+			continue
 		}
 
 		// Apply all values in the key-value pair of the resource to the cluster.
 		// As there can be multiple key-value pairs in a resource, each value may have multiple objects in it.
 		isSuccessful := true
-		for i := range dataList {
-			data := dataList[i]
-
-			if err := apply(ctx, remoteClient, data); err != nil {
-				isSuccessful = false
-				log.Error(err, "failed to apply ClusterResourceSet resource", "Resource kind", resource.Kind, "Resource name", resource.Name)
-				conditions.MarkFalse(clusterResourceSet, addonsv1.ResourcesAppliedCondition, addonsv1.ApplyFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
-				errList = append(errList, err)
-			}
+		if err := resourceScope.apply(ctx, remoteClient); err != nil {
+			isSuccessful = false
+			log.Error(err, "failed to apply ClusterResourceSet resource", "Resource kind", resource.Kind, "Resource name", resource.Name)
+			conditions.MarkFalse(clusterResourceSet, addonsv1.ResourcesAppliedCondition, addonsv1.ApplyFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
+			errList = append(errList, err)
 		}
 
 		resourceSetBinding.SetBinding(addonsv1.ResourceBinding{
 			ResourceRef:     resource,
-			Hash:            computeHash(dataList),
+			Hash:            resourceScope.hash(),
 			Applied:         isSuccessful,
 			LastAppliedTime: &metav1.Time{Time: time.Now().UTC()},
 		})
diff --git a/exp/addons/internal/controllers/clusterresourceset_controller_test.go b/exp/addons/internal/controllers/clusterresourceset_controller_test.go
index 3a14392ae..c50f9c9cf 100644
--- a/exp/addons/internal/controllers/clusterresourceset_controller_test.go
+++ b/exp/addons/internal/controllers/clusterresourceset_controller_test.go
@@ -18,6 +18,7 @@ package controllers
 
 import (
 	"fmt"
+	"reflect"
 	"testing"
 	"time"
 
@@ -27,9 +28,11 @@ import (
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"sigs.k8s.io/controller-runtime/pkg/client"
+	"sigs.k8s.io/yaml"
 
 	clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
 	addonsv1 "sigs.k8s.io/cluster-api/exp/addons/api/v1beta1"
+	"sigs.k8s.io/cluster-api/internal/test/envtest"
 	"sigs.k8s.io/cluster-api/util"
 )
 
@@ -39,13 +42,16 @@ const (
 
 func TestClusterResourceSetReconciler(t *testing.T) {
 	var (
-		clusterResourceSetName string
-		testCluster            *clusterv1.Cluster
-		clusterName            string
-		labels                 map[string]string
-		configmapName          = "test-configmap"
-		secretName             = "test-secret"
-		namespacePrefix        = "test-cluster-resource-set"
+		clusterResourceSetName      string
+		testCluster                 *clusterv1.Cluster
+		clusterName                 string
+		labels                      map[string]string
+		configmapName               = "test-configmap"
+		secretName                  = "test-secret"
+		namespacePrefix             = "test-cluster-resource-set"
+		resourceConfigMap1Name      = "resource-configmap"
+		resourceConfigMap2Name      = "resource-configmap-2"
+		resourceConfigMapsNamespace = "default"
 	)
 
 	setup := func(t *testing.T, g *WithT) *corev1.Namespace {
@@ -64,19 +70,29 @@ func TestClusterResourceSetReconciler(t *testing.T) {
 		g.Expect(env.Create(ctx, testCluster)).To(Succeed())
 		t.Log("Creating the remote Cluster kubeconfig")
 		g.Expect(env.CreateKubeconfigSecret(ctx, testCluster)).To(Succeed())
+
+		resourceConfigMap1Content := fmt.Sprintf(`metadata:
+ name: %s
+ namespace: %s
+kind: ConfigMap
+apiVersion: v1`, resourceConfigMap1Name, resourceConfigMapsNamespace)
+
 		testConfigmap := &corev1.ConfigMap{
 			ObjectMeta: metav1.ObjectMeta{
 				Name:      configmapName,
 				Namespace: ns.Name,
 			},
 			Data: map[string]string{
-				"cm": `metadata:
- name: resource-configmap
- namespace: default
-kind: ConfigMap
-apiVersion: v1`,
+				"cm": resourceConfigMap1Content,
 			},
 		}
+
+		resourceConfigMap2Content := fmt.Sprintf(`metadata:
+kind: ConfigMap
+apiVersion: v1
+metadata:
+ name: %s
+ namespace: %s`, resourceConfigMap2Name, resourceConfigMapsNamespace)
 		testSecret := &corev1.Secret{
 			ObjectMeta: metav1.ObjectMeta{
 				Name:      secretName,
@@ -84,12 +100,7 @@ apiVersion: v1`,
 			},
 			Type: "addons.cluster.x-k8s.io/resource-set",
 			StringData: map[string]string{
-				"cm": `metadata:
-kind: ConfigMap
-apiVersion: v1
-metadata:
- name: resource-configmap
- namespace: default`,
+				"cm": resourceConfigMap2Content,
 			},
 		}
 		t.Log("Creating a Secret and a ConfigMap with ConfigMap in their data field")
@@ -141,7 +152,32 @@ metadata:
 			Name:      secretName,
 			Namespace: ns.Name,
 		}})).To(Succeed())
+
+		cm1 := &corev1.ConfigMap{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      resourceConfigMap1Name,
+				Namespace: resourceConfigMapsNamespace,
+			},
+		}
+		if err = env.Get(ctx, client.ObjectKeyFromObject(cm1), cm1); err == nil {
+			g.Expect(env.Delete(ctx, cm1)).To(Succeed())
+		}
+		cm2 := &corev1.ConfigMap{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      resourceConfigMap2Name,
+				Namespace: resourceConfigMapsNamespace,
+			},
+		}
+		if err = env.Get(ctx, client.ObjectKeyFromObject(cm2), cm2); err == nil {
+			g.Expect(env.Delete(ctx, cm2)).To(Succeed())
+		}
+
 		g.Expect(env.Delete(ctx, ns)).To(Succeed())
+
+		clusterKey := client.ObjectKey{Namespace: testCluster.Namespace, Name: testCluster.Name}
+		if err = env.Get(ctx, clusterKey, testCluster); err == nil {
+			g.Expect(env.Delete(ctx, testCluster)).To(Succeed())
+		}
 	}
 
 	t.Run("Should reconcile a ClusterResourceSet with multiple resources when a cluster with matching label exists", func(t *testing.T) {
@@ -170,35 +206,7 @@ metadata:
 		g.Expect(env.Create(ctx, clusterResourceSetInstance)).To(Succeed())
 
 		t.Log("Verifying ClusterResourceSetBinding is created with cluster owner reference")
-		g.Eventually(func() bool {
-			binding := &addonsv1.ClusterResourceSetBinding{}
-			clusterResourceSetBindingKey := client.ObjectKey{
-				Namespace: testCluster.Namespace,
-				Name:      testCluster.Name,
-			}
-			err := env.Get(ctx, clusterResourceSetBindingKey, binding)
-			if err != nil {
-				return false
-			}
-
-			if len(binding.Spec.Bindings) != 1 {
-				return false
-			}
-			if len(binding.Spec.Bindings[0].Resources) != 2 {
-				return false
-			}
-
-			if !binding.Spec.Bindings[0].Resources[0].Applied || !binding.Spec.Bindings[0].Resources[1].Applied {
-				return false
-			}
-
-			return util.HasOwnerRef(binding.GetOwnerReferences(), metav1.OwnerReference{
-				APIVersion: clusterv1.GroupVersion.String(),
-				Kind:       "Cluster",
-				Name:       testCluster.Name,
-				UID:        testCluster.UID,
-			})
-		}, timeout).Should(BeTrue())
+		g.Eventually(clusterResourceSetBindingReady(env, testCluster), timeout).Should(BeTrue())
 		t.Log("Deleting the Cluster")
 		g.Expect(env.Delete(ctx, testCluster)).To(Succeed())
 	})
@@ -588,4 +596,193 @@ metadata:
 			return false
 		}, timeout).Should(BeTrue())
 	})
+
+	t.Run("Should reconcile a ClusterResourceSet with Reconcile strategy after the resources have already been created", func(t *testing.T) {
+		g := NewWithT(t)
+		ns := setup(t, g)
+		defer teardown(t, g, ns)
+
+		t.Log("Updating the cluster with labels")
+		testCluster.SetLabels(labels)
+		g.Expect(env.Update(ctx, testCluster)).To(Succeed())
+
+		t.Log("Creating a ClusterResourceSet instance that has same labels as selector")
+		clusterResourceSet := &addonsv1.ClusterResourceSet{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      clusterResourceSetName,
+				Namespace: ns.Name,
+			},
+			Spec: addonsv1.ClusterResourceSetSpec{
+				Strategy: string(addonsv1.ClusterResourceSetStrategyReconcile),
+				ClusterSelector: metav1.LabelSelector{
+					MatchLabels: labels,
+				},
+				Resources: []addonsv1.ResourceRef{{Name: configmapName, Kind: "ConfigMap"}, {Name: secretName, Kind: "Secret"}},
+			},
+		}
+
+		g.Expect(env.Create(ctx, clusterResourceSet)).To(Succeed())
+
+		t.Log("Verifying ClusterResourceSetBinding is created with cluster owner reference")
+		clusterResourceSetBindingKey := client.ObjectKey{
+			Namespace: testCluster.Namespace,
+			Name:      testCluster.Name,
+		}
+		g.Eventually(clusterResourceSetBindingReady(env, testCluster), timeout).Should(BeTrue())
+
+		binding := &addonsv1.ClusterResourceSetBinding{}
+		err := env.Get(ctx, clusterResourceSetBindingKey, binding)
+		g.Expect(err).NotTo(HaveOccurred())
+		resourceHashes := map[string]string{}
+		for _, r := range binding.Spec.Bindings[0].Resources {
+			resourceHashes[r.Name] = r.Hash
+		}
+
+		t.Log("Verifying resource ConfigMap 1 has been created")
+		resourceConfigMap1Key := client.ObjectKey{
+			Namespace: resourceConfigMapsNamespace,
+			Name:      resourceConfigMap1Name,
+		}
+		g.Eventually(func() error {
+			cm := &corev1.ConfigMap{}
+			return env.Get(ctx, resourceConfigMap1Key, cm)
+		}, timeout).Should(Succeed())
+
+		t.Log("Verifying resource ConfigMap 2 has been created")
+		resourceConfigMap2Key := client.ObjectKey{
+			Namespace: resourceConfigMapsNamespace,
+			Name:      resourceConfigMap2Name,
+		}
+		g.Eventually(func() error {
+			cm := &corev1.ConfigMap{}
+			return env.Get(ctx, resourceConfigMap2Key, cm)
+		}, timeout).Should(Succeed())
+
+		resourceConfigMap1 := configMap(
+			resourceConfigMap1Name,
+			resourceConfigMapsNamespace,
+			map[string]string{
+				"my_new_config": "some_value",
+			},
+		)
+
+		resourceConfigMap1Content, err := yaml.Marshal(resourceConfigMap1)
+		g.Expect(err).NotTo(HaveOccurred())
+
+		testConfigmap := configMap(
+			configmapName,
+			ns.Name,
+			map[string]string{
+				"cm": string(resourceConfigMap1Content),
+			},
+		)
+
+		resourceConfigMap2 := configMap(
+			resourceConfigMap2Name,
+			resourceConfigMapsNamespace,
+			map[string]string{
+				"my_new_secret_config": "some_secret_value",
+			},
+		)
+
+		resourceConfigMap2Content, err := yaml.Marshal(resourceConfigMap2)
+		g.Expect(err).NotTo(HaveOccurred())
+
+		testSecret := &corev1.Secret{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      secretName,
+				Namespace: ns.Name,
+			},
+			Type: "addons.cluster.x-k8s.io/resource-set",
+			StringData: map[string]string{
+				"cm": string(resourceConfigMap2Content),
+			},
+		}
+		t.Log("Updating the Secret and a ConfigMap with updated ConfigMaps in their data field")
+		g.Expect(env.Update(ctx, testConfigmap)).To(Succeed())
+		g.Expect(env.Update(ctx, testSecret)).To(Succeed())
+
+		t.Log("Verifying ClusterResourceSetBinding has been updated with new hashes")
+		g.Eventually(func() error {
+			binding := &addonsv1.ClusterResourceSetBinding{}
+			if err := env.Get(ctx, clusterResourceSetBindingKey, binding); err != nil {
+				return err
+			}
+
+			for _, r := range binding.Spec.Bindings[0].Resources {
+				if resourceHashes[r.Name] == r.Hash {
+					return errors.Errorf("resource binding for %s hasn't been updated with new hash", r.Name)
+				}
+			}
+
+			return nil
+		}, timeout).Should(Succeed())
+
+		t.Log("Checking resource ConfigMap 1 has been updated")
+		g.Eventually(configMapHasBeenUpdated(env, resourceConfigMap1Key, resourceConfigMap1), timeout).Should(Succeed())
+
+		t.Log("Checking resource ConfigMap 2 has been updated")
+		g.Eventually(configMapHasBeenUpdated(env, resourceConfigMap2Key, resourceConfigMap2), timeout).Should(Succeed())
+	})
+}
+
+func clusterResourceSetBindingReady(env *envtest.Environment, cluster *clusterv1.Cluster) func() bool {
+	return func() bool {
+		clusterResourceSetBindingKey := client.ObjectKey{
+			Namespace: cluster.Namespace,
+			Name:      cluster.Name,
+		}
+		binding := &addonsv1.ClusterResourceSetBinding{}
+		err := env.Get(ctx, clusterResourceSetBindingKey, binding)
+		if err != nil {
+			return false
+		}
+
+		if len(binding.Spec.Bindings) != 1 {
+			return false
+		}
+		if len(binding.Spec.Bindings[0].Resources) != 2 {
+			return false
+		}
+
+		if !binding.Spec.Bindings[0].Resources[0].Applied || !binding.Spec.Bindings[0].Resources[1].Applied {
+			return false
+		}
+
+		return util.HasOwnerRef(binding.GetOwnerReferences(), metav1.OwnerReference{
+			APIVersion: clusterv1.GroupVersion.String(),
+			Kind:       "Cluster",
+			Name:       cluster.Name,
+			UID:        cluster.UID,
+		})
+	}
+}
+
+func configMapHasBeenUpdated(env *envtest.Environment, key client.ObjectKey, newState *corev1.ConfigMap) func() error {
+	return func() error {
+		cm := &corev1.ConfigMap{}
+		if err := env.Get(ctx, key, cm); err != nil {
+			return err
+		}
+
+		if !reflect.DeepEqual(cm.Data, newState.Data) {
+			return errors.Errorf("configMap %s hasn't been updated yet", key.Name)
+		}
+
+		return nil
+	}
+}
+
+func configMap(name, namespace string, data map[string]string) *corev1.ConfigMap {
+	return &corev1.ConfigMap{
+		TypeMeta: metav1.TypeMeta{
+			APIVersion: "v1",
+			Kind:       "ConfigMap",
+		},
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      name,
+			Namespace: namespace,
+		},
+		Data: data,
+	}
 }
diff --git a/exp/addons/internal/controllers/clusterresourceset_helpers.go b/exp/addons/internal/controllers/clusterresourceset_helpers.go
index d077816d0..c0b8fa1a7 100644
--- a/exp/addons/internal/controllers/clusterresourceset_helpers.go
+++ b/exp/addons/internal/controllers/clusterresourceset_helpers.go
@@ -21,8 +21,10 @@ import (
 	"bytes"
 	"context"
 	"crypto/sha256"
+	"encoding/base64"
 	"encoding/json"
 	"fmt"
+	"sort"
 	"unicode"
 
 	"github.com/pkg/errors"
@@ -31,7 +33,7 @@ import (
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
 	"k8s.io/apimachinery/pkg/types"
-	kerrors "k8s.io/apimachinery/pkg/util/errors"
+	"k8s.io/klog/v2"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 
 	clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
@@ -43,6 +45,42 @@ import (
 
 var jsonListPrefix = []byte("[")
 
+// objsFromYamlData parses a collection of yaml documents into Unstructured objects.
+// The returned objects are sorted for creation priority within the objects defined
+// in the same document. The flattening of the documents preserves the original order.
+func objsFromYamlData(yamlDocs [][]byte) ([]unstructured.Unstructured, error) {
+	allObjs := []unstructured.Unstructured{}
+	for _, data := range yamlDocs {
+		isJSONList, err := isJSONList(data)
+		if err != nil {
+			return nil, err
+		}
+		objs := []unstructured.Unstructured{}
+		// If it is a json list, convert each list element to an unstructured object.
+		if isJSONList {
+			var results []map[string]interface{}
+			// Unmarshal the JSON to the interface.
+			if err = json.Unmarshal(data, &results); err == nil {
+				for i := range results {
+					var u unstructured.Unstructured
+					u.SetUnstructuredContent(results[i])
+					objs = append(objs, u)
+				}
+			}
+		} else {
+			// If it is not a json list, data is either json or yaml format.
+			objs, err = utilyaml.ToUnstructured(data)
+			if err != nil {
+				return nil, errors.Wrapf(err, "failed converting data to unstructured objects")
+			}
+		}
+
+		allObjs = append(allObjs, utilresource.SortForCreate(objs)...)
+	}
+
+	return allObjs, nil
+}
+
 // isJSONList returns whether the data is in JSON list format.
 func isJSONList(data []byte) (bool, error) {
 	const peekSize = 32
@@ -55,56 +93,16 @@ func isJSONList(data []byte) (bool, error) {
 	return bytes.HasPrefix(trim, jsonListPrefix), nil
 }
 
-func apply(ctx context.Context, c client.Client, data []byte) error {
-	isJSONList, err := isJSONList(data)
-	if err != nil {
-		return err
-	}
-	objs := []unstructured.Unstructured{}
-	// If it is a json list, convert each list element to an unstructured object.
-	if isJSONList {
-		var results []map[string]interface{}
-		// Unmarshal the JSON to the interface.
-		if err = json.Unmarshal(data, &results); err == nil {
-			for i := range results {
-				var u unstructured.Unstructured
-				u.SetUnstructuredContent(results[i])
-				objs = append(objs, u)
-			}
-		}
-	} else {
-		// If it is not a json list, data is either json or yaml format.
-		objs, err = utilyaml.ToUnstructured(data)
-		if err != nil {
-			return errors.Wrapf(err, "failed converting data to unstructured objects")
-		}
-	}
-
-	errList := []error{}
-	sortedObjs := utilresource.SortForCreate(objs)
-	for i := range sortedObjs {
-		if err := applyUnstructured(ctx, c, &sortedObjs[i]); err != nil {
-			errList = append(errList, err)
-		}
-	}
-	return kerrors.NewAggregate(errList)
-}
-
-func applyUnstructured(ctx context.Context, c client.Client, obj *unstructured.Unstructured) error {
-	// Create the object on the API server.
-	// TODO: Errors are only logged. If needed, exponential backoff or requeuing could be used here for remedying connection glitches etc.
+func createUnstructured(ctx context.Context, c client.Client, obj *unstructured.Unstructured) error {
 	if err := c.Create(ctx, obj); err != nil {
-		// The create call is idempotent, so if the object already exists
-		// then do not consider it to be an error.
-		if !apierrors.IsAlreadyExists(err) {
-			return errors.Wrapf(
-				err,
-				"failed to create object %s %s/%s",
-				obj.GroupVersionKind(),
-				obj.GetNamespace(),
-				obj.GetName())
-		}
+		return errors.Wrapf(
+			err,
+			"creating object %s %s",
+			obj.GroupVersionKind(),
+			klog.KObj(obj),
+		)
 	}
+
 	return nil
 }
 
@@ -196,3 +194,40 @@ func computeHash(dataArr [][]byte) string {
 	}
 	return fmt.Sprintf("sha256:%x", hash.Sum(nil))
 }
+
+// normalizeData reads content of the resource (configmap or secret) and returns
+// them serialized with constant order. Secret's data is base64 decoded.
+// This is useful to achieve consistent data  between runs, since the content
+// of the data field is a mapp and its order is non deterministic.
+func normalizeData(resource *unstructured.Unstructured) ([][]byte, error) {
+	// Since maps are not ordered, we need to order them to get the same hash at each reconcile.
+	keys := make([]string, 0)
+	data, ok := resource.UnstructuredContent()["data"]
+	if !ok {
+		return nil, errors.New("failed to get data field from the resource")
+	}
+
+	unstructuredData := data.(map[string]interface{})
+	for key := range unstructuredData {
+		keys = append(keys, key)
+	}
+	sort.Strings(keys)
+
+	dataList := make([][]byte, 0)
+	for _, key := range keys {
+		val, ok, err := unstructured.NestedString(unstructuredData, key)
+		if !ok || err != nil {
+			return nil, errors.New("failed to get value field from the resource")
+		}
+
+		byteArr := []byte(val)
+		// If the resource is a Secret, data needs to be decoded.
+		if resource.GetKind() == string(addonsv1.SecretClusterResourceSetResourceKind) {
+			byteArr, _ = base64.StdEncoding.DecodeString(val)
+		}
+
+		dataList = append(dataList, byteArr)
+	}
+
+	return dataList, nil
+}
diff --git a/exp/addons/internal/controllers/clusterresourceset_scope.go b/exp/addons/internal/controllers/clusterresourceset_scope.go
new file mode 100644
index 000000000..e4af7ff3d
--- /dev/null
+++ b/exp/addons/internal/controllers/clusterresourceset_scope.go
@@ -0,0 +1,185 @@
+/*
+Copyright 2022 The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package controllers
+
+import (
+	"context"
+
+	"github.com/pkg/errors"
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	kerrors "k8s.io/apimachinery/pkg/util/errors"
+	"k8s.io/klog/v2"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+
+	addonsv1 "sigs.k8s.io/cluster-api/exp/addons/api/v1beta1"
+)
+
+// resourceReconcileScope contains the scope for a CRS's resource
+// reconciliation request.
+type resourceReconcileScope interface {
+	// needsApply determines if a resource needs to be applied to the target cluster
+	// based on the strategy.
+	needsApply() bool
+	// apply reconciles all objects defined by the resource following the proper strategy for the CRS.
+	apply(ctx context.Context, c client.Client) error
+	// hash returns a computed hash of the defined objects in the resource. It is consistent
+	// between runs.
+	hash() string
+}
+
+func reconcileScopeForResource(
+	crs *addonsv1.ClusterResourceSet,
+	resourceRef addonsv1.ResourceRef,
+	resourceSetBinding *addonsv1.ResourceSetBinding,
+	resource *unstructured.Unstructured,
+) (resourceReconcileScope, error) {
+	normalizedData, err := normalizeData(resource)
+	if err != nil {
+		return nil, err
+	}
+
+	objs, err := objsFromYamlData(normalizedData)
+	if err != nil {
+		return nil, err
+	}
+
+	return newResourceReconcileScope(crs, resourceRef, resourceSetBinding, normalizedData, objs), nil
+}
+
+func newResourceReconcileScope(
+	clusterResourceSet *addonsv1.ClusterResourceSet,
+	resourceRef addonsv1.ResourceRef,
+	resourceSetBinding *addonsv1.ResourceSetBinding,
+	normalizedData [][]byte,
+	objs []unstructured.Unstructured,
+) resourceReconcileScope {
+	base := baseResourceReconcileScope{
+		clusterResourceSet: clusterResourceSet,
+		resourceRef:        resourceRef,
+		resourceSetBinding: resourceSetBinding,
+		data:               normalizedData,
+		normalizedObjs:     objs,
+		computedHash:       computeHash(normalizedData),
+	}
+
+	switch addonsv1.ClusterResourceSetStrategy(clusterResourceSet.Spec.Strategy) {
+	case addonsv1.ClusterResourceSetStrategyApplyOnce:
+		return &reconcileApplyOnceScope{base}
+	case addonsv1.ClusterResourceSetStrategyReconcile:
+		return &reconcileStrategyScope{base}
+	default:
+		return nil
+	}
+}
+
+type baseResourceReconcileScope struct {
+	clusterResourceSet *addonsv1.ClusterResourceSet
+	resourceRef        addonsv1.ResourceRef
+	resourceSetBinding *addonsv1.ResourceSetBinding
+	normalizedObjs     []unstructured.Unstructured
+	data               [][]byte
+	computedHash       string
+}
+
+func (b baseResourceReconcileScope) objs() []unstructured.Unstructured {
+	return b.normalizedObjs
+}
+
+func (b baseResourceReconcileScope) hash() string {
+	return b.computedHash
+}
+
+type reconcileStrategyScope struct {
+	baseResourceReconcileScope
+}
+
+func (r *reconcileStrategyScope) needsApply() bool {
+	resourceBinding := r.resourceSetBinding.GetResource(r.resourceRef)
+
+	return resourceBinding == nil || !resourceBinding.Applied || resourceBinding.Hash != r.computedHash
+}
+
+func (r *reconcileStrategyScope) apply(ctx context.Context, c client.Client) error {
+	return apply(ctx, c, r.applyObj, r.objs())
+}
+
+func (r *reconcileStrategyScope) applyObj(ctx context.Context, c client.Client, obj *unstructured.Unstructured) error {
+	currentObj := &unstructured.Unstructured{}
+	currentObj.SetAPIVersion(obj.GetAPIVersion())
+	currentObj.SetKind(obj.GetKind())
+	err := c.Get(ctx, client.ObjectKeyFromObject(obj), currentObj)
+	if apierrors.IsNotFound(err) {
+		return createUnstructured(ctx, c, obj)
+	}
+	if err != nil {
+		return errors.Wrapf(
+			err,
+			"reading object %s %s",
+			obj.GroupVersionKind(),
+			klog.KObj(obj),
+		)
+	}
+
+	patch := client.MergeFrom(currentObj.DeepCopy())
+	obj.SetResourceVersion(currentObj.GetResourceVersion())
+	if err = c.Patch(ctx, obj, patch); err != nil {
+		return errors.Wrapf(
+			err,
+			"patching object %s %s/%s",
+			obj.GroupVersionKind(),
+			obj.GetNamespace(),
+			obj.GetName(),
+		)
+	}
+
+	return nil
+}
+
+type reconcileApplyOnceScope struct {
+	baseResourceReconcileScope
+}
+
+func (r *reconcileApplyOnceScope) needsApply() bool {
+	return !r.resourceSetBinding.IsApplied(r.resourceRef)
+}
+
+func (r *reconcileApplyOnceScope) apply(ctx context.Context, c client.Client) error {
+	return apply(ctx, c, r.applyObj, r.objs())
+}
+
+func (r *reconcileApplyOnceScope) applyObj(ctx context.Context, c client.Client, obj *unstructured.Unstructured) error {
+	// The create call is idempotent, so if the object already exists
+	// then do not consider it to be an error.
+	if err := createUnstructured(ctx, c, obj); !apierrors.IsAlreadyExists(err) {
+		return err
+	}
+	return nil
+}
+
+type applyObj func(ctx context.Context, c client.Client, obj *unstructured.Unstructured) error
+
+// apply reconciles unstructured objects using applyObj and aggreates the error if present.
+func apply(ctx context.Context, c client.Client, applyObj applyObj, objs []unstructured.Unstructured) error {
+	errList := []error{}
+	for i := range objs {
+		if err := applyObj(ctx, c, &objs[i]); err != nil {
+			errList = append(errList, err)
+		}
+	}
+	return kerrors.NewAggregate(errList)
+}
diff --git a/exp/addons/internal/controllers/clusterresourceset_scope_test.go b/exp/addons/internal/controllers/clusterresourceset_scope_test.go
new file mode 100644
index 000000000..624798294
--- /dev/null
+++ b/exp/addons/internal/controllers/clusterresourceset_scope_test.go
@@ -0,0 +1,251 @@
+/*
+Copyright 2022 The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package controllers
+
+import (
+	"context"
+	"testing"
+
+	. "github.com/onsi/gomega"
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+	"sigs.k8s.io/controller-runtime/pkg/client/fake"
+
+	addonsv1 "sigs.k8s.io/cluster-api/exp/addons/api/v1beta1"
+)
+
+func TestReconcileStrategyScopeNeedsApply(t *testing.T) {
+	tests := []struct {
+		name  string
+		scope *reconcileStrategyScope
+		want  bool
+	}{
+		{
+			name: "no ResourceBinding",
+			scope: &reconcileStrategyScope{
+				baseResourceReconcileScope: baseResourceReconcileScope{
+					resourceSetBinding: &addonsv1.ResourceSetBinding{},
+					resourceRef: addonsv1.ResourceRef{
+						Name: "cp",
+						Kind: "ConfigMap",
+					},
+				},
+			},
+			want: true,
+		},
+		{
+			name: "not applied ResourceBinding",
+			scope: &reconcileStrategyScope{
+				baseResourceReconcileScope: baseResourceReconcileScope{
+					resourceSetBinding: &addonsv1.ResourceSetBinding{
+						Resources: []addonsv1.ResourceBinding{
+							{
+								ResourceRef: addonsv1.ResourceRef{
+									Name: "cp",
+									Kind: "ConfigMap",
+								},
+								Applied: false,
+							},
+						},
+					},
+					resourceRef: addonsv1.ResourceRef{
+						Name: "cp",
+						Kind: "ConfigMap",
+					},
+				},
+			},
+			want: true,
+		},
+		{
+			name: "applied ResourceBinding and different hash",
+			scope: &reconcileStrategyScope{
+				baseResourceReconcileScope: baseResourceReconcileScope{
+					resourceSetBinding: &addonsv1.ResourceSetBinding{
+						Resources: []addonsv1.ResourceBinding{
+							{
+								ResourceRef: addonsv1.ResourceRef{
+									Name: "cp",
+									Kind: "ConfigMap",
+								},
+								Applied: true,
+								Hash:    "111",
+							},
+						},
+					},
+					resourceRef: addonsv1.ResourceRef{
+						Name: "cp",
+						Kind: "ConfigMap",
+					},
+					computedHash: "222",
+				},
+			},
+			want: true,
+		},
+		{
+			name: "applied ResourceBinding and same hash",
+			scope: &reconcileStrategyScope{
+				baseResourceReconcileScope: baseResourceReconcileScope{
+					resourceSetBinding: &addonsv1.ResourceSetBinding{
+						Resources: []addonsv1.ResourceBinding{
+							{
+								ResourceRef: addonsv1.ResourceRef{
+									Name: "cp",
+									Kind: "ConfigMap",
+								},
+								Applied: true,
+								Hash:    "111",
+							},
+						},
+					},
+					resourceRef: addonsv1.ResourceRef{
+						Name: "cp",
+						Kind: "ConfigMap",
+					},
+					computedHash: "111",
+				},
+			},
+			want: false,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			gs := NewWithT(t)
+			gs.Expect(tt.scope.needsApply()).To(Equal(tt.want))
+		})
+	}
+}
+
+func TestReconcileApplyOnceScopeNeedsApply(t *testing.T) {
+	tests := []struct {
+		name  string
+		scope *reconcileApplyOnceScope
+		want  bool
+	}{
+		{
+			name: "not applied ResourceBinding",
+			scope: &reconcileApplyOnceScope{
+				baseResourceReconcileScope: baseResourceReconcileScope{
+					resourceSetBinding: &addonsv1.ResourceSetBinding{
+						Resources: []addonsv1.ResourceBinding{
+							{
+								ResourceRef: addonsv1.ResourceRef{
+									Name: "cp",
+									Kind: "ConfigMap",
+								},
+								Applied: false,
+							},
+						},
+					},
+					resourceRef: addonsv1.ResourceRef{
+						Name: "cp",
+						Kind: "ConfigMap",
+					},
+				},
+			},
+			want: true,
+		},
+		{
+			name: "applied ResourceBinding",
+			scope: &reconcileApplyOnceScope{
+				baseResourceReconcileScope: baseResourceReconcileScope{
+					resourceSetBinding: &addonsv1.ResourceSetBinding{
+						Resources: []addonsv1.ResourceBinding{
+							{
+								ResourceRef: addonsv1.ResourceRef{
+									Name: "cp",
+									Kind: "ConfigMap",
+								},
+								Applied: true,
+							},
+						},
+					},
+					resourceRef: addonsv1.ResourceRef{
+						Name: "cp",
+						Kind: "ConfigMap",
+					},
+				},
+			},
+			want: false,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			gs := NewWithT(t)
+			gs.Expect(tt.scope.needsApply()).To(Equal(tt.want))
+		})
+	}
+}
+
+func TestReconcileApplyOnceScopeApplyObj(t *testing.T) {
+	tests := []struct {
+		name         string
+		existingObjs []client.Object
+		obj          *unstructured.Unstructured
+		wantErr      string
+	}{
+		{
+			name: "object doesn't exist",
+			obj: &unstructured.Unstructured{
+				Object: map[string]interface{}{
+					"apiVersion": "v1",
+					"kind":       "ConfigMap",
+					"metadata": map[string]interface{}{
+						"name":      "my-cm",
+						"namespace": "that-ns",
+					},
+				},
+			},
+		},
+		{
+			name: "object exists",
+			existingObjs: []client.Object{
+				&corev1.ConfigMap{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "my-cm",
+						Namespace: "that-ns",
+					},
+				},
+			},
+			obj: &unstructured.Unstructured{
+				Object: map[string]interface{}{
+					"apiVersion": "v1",
+					"kind":       "ConfigMap",
+					"metadata": map[string]interface{}{
+						"name":      "my-cm",
+						"namespace": "that-ns",
+					},
+				},
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			gs := NewWithT(t)
+			ctx := context.Background()
+			client := fake.NewClientBuilder().WithObjects(tt.existingObjs...).Build()
+			scope := &reconcileApplyOnceScope{}
+			err := scope.applyObj(ctx, client, tt.obj)
+			if tt.wantErr == "" {
+				gs.Expect(err).NotTo(HaveOccurred())
+			} else {
+				gs.Expect(err).To(MatchError(ContainSubstring(tt.wantErr)))
+			}
+		})
+	}
+}
diff --git a/exp/addons/internal/controllers/predicates/resource_predicates.go b/exp/addons/internal/controllers/predicates/resource_predicates.go
index 7db6a76b7..bc12a340a 100644
--- a/exp/addons/internal/controllers/predicates/resource_predicates.go
+++ b/exp/addons/internal/controllers/predicates/resource_predicates.go
@@ -23,11 +23,11 @@ import (
 	"sigs.k8s.io/controller-runtime/pkg/predicate"
 )
 
-// ResourceCreate returns a predicate that returns true for a create event.
-func ResourceCreate(_ logr.Logger) predicate.Funcs {
+// ResourceCreateOrUpdate returns a predicate that returns true for create and update events.
+func ResourceCreateOrUpdate(_ logr.Logger) predicate.Funcs {
 	return predicate.Funcs{
 		CreateFunc:  func(e event.CreateEvent) bool { return true },
-		UpdateFunc:  func(e event.UpdateEvent) bool { return false },
+		UpdateFunc:  func(e event.UpdateEvent) bool { return true },
 		DeleteFunc:  func(e event.DeleteEvent) bool { return false },
 		GenericFunc: func(e event.GenericEvent) bool { return false },
 	}
-- 
2.25.1

