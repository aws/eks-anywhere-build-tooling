From cadf7a1fc6f2ea8ac101af65dfd820010da78d1c Mon Sep 17 00:00:00 2001
From: Jun Shun Zhang <junshun@amazon.com>
Date: Wed, 18 Jan 2023 20:33:53 +0000
Subject: [PATCH] Removing azure provider from 1.21 for cve-2021-3538

---
 cluster-autoscaler/cloudprovider/azure/OWNERS |    8 -
 .../cloudprovider/azure/README.md             |  316 --
 .../cloudprovider/azure/azure_agent_pool.go   |  618 ---
 .../azure/azure_agent_pool_test.go            |  521 ---
 .../azure/azure_autodiscovery.go              |  103 -
 .../azure/azure_autodiscovery_test.go         |   77 -
 .../cloudprovider/azure/azure_cache.go        |  316 --
 .../cloudprovider/azure/azure_cache_test.go   |   72 -
 .../cloudprovider/azure/azure_client.go       |  259 --
 .../azure/azure_cloud_provider.go             |  174 -
 .../azure/azure_cloud_provider_test.go        |  183 -
 .../cloudprovider/azure/azure_config.go       |  476 --
 .../cloudprovider/azure/azure_config_test.go  |  237 -
 .../cloudprovider/azure/azure_fakes.go        |  128 -
 .../azure/azure_instance_types.go             | 3835 -----------------
 .../azure/azure_instance_types/gen.go         |  164 -
 .../azure_kubernetes_sercice_pool_test.go     |  419 --
 .../azure/azure_kubernetes_service_pool.go    |  442 --
 .../cloudprovider/azure/azure_manager.go      |  333 --
 .../cloudprovider/azure/azure_manager_test.go |  793 ----
 .../cloudprovider/azure/azure_scale_set.go    |  600 ---
 .../azure/azure_scale_set_test.go             |  577 ---
 .../cloudprovider/azure/azure_template.go     |  207 -
 .../azure/azure_template_test.go              |  113 -
 .../cloudprovider/azure/azure_util.go         |  609 ---
 .../cloudprovider/azure/azure_util_test.go    |  539 ---
 .../examples/cluster-autoscaler-aks.yaml      |  214 -
 .../cluster-autoscaler-autodiscover.yaml      |  225 -
 ...ter-autoscaler-standard-control-plane.yaml |  235 -
 .../cluster-autoscaler-standard-msi.yaml      |  226 -
 .../examples/cluster-autoscaler-standard.yaml |  228 -
 ...cluster-autoscaler-vmss-control-plane.yaml |  219 -
 .../examples/cluster-autoscaler-vmss-msi.yaml |  210 -
 .../examples/cluster-autoscaler-vmss.yaml     |  212 -
 .../cloudprovider/builder/builder_all.go      |    4 -
 .../cloudprovider/builder/builder_azure.go    |   42 -
 cluster-autoscaler/go.mod                     |    7 -
 .../mgmt/2018-07-01/storage/accounts.go       | 1157 -----
 .../mgmt/2018-07-01/storage/blobcontainers.go | 1405 ------
 .../mgmt/2018-07-01/storage/blobservices.go   |  242 --
 .../storage/mgmt/2018-07-01/storage/client.go |   52 -
 .../2018-07-01/storage/managementpolicies.go  |  322 --
 .../storage/mgmt/2018-07-01/storage/models.go | 2187 ----------
 .../mgmt/2018-07-01/storage/operations.go     |  109 -
 .../storage/mgmt/2018-07-01/storage/skus.go   |  120 -
 .../storage/mgmt/2018-07-01/storage/usages.go |  123 -
 .../mgmt/2018-07-01/storage/version.go        |   30 -
 .../mockcontainerserviceclient/doc.go         |   20 -
 .../mockcontainerserviceclient/interface.go   |  109 -
 .../mockstorageaccountclient/doc.go           |   20 -
 .../mockstorageaccountclient/interface.go     |  123 -
 cluster-autoscaler/vendor/modules.txt         |   10 -
 52 files changed, 19970 deletions(-)
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/OWNERS
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/README.md
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_agent_pool.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_agent_pool_test.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_autodiscovery.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_autodiscovery_test.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_cache.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_cache_test.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_client.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_cloud_provider.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_cloud_provider_test.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_config.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_config_test.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_fakes.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_instance_types.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_instance_types/gen.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_kubernetes_sercice_pool_test.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_kubernetes_service_pool.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_manager.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_manager_test.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_scale_set.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_scale_set_test.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_template.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_template_test.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_util.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/azure_util_test.go
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-aks.yaml
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-autodiscover.yaml
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-standard-control-plane.yaml
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-standard-msi.yaml
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-standard.yaml
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-vmss-control-plane.yaml
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-vmss-msi.yaml
 delete mode 100644 cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-vmss.yaml
 delete mode 100644 cluster-autoscaler/cloudprovider/builder/builder_azure.go
 delete mode 100644 cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/accounts.go
 delete mode 100644 cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/blobcontainers.go
 delete mode 100644 cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/blobservices.go
 delete mode 100644 cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/client.go
 delete mode 100644 cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/managementpolicies.go
 delete mode 100644 cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/models.go
 delete mode 100644 cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/operations.go
 delete mode 100644 cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/skus.go
 delete mode 100644 cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/usages.go
 delete mode 100644 cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/version.go
 delete mode 100644 cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/containerserviceclient/mockcontainerserviceclient/doc.go
 delete mode 100644 cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/containerserviceclient/mockcontainerserviceclient/interface.go
 delete mode 100644 cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient/mockstorageaccountclient/doc.go
 delete mode 100644 cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient/mockstorageaccountclient/interface.go

diff --git a/cluster-autoscaler/cloudprovider/azure/OWNERS b/cluster-autoscaler/cloudprovider/azure/OWNERS
deleted file mode 100644
index b0ed6af1e..000000000
--- a/cluster-autoscaler/cloudprovider/azure/OWNERS
+++ /dev/null
@@ -1,8 +0,0 @@
-approvers:
-- feiskyer
-- nilo19
-- marwanad
-reviewers:
-- feiskyer
-- nilo19
-- marwanad
diff --git a/cluster-autoscaler/cloudprovider/azure/README.md b/cluster-autoscaler/cloudprovider/azure/README.md
deleted file mode 100644
index bfd1e46dd..000000000
--- a/cluster-autoscaler/cloudprovider/azure/README.md
+++ /dev/null
@@ -1,316 +0,0 @@
-# Cluster Autoscaler on Azure
-
-The cluster autoscaler on Azure dynamically scales Kubernetes worker nodes. It runs as a deployment in your cluster.
-
-This README will help you get cluster autoscaler running on your Azure Kubernetes cluster.
-
-## Kubernetes Version
-
-Kubernetes v1.10.x or later is required to use cluster autoscaler on Azure. See the "[Releases][]" section in the README for more information.
-
-## CA Version
-
-Cluster autoscaler v1.2.x or later is required for Azure. See the "[Releases][]" section in the README for more information.
-
-> **_NOTE_**: In the deployment manifests referenced below, be sure to replace the `{{ ca_version }}` placeholder with an actual release, such as `v1.14.2`.
-
-## Permissions
-
-Get Azure credentials by running the following [Azure CLI][] command:
-
-```sh
-# replace <subscription-id> with yours.
-az ad sp create-for-rbac --role="Contributor" --scopes="/subscriptions/<subscription-id>" --output json
-```
-
-This will create a new [service principal][] with "Contributor" role scoped to your subscription. Save the JSON output, because it will be needed to configure the cluster autoscaler deployment in the next step.
-
-## Scaling a VMSS node group to and from 0
-
-If you are using `nodeSelector`, you need to tag the VMSS  with a node-template key `"k8s.io_cluster-autoscaler_node-template_label_"` for using labels and `"k8s.io_cluster-autoscaler_node-template_taint_"` if you are using taints.
-
-> Note that these tags use the pipe `_` character compared to a forward slash due to [Azure tag name restrictions](https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-using-tags).
-
-### Examples
-
-#### Labels
-
-To add the label of `foo=bar` to a node from a VMSS pool, you would add the following tag to the VMSS `k8s.io_cluster-autoscaler_node-template_label_foo: bar`.
-
-You can also use forward slashes in the labels by setting them as an underscore in the tag name. For example to add the label of `k8s.io/foo=bar` to a node from a VMSS pool, you would add the following tag to the VMSS `k8s.io_cluster-autoscaler_node-template_label_k8s.io_foo: bar`
-
-#### Taints
-
-To add the taint of `foo=bar:NoSchedule` to a node from a VMSS pool, you would add the following tag to the VMSS `k8s.io_cluster-autoscaler_node-template_taint_foo: bar:NoSchedule`.
-
-You can also use forward slashes in taints by setting them as an underscore in the tag name. For example to add the taint of `k8s.io/foo=bar:NoSchedule` to a node from a VMSS pool, you would add the following tag to the VMSS `k8s.io_cluster-autoscaler_node-template_taint_k8s.io_foo: bar:NoSchedule`
-
-#### Resources
-
-When scaling from an empty VM Scale Set (0 instances), Cluster Autoscaler will evaluate the provided presources (cpu, memory, ephemeral-storage) based on that VM Scale Set's backing instance type.
-This can be overridden (for instance, to account for system reserved resources) by specifying capacities with VMSS tags, formated as: `k8s.io_cluster-autoscaler_node-template_resources_<resource name>: <resource value>`. For instance:
-```
-k8s.io_cluster-autoscaler_node-template_resources_cpu: 3800m
-k8s.io_cluster-autoscaler_node-template_resources_memory: 11Gi
-```
-
-## Deployment manifests
-
-Cluster autoscaler supports four Kubernetes cluster options on Azure:
-
-- [**vmss**](#vmss-deployment): Autoscale VMSS instances by setting the Azure cloud provider's `vmType` parameter to `vmss` or to an empty string. This supports clusters deployed with [aks-engine][].
-- [**standard**](#standard-deployment): Autoscale VMAS instances by setting the Azure cloud provider's `vmType` parameter to `standard`. This supports clusters deployed with [aks-engine][].
-- [**aks**](#aks-deployment): Supports an Azure Kubernetes Service ([AKS][]) cluster.
-
-> **_NOTE_**: only the `vmss` option supports scaling down to zero nodes.
-
-> **_NOTE_**: The `subscriptionID` parameter is optional. When skipped, the subscription will be fetched from [the instance metadata](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/instance-metadata-service).
-
-### VMSS deployment
-
-Prerequisites:
-
-- Get Azure credentials from the [**Permissions**](#permissions) step above.
-- Get the name of the VM scale set associated with the cluster's node pool. You can find this in the [Azure Portal][] or with the `az vmss list` command.
-
-Make a copy of [cluster-autoscaler-vmss.yaml](examples/cluster-autoscaler-vmss.yaml). Fill in the placeholder values for the `cluster-autoscaler-azure` secret data by base64-encoding each of your Azure credential fields.
-
-- ClientID: `<base64-encoded-client-id>`
-- ClientSecret: `<base64-encoded-client-secret>`
-- ResourceGroup: `<base64-encoded-resource-group>`
-- SubscriptionID: `<base64-encoded-subscription-id>`
-- TenantID: `<base64-encoded-tenant-id>`
-
-> **_NOTE_**: Use a command such as `echo $CLIENT_ID | base64` to encode each of the fields above.
-
-In the `cluster-autoscaler` spec, find the `image:` field and replace `{{ ca_version }}` with a specific cluster autoscaler release.
-
-#### Auto-Discovery Setup
-
-To run a cluster-autoscaler which auto-discovers VMSSs with nodes use the `--node-group-auto-discovery` flag.
-For example, `--node-group-auto-discovery=label:cluster-autoscaler-enabled=true,cluster-autoscaler-name=<YOUR CLUSTER NAME>` will find the VMSSs tagged with those tags containing those values.
-
-Note that:
-
-* It is recommended to use a second tag like `cluster-autoscaler-name=<YOUR CLUSTER NAME>` when `cluster-autoscaler-enabled=true` is used across many clusters to prevent VMSSs from different clusters recognized as the node groups
-* There are no `--nodes` flags passed to cluster-autoscaler because the node groups are automatically discovered by tags
-* No min/max values are provided when using Auto-Discovery, cluster-autoscaler will detect the "min" and "max" tags on the VMSS resource in Azure, adjusting the desired number of nodes within these limits.
-
-```
-kubectl apply -f examples/cluster-autoscaler-autodiscover.yaml
-```
-
-#### Explicit setup
-
-Below that, in the `command:` section, update the `--nodes=` arguments to reference your node limits and VMSS name. For example, if node pool "k8s-nodepool-1-vmss" should scale from 1 to 10 nodes:
-
-```yaml
-        - --nodes=1:10:k8s-nodepool-1-vmss
-```
-
-or to autoscale multiple VM scale sets:
-
-```yaml
-        - --nodes=1:10:k8s-nodepool-1-vmss
-        - --nodes=1:10:k8s-nodepool-2-vmss
-```
-
-Note that it doesn't mean the number of nodes in nodepool is restricted in the
-range from 1 to 10. It means when ca is downscaling (upscaling) the nodepool,
-it will never break the limit of 1 (10). If the current node pool size is lower than the specified minimum or greater than the specified maximum when you enable autoscaling, the autoscaler waits to take effect until a new node is needed in the node pool or until a node can be safely deleted from the node pool.
-
-To allow scaling similar node pools simultaneously, or when using separate node groups per zone and to keep nodes balanced across zones, use the `--balance-similar-node-groups` flag (default false). Add it to the `command` section to enable it:
-
-```yaml
-        - --balance-similar-node-groups=true
-```
-
-See the [FAQ](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#im-running-cluster-with-nodes-in-multiple-zones-for-ha-purposes-is-that-supported-by-cluster-autoscaler) for more details.
-
-Save the updated deployment manifest, then deploy cluster-autoscaler by running:
-
-```sh
-kubectl create -f cluster-autoscaler-vmss.yaml
-```
-
-<!--TODO: Remove "previously referred to as master" references from this doc once this terminology is fully removed from k8s-->
-To run a cluster autoscaler pod on a control plane (previously referred to as master) node, the deployment should tolerate the `master` taint, and `nodeSelector` should be used to schedule pods. Use [cluster-autoscaler-vmss-control-plane.yaml](examples/cluster-autoscaler-vmss-control-plane.yaml) in this case.
-
-To run a cluster autoscaler pod with Azure managed service identity (MSI), use [cluster-autoscaler-vmss-msi.yaml](examples/cluster-autoscaler-vmss-msi.yaml) instead.
-
-#### Azure API Throttling
-Azure has hard limits on the number of read and write requests against Azure APIs *per subscription, per region*. Running lots of clusters in a single subscription, or running a single large, dynamic cluster in a subscription can produce side effects that exceed the number of calls permitted within a given time window for a particular category of requests. See the following documents for more detail on Azure API throttling in general:
-
-- https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/request-limits-and-throttling
-- https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors
-
-Given the dynamic nature of cluster autoscaler, it can be a trigger for hitting those rate limits on the subscriptions. This in turn can affect other components running in the cluster that depend on Azure APIs such as kube-controller-manager.
-
-When using K8s versions older than v1.18, we recommend using at least **v.1.17.5, v1.16.9, v1.15.12** which include various improvements on the cloud-provider side that have an impact on the number of API calls during scale down operations.
-
-As for CA versions older than 1.18, we recommend using at least **v.1.17.2, v1.16.5, v1.15.6**.
-
-In addition, cluster-autoscaler exposes a `AZURE_VMSS_CACHE_TTL` environment variable which controls the rate of `GetVMScaleSet` being made. By default, this is 15 seconds but setting this to a higher value such as 60 seconds can protect against API throttling. The caches used are proactively incremented and decremented with the scale up and down operations and this higher value doesn't have any noticeable impact on performance. **Note that the value is in seconds**
-
-| Config Name | Default | Environment Variable | Cloud Config File |
-| ----------- | ------- | -------------------- | ----------------- |
-| VmssCacheTTL | 60 | AZURE_VMSS_CACHE_TTL | vmssCacheTTL |
-
-The `AZURE_VMSS_VMS_CACHE_TTL` environment variable affects the `GetScaleSetVms` (VMSS VM List) calls rate. The default value is 300 seconds.
-A configurable jitter (`AZURE_VMSS_VMS_CACHE_JITTER` environment variable, default 0) expresses the maximum number of second that will be subtracted from that initial VMSS cache TTL after a new VMSS is discovered by the cluster-autoscaler: this can prevent a dogpile effect on clusters having many VMSS.
-
-| Config Name | Default | Environment Variable | Cloud Config File |
-| ----------- | ------- | -------------------- | ----------------- |
-| vmssVmsCacheTTL | 300 | AZURE_VMSS_VMS_CACHE_TTL | vmssVmsCacheTTL |
-| vmssVmsCacheJitter | 0 | AZURE_VMSS_VMS_CACHE_JITTER | vmssVmsCacheJitter |
-
-When using K8s 1.18 or higher, it is also recommended to configure backoff and retries on the client as described [here](#rate-limit-and-back-off-retries)
-
-### Standard deployment
-
-Prerequisites:
-
-- Get Azure credentials from the [**Permissions**](#permissions) step above.
-- Get the name of the initial Azure deployment resource for the cluster. You can find this in the [Azure Portal](https://portal.azure.com) or with the `az deployment list` command. If there are multiple deployments, get the name of the first one.
-
-Make a copy of [cluster-autoscaler-standard-control-plane.yaml](examples/cluster-autoscaler-standard-control-plane.yaml). Fill in the placeholder values for the `cluster-autoscaler-azure` secret data by base64-encoding each of your Azure credential fields.
-
-- ClientID: `<base64-encoded-client-id>`
-- ClientSecret: `<base64-encoded-client-secret>`
-- ResourceGroup: `<base64-encoded-resource-group>`
-- SubscriptionID: `<base64-encoded-subscription-id>`
-- TenantID: `<base64-encoded-tenant-id>`
-- Deployment: `<base64-encoded-azure-initial-deployment-name>`
-
-> **_NOTE_**: Use a command such as `echo $CLIENT_ID | base64` to encode each of the fields above.
-
-In the `cluster-autoscaler` spec, find the `image:` field and replace `{{ ca_version }}` with a specific cluster autoscaler release.
-
-Below that, in the `command:` section, update the `--nodes=` arguments to reference your node limits and node pool name (tips: node pool name is NOT availability set name, e.g., the corresponding node pool name of the availability set
-`agentpool1-availabilitySet-xxxxxxxx` would be `agentpool1`). For example, if node pool "k8s-nodepool-1" should scale from 1 to 10 nodes:
-
-```yaml
-        - --nodes=1:10:k8s-nodepool-1
-```
-
-or to autoscale multiple VM scale sets:
-
-```yaml
-        - --nodes=1:10:k8s-nodepool-1
-        - --nodes=1:10:k8s-nodepool-2
-```
-
-Create the Azure deploy parameters secret `cluster-autoscaler-azure-deploy-parameters` by running:
-
-```sh
-kubectl -n kube-system create secret generic cluster-autoscaler-azure-deploy-parameters --from-file=deploy-parameters=./_output/<your-output-path>/azuredeploy.parameters.json
-```
-
-Then deploy cluster-autoscaler by running:
-
-```sh
-kubectl create -f cluster-autoscaler-standard-control-plane.yaml
-```
-
-To run a cluster autoscaler pod with Azure managed service identity (MSI), use [cluster-autoscaler-standard-msi.yaml](examples/cluster-autoscaler-standard-msi.yaml) instead.
-
-> **_WARNING_**: Cluster autoscaler depends on user-provided deployment parameters to provision new nodes. After upgrading your Kubernetes cluster, cluster autoscaler must also be redeployed with new parameters to prevent provisioning nodes with an old version.
-
-### AKS deployment
-
-#### AKS + VMSS
-
-Autoscaling VM scale sets with AKS is supported for Kubernetes v1.12.4 and later. The option to enable cluster autoscaler is available in the [Azure Portal][] or with the [Azure CLI][]:
-
-```sh
-az aks create \
-  --resource-group myResourceGroup \
-  --name myAKSCluster \
-  --kubernetes-version 1.13.5 \
-  --node-count 1 \
-  --enable-vmss \
-  --enable-cluster-autoscaler \
-  --min-count 1 \
-  --max-count 3
-```
-
-#### AKS + Availability Set
-
-The CLI based deployment only support VMSS and manual deployment is needed if availability set is used.
-
-Prerequisites:
-
-- Get Azure credentials from the [**Permissions**](#permissions) step above.
-- Get the cluster name with the `az aks list` command.
-- Get the name of a node pool from the value of the label **agentpool**
-
-```sh
-kubectl get nodes --show-labels
-```
-
-Make a copy of [cluster-autoscaler-aks.yaml](examples/cluster-autoscaler-aks.yaml). Fill in the placeholder values for
-the `cluster-autoscaler-azure` secret data by base64-encoding each of your Azure credential fields.
-
-- ClientID: `<base64-encoded-client-id>`
-- ClientSecret: `<base64-encoded-client-secret>`
-- ResourceGroup: `<base64-encoded-resource-group>` (Note: ResourceGroup is case-sensitive)
-- SubscriptionID: `<base64-encoded-subscription-id>`
-- TenantID: `<base64-encoded-tenant-id>`
-- ClusterName: `<base64-encoded-clustername>`
-- NodeResourceGroup: `<base64-encoded-node-resource-group>` (Note: node resource group is not resource group and can be obtained in the corresponding label of the nodepool)
-
-> **_NOTE_**: Use a command such as `echo $CLIENT_ID | base64` to encode each of the fields above.
-
-In the `cluster-autoscaler` spec, find the `image:` field and replace `{{ ca_version }}` with a specific cluster autoscaler release.
-
-Below that, in the `command:` section, update the `--nodes=` arguments to reference your node limits and node pool name. For example, if node pool "k8s-nodepool-1" should scale from 1 to 10 nodes:
-
-```yaml
-        - --nodes=1:10:k8s-nodepool-1
-```
-
-or to autoscale multiple VM scale sets:
-
-```yaml
-        - --nodes=1:10:k8s-nodepool-1
-        - --nodes=1:10:k8s-nodepool-2
-```
-
-Then deploy cluster-autoscaler by running
-
-```sh
-kubectl create -f cluster-autoscaler-aks.yaml
-```
-
-To deploy in AKS with `Helm 3`, please refer to [helm installation tutorial][].
-
-Please see the [AKS autoscaler documentation][] for details.
-
-## Rate limit and back-off retries
-
-The new version of [Azure client][] supports rate limit and back-off retries when the cluster hits the throttling issue. These can be set by either environment variables, or cloud config file. With config file, defaults values are false or 0.
-
-| Config Name | Default | Environment Variable | Cloud Config File |
-| ----------- | ------- | -------------------- | ----------------- |
-| CloudProviderBackoff | false | ENABLE_BACKOFF | cloudProviderBackoff |
-| CloudProviderBackoffRetries | 6 | BACKOFF_RETRIES | cloudProviderBackoffRetries |
-| CloudProviderBackoffExponent | 1.5 | BACKOFF_EXPONENT | cloudProviderBackoffExponent |
-| CloudProviderBackoffDuration | 5 | BACKOFF_DURATION | cloudProviderBackoffDuration |
-| CloudProviderBackoffJitter | 1.0 | BACKOFF_JITTER | cloudProviderBackoffJitter |
-| CloudProviderRateLimit * | false | CLOUD_PROVIDER_RATE_LIMIT | cloudProviderRateLimit |
-| CloudProviderRateLimitQPS * | 1 | RATE_LIMIT_READ_QPS | cloudProviderRateLimitQPS |
-| CloudProviderRateLimitBucket * | 5 | RATE_LIMIT_READ_BUCKETS | cloudProviderRateLimitBucket |
-| CloudProviderRateLimitQPSWrite * | 1 | RATE_LIMIT_WRITE_QPS | cloudProviderRateLimitQPSWrite |
-| CloudProviderRateLimitBucketWrite * | 5 | RATE_LIMIT_WRITE_BUCKETS | cloudProviderRateLimitBucketWrite |
-
-> **_NOTE_**: * These rate limit configs can be set per-client. Customizing `QPS` and `Bucket` through environment variables per client is not supported.
-
-[AKS]: https://docs.microsoft.com/azure/aks/
-[AKS autoscaler documentation]: https://docs.microsoft.com/azure/aks/autoscaler
-[aks-engine]: https://github.com/Azure/aks-engine
-[Azure CLI]: https://docs.microsoft.com/cli/azure/install-azure-cli
-[Azure Portal]: https://portal.azure.com
-[Releases]: ../../README.md#releases
-[service principal]: https://docs.microsoft.com/azure/active-directory/develop/app-objects-and-service-principals
-[helm installation tutorial]: https://github.com/helm/charts/tree/master/stable/cluster-autoscaler#azure-aks
-[Azure client]: https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io/legacy-cloud-providers/azure/clients
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_agent_pool.go b/cluster-autoscaler/cloudprovider/azure/azure_agent_pool.go
deleted file mode 100644
index 9ce7177a9..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_agent_pool.go
+++ /dev/null
@@ -1,618 +0,0 @@
-/*
-Copyright 2017 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"fmt"
-	"math/rand"
-	"sort"
-	"strings"
-	"sync"
-	"time"
-
-	"github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2019-12-01/compute"
-	"github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2017-05-10/resources"
-	azStorage "github.com/Azure/azure-sdk-for-go/storage"
-	"github.com/Azure/go-autorest/autorest/to"
-
-	apiv1 "k8s.io/api/core/v1"
-	utilerrors "k8s.io/apimachinery/pkg/util/errors"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-	"k8s.io/autoscaler/cluster-autoscaler/config"
-	"k8s.io/autoscaler/cluster-autoscaler/config/dynamic"
-	klog "k8s.io/klog/v2"
-	schedulerframework "k8s.io/kubernetes/pkg/scheduler/framework"
-)
-
-const (
-	clusterAutoscalerDeploymentPrefix = `cluster-autoscaler-`
-	defaultMaxDeploymentsCount        = 10
-)
-
-// AgentPool implements NodeGroup interface for agent pools deployed by aks-engine.
-type AgentPool struct {
-	azureRef
-	manager *AzureManager
-
-	minSize int
-	maxSize int
-
-	template   map[string]interface{}
-	parameters map[string]interface{}
-
-	mutex       sync.Mutex
-	lastRefresh time.Time
-	curSize     int64
-}
-
-// NewAgentPool creates a new AgentPool.
-func NewAgentPool(spec *dynamic.NodeGroupSpec, az *AzureManager) (*AgentPool, error) {
-	as := &AgentPool{
-		azureRef: azureRef{
-			Name: spec.Name,
-		},
-		minSize: spec.MinSize,
-		maxSize: spec.MaxSize,
-		manager: az,
-		curSize: -1,
-	}
-
-	if err := as.initialize(); err != nil {
-		return nil, err
-	}
-
-	return as, nil
-}
-
-func (as *AgentPool) initialize() error {
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-
-	template, err := as.manager.azClient.deploymentsClient.ExportTemplate(ctx, as.manager.config.ResourceGroup, as.manager.config.Deployment)
-	if err != nil {
-		klog.Errorf("deploymentsClient.ExportTemplate(%s, %s) failed: %v", as.manager.config.ResourceGroup, as.manager.config.Deployment, err)
-		return err
-	}
-
-	as.template = template.Template.(map[string]interface{})
-	as.parameters = as.manager.config.DeploymentParameters
-	return normalizeForK8sVMASScalingUp(as.template)
-}
-
-// MinSize returns minimum size of the node group.
-func (as *AgentPool) MinSize() int {
-	return as.minSize
-}
-
-// Exist checks if the node group really exists on the cloud provider side. Allows to tell the
-// theoretical node group from the real one.
-func (as *AgentPool) Exist() bool {
-	return true
-}
-
-// Create creates the node group on the cloud provider side.
-func (as *AgentPool) Create() (cloudprovider.NodeGroup, error) {
-	return nil, cloudprovider.ErrAlreadyExist
-}
-
-// Delete deletes the node group on the cloud provider side.
-// This will be executed only for autoprovisioned node groups, once their size drops to 0.
-func (as *AgentPool) Delete() error {
-	return cloudprovider.ErrNotImplemented
-}
-
-// Autoprovisioned returns true if the node group is autoprovisioned.
-func (as *AgentPool) Autoprovisioned() bool {
-	return false
-}
-
-// GetOptions returns NodeGroupAutoscalingOptions that should be used for this particular
-// NodeGroup. Returning a nil will result in using default options.
-func (as *AgentPool) GetOptions(defaults config.NodeGroupAutoscalingOptions) (*config.NodeGroupAutoscalingOptions, error) {
-	return nil, cloudprovider.ErrNotImplemented
-}
-
-// MaxSize returns maximum size of the node group.
-func (as *AgentPool) MaxSize() int {
-	return as.maxSize
-}
-
-// Id returns AgentPool id.
-func (as *AgentPool) Id() string {
-	return as.Name
-}
-
-func (as *AgentPool) getVMsFromCache() ([]compute.VirtualMachine, error) {
-	allVMs := as.manager.azureCache.getVirtualMachines()
-	if _, exists := allVMs[as.Name]; !exists {
-		return []compute.VirtualMachine{}, fmt.Errorf("could not find VMs with poolName: %s", as.Name)
-	}
-	return allVMs[as.Name], nil
-}
-
-// GetVMIndexes gets indexes of all virtual machines belonging to the agent pool.
-func (as *AgentPool) GetVMIndexes() ([]int, map[int]string, error) {
-	klog.V(6).Infof("GetVMIndexes: starts for as %v", as)
-
-	instances, err := as.getVMsFromCache()
-	if err != nil {
-		return nil, nil, err
-	}
-	klog.V(6).Infof("GetVMIndexes: got instances, length = %d", len(instances))
-
-	indexes := make([]int, 0)
-	indexToVM := make(map[int]string)
-	for _, instance := range instances {
-		index, err := GetVMNameIndex(instance.StorageProfile.OsDisk.OsType, *instance.Name)
-		if err != nil {
-			return nil, nil, err
-		}
-
-		indexes = append(indexes, index)
-		resourceID, err := convertResourceGroupNameToLower("azure://" + *instance.ID)
-		if err != nil {
-			return nil, nil, err
-		}
-		indexToVM[index] = resourceID
-	}
-
-	sortedIndexes := sort.IntSlice(indexes)
-	sortedIndexes.Sort()
-	return sortedIndexes, indexToVM, nil
-}
-
-func (as *AgentPool) getCurSize() (int64, error) {
-	as.mutex.Lock()
-	defer as.mutex.Unlock()
-
-	if as.lastRefresh.Add(15 * time.Second).After(time.Now()) {
-		return as.curSize, nil
-	}
-
-	klog.V(5).Infof("Get agent pool size for %q", as.Name)
-	indexes, _, err := as.GetVMIndexes()
-	if err != nil {
-		return 0, err
-	}
-	klog.V(5).Infof("Returning agent pool (%q) size: %d\n", as.Name, len(indexes))
-
-	if as.curSize != int64(len(indexes)) {
-		klog.V(6).Infof("getCurSize:as.curSize(%d) != real size (%d), invalidating cache", as.curSize, len(indexes))
-		as.manager.invalidateCache()
-	}
-
-	as.curSize = int64(len(indexes))
-	as.lastRefresh = time.Now()
-	return as.curSize, nil
-}
-
-// TargetSize returns the current TARGET size of the node group. It is possible that the
-// number is different from the number of nodes registered in Kubernetes.
-func (as *AgentPool) TargetSize() (int, error) {
-	size, err := as.getCurSize()
-	if err != nil {
-		return -1, err
-	}
-
-	return int(size), nil
-}
-
-func (as *AgentPool) getAllSucceededAndFailedDeployments() (succeededAndFailedDeployments []resources.DeploymentExtended, err error) {
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-
-	deploymentsFilter := "provisioningState eq 'Succeeded' or provisioningState eq 'Failed'"
-	succeededAndFailedDeployments, err = as.manager.azClient.deploymentsClient.List(ctx, as.manager.config.ResourceGroup, deploymentsFilter, nil)
-	if err != nil {
-		klog.Errorf("getAllSucceededAndFailedDeployments: failed to list succeeded or failed deployments with error: %v", err)
-		return nil, err
-	}
-
-	return succeededAndFailedDeployments, err
-}
-
-// deleteOutdatedDeployments keeps the newest deployments in the resource group and delete others,
-// since Azure resource group deployments have a hard cap of 800, outdated deployments must be deleted
-// to prevent the `DeploymentQuotaExceeded` error. see: issue #2154.
-func (as *AgentPool) deleteOutdatedDeployments() (err error) {
-	deployments, err := as.getAllSucceededAndFailedDeployments()
-	if err != nil {
-		return err
-	}
-
-	for i := len(deployments) - 1; i >= 0; i-- {
-		klog.V(4).Infof("deleteOutdatedDeployments: found deployments[i].Name: %s", *deployments[i].Name)
-		if deployments[i].Name != nil && !strings.HasPrefix(*deployments[i].Name, clusterAutoscalerDeploymentPrefix) {
-			deployments = append(deployments[:i], deployments[i+1:]...)
-		}
-	}
-
-	if int64(len(deployments)) <= as.manager.config.MaxDeploymentsCount {
-		klog.V(4).Infof("deleteOutdatedDeployments: the number of deployments (%d) is under threshold, skip deleting", len(deployments))
-		return err
-	}
-
-	sort.Slice(deployments, func(i, j int) bool {
-		return deployments[i].Properties.Timestamp.Time.After(deployments[j].Properties.Timestamp.Time)
-	})
-
-	toBeDeleted := deployments[as.manager.config.MaxDeploymentsCount:]
-
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-
-	errList := make([]error, 0)
-	for _, deployment := range toBeDeleted {
-		klog.V(4).Infof("deleteOutdatedDeployments: starts deleting outdated deployment (%s)", *deployment.Name)
-		_, err := as.manager.azClient.deploymentsClient.Delete(ctx, as.manager.config.ResourceGroup, *deployment.Name)
-		if err != nil {
-			errList = append(errList, err)
-		}
-	}
-
-	return utilerrors.NewAggregate(errList)
-}
-
-// IncreaseSize increases agent pool size
-func (as *AgentPool) IncreaseSize(delta int) error {
-	as.mutex.Lock()
-	defer as.mutex.Unlock()
-
-	if as.curSize == -1 {
-		return fmt.Errorf("the availability set %s is under initialization, skipping IncreaseSize", as.Name)
-	}
-
-	if delta <= 0 {
-		return fmt.Errorf("size increase must be positive")
-	}
-
-	err := as.deleteOutdatedDeployments()
-	if err != nil {
-		klog.Warningf("IncreaseSize: failed to cleanup outdated deployments with err: %v.", err)
-	}
-
-	klog.V(6).Infof("IncreaseSize: invalidating cache")
-	as.manager.invalidateCache()
-
-	indexes, _, err := as.GetVMIndexes()
-	if err != nil {
-		return err
-	}
-
-	curSize := len(indexes)
-	if curSize+delta > as.MaxSize() {
-		return fmt.Errorf("size increase too large - desired:%d max:%d", curSize+delta, as.MaxSize())
-	}
-
-	highestUsedIndex := indexes[len(indexes)-1]
-	expectedSize := curSize + delta
-	countForTemplate := expectedSize
-	if highestUsedIndex != 0 {
-		countForTemplate += highestUsedIndex + 1 - curSize
-	}
-	as.parameters[as.Name+"Count"] = map[string]int{"value": countForTemplate}
-	as.parameters[as.Name+"Offset"] = map[string]int{"value": highestUsedIndex + 1}
-
-	newDeploymentName := fmt.Sprintf("cluster-autoscaler-%d", rand.New(rand.NewSource(time.Now().UnixNano())).Int31())
-	newDeployment := resources.Deployment{
-		Properties: &resources.DeploymentProperties{
-			Template:   &as.template,
-			Parameters: &as.parameters,
-			Mode:       resources.Incremental,
-		},
-	}
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-	klog.V(3).Infof("Waiting for deploymentsClient.CreateOrUpdate(%s, %s, %v)", as.manager.config.ResourceGroup, newDeploymentName, newDeployment)
-	resp, err := as.manager.azClient.deploymentsClient.CreateOrUpdate(ctx, as.manager.config.ResourceGroup, newDeploymentName, newDeployment)
-	isSuccess, realError := isSuccessHTTPResponse(resp, err)
-	if isSuccess {
-		klog.V(3).Infof("deploymentsClient.CreateOrUpdate(%s, %s, %v) success", as.manager.config.ResourceGroup, newDeploymentName, newDeployment)
-
-		// Update cache after scale success.
-		as.curSize = int64(expectedSize)
-		as.lastRefresh = time.Now()
-		klog.V(6).Info("IncreaseSize: invalidating cache")
-		as.manager.invalidateCache()
-		return nil
-	}
-
-	klog.Errorf("deploymentsClient.CreateOrUpdate for deployment %q failed: %v", newDeploymentName, realError)
-	return realError
-}
-
-// DecreaseTargetSize decreases the target size of the node group. This function
-// doesn't permit to delete any existing node and can be used only to reduce the
-// request for new nodes that have not been yet fulfilled. Delta should be negative.
-// It is assumed that cloud provider will not delete the existing nodes if the size
-// when there is an option to just decrease the target.
-func (as *AgentPool) DecreaseTargetSize(delta int) error {
-	as.mutex.Lock()
-	defer as.mutex.Unlock()
-
-	nodes, err := as.getVMsFromCache()
-	if err != nil {
-		return err
-	}
-
-	curTargetSize := int(as.curSize)
-	if curTargetSize+delta < len(nodes) {
-		return fmt.Errorf("attempt to delete existing nodes targetSize:%d delta:%d existingNodes: %d",
-			curTargetSize, delta, len(nodes))
-	}
-
-	as.curSize = int64(curTargetSize + delta)
-	as.lastRefresh = time.Now()
-	return nil
-}
-
-// Belongs returns true if the given node belongs to the NodeGroup.
-func (as *AgentPool) Belongs(node *apiv1.Node) (bool, error) {
-	klog.V(6).Infof("Check if node belongs to this agent pool: AgentPool:%v, node:%v\n", as, node)
-
-	ref := &azureRef{
-		Name: node.Spec.ProviderID,
-	}
-
-	targetAsg, err := as.manager.GetNodeGroupForInstance(ref)
-	if err != nil {
-		return false, err
-	}
-	if targetAsg == nil {
-		return false, fmt.Errorf("%s doesn't belong to a known agent pool", node.Name)
-	}
-	if !strings.EqualFold(targetAsg.Id(), as.Name) {
-		return false, nil
-	}
-	return true, nil
-}
-
-// DeleteInstances deletes the given instances. All instances must be controlled by the same ASG.
-func (as *AgentPool) DeleteInstances(instances []*azureRef) error {
-	if len(instances) == 0 {
-		return nil
-	}
-
-	commonAsg, err := as.manager.GetNodeGroupForInstance(instances[0])
-	if err != nil {
-		return err
-	}
-
-	for _, instance := range instances {
-		asg, err := as.manager.GetNodeGroupForInstance(instance)
-		if err != nil {
-			return err
-		}
-
-		if !strings.EqualFold(asg.Id(), commonAsg.Id()) {
-			return fmt.Errorf("cannot delete instance (%s) which don't belong to the same node pool (%q)", instance.GetKey(), commonAsg)
-		}
-	}
-
-	for _, instance := range instances {
-		name, err := resourceName((*instance).Name)
-		if err != nil {
-			klog.Errorf("Get name for instance %q failed: %v", *instance, err)
-			return err
-		}
-
-		err = as.deleteVirtualMachine(name)
-		if err != nil {
-			klog.Errorf("Delete virtual machine %q failed: %v", name, err)
-			return err
-		}
-	}
-
-	klog.V(6).Infof("DeleteInstances: invalidating cache")
-	as.manager.invalidateCache()
-	return nil
-}
-
-// DeleteNodes deletes the nodes from the group.
-func (as *AgentPool) DeleteNodes(nodes []*apiv1.Node) error {
-	klog.V(6).Infof("Delete nodes requested: %v\n", nodes)
-	indexes, _, err := as.GetVMIndexes()
-	if err != nil {
-		return err
-	}
-
-	if len(indexes) <= as.MinSize() {
-		return fmt.Errorf("min size reached, nodes will not be deleted")
-	}
-
-	refs := make([]*azureRef, 0, len(nodes))
-	for _, node := range nodes {
-		belongs, err := as.Belongs(node)
-		if err != nil {
-			return err
-		}
-
-		if belongs != true {
-			return fmt.Errorf("%s belongs to a different asg than %s", node.Name, as.Name)
-		}
-
-		ref := &azureRef{
-			Name: node.Spec.ProviderID,
-		}
-		refs = append(refs, ref)
-	}
-
-	err = as.deleteOutdatedDeployments()
-	if err != nil {
-		klog.Warningf("DeleteNodes: failed to cleanup outdated deployments with err: %v.", err)
-	}
-
-	return as.DeleteInstances(refs)
-}
-
-// Debug returns a debug string for the agent pool.
-func (as *AgentPool) Debug() string {
-	return fmt.Sprintf("%s (%d:%d)", as.Name, as.MinSize(), as.MaxSize())
-}
-
-// TemplateNodeInfo returns a node template for this agent pool.
-func (as *AgentPool) TemplateNodeInfo() (*schedulerframework.NodeInfo, error) {
-	return nil, cloudprovider.ErrNotImplemented
-}
-
-// Nodes returns a list of all nodes that belong to this node group.
-func (as *AgentPool) Nodes() ([]cloudprovider.Instance, error) {
-	instances, err := as.getVMsFromCache()
-	if err != nil {
-		return nil, err
-	}
-
-	nodes := make([]cloudprovider.Instance, 0, len(instances))
-	for _, instance := range instances {
-		if len(*instance.ID) == 0 {
-			continue
-		}
-
-		// To keep consistent with providerID from kubernetes cloud provider, convert
-		// resourceGroupName in the ID to lower case.
-		resourceID, err := convertResourceGroupNameToLower("azure://" + *instance.ID)
-		if err != nil {
-			return nil, err
-		}
-		nodes = append(nodes, cloudprovider.Instance{Id: resourceID})
-	}
-
-	return nodes, nil
-}
-
-func (as *AgentPool) deleteBlob(accountName, vhdContainer, vhdBlob string) error {
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-
-	storageKeysResult, rerr := as.manager.azClient.storageAccountsClient.ListKeys(ctx, as.manager.config.ResourceGroup, accountName)
-	if rerr != nil {
-		return rerr.Error()
-	}
-
-	keys := *storageKeysResult.Keys
-	client, err := azStorage.NewBasicClientOnSovereignCloud(accountName, to.String(keys[0].Value), as.manager.env)
-	if err != nil {
-		return err
-	}
-
-	bs := client.GetBlobService()
-	containerRef := bs.GetContainerReference(vhdContainer)
-	blobRef := containerRef.GetBlobReference(vhdBlob)
-
-	return blobRef.Delete(&azStorage.DeleteBlobOptions{})
-}
-
-// deleteVirtualMachine deletes a VM and any associated OS disk
-func (as *AgentPool) deleteVirtualMachine(name string) error {
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-
-	vm, rerr := as.manager.azClient.virtualMachinesClient.Get(ctx, as.manager.config.ResourceGroup, name, "")
-	if rerr != nil {
-		if exists, _ := checkResourceExistsFromRetryError(rerr); !exists {
-			klog.V(2).Infof("VirtualMachine %s/%s has already been removed", as.manager.config.ResourceGroup, name)
-			return nil
-		}
-
-		klog.Errorf("failed to get VM: %s/%s: %s", as.manager.config.ResourceGroup, name, rerr.Error())
-		return rerr.Error()
-	}
-
-	vhd := vm.VirtualMachineProperties.StorageProfile.OsDisk.Vhd
-	managedDisk := vm.VirtualMachineProperties.StorageProfile.OsDisk.ManagedDisk
-	if vhd == nil && managedDisk == nil {
-		klog.Errorf("failed to get a valid os disk URI for VM: %s/%s", as.manager.config.ResourceGroup, name)
-		return fmt.Errorf("os disk does not have a VHD URI")
-	}
-
-	osDiskName := vm.VirtualMachineProperties.StorageProfile.OsDisk.Name
-	var nicName string
-	nicID := (*vm.VirtualMachineProperties.NetworkProfile.NetworkInterfaces)[0].ID
-	if nicID == nil {
-		klog.Warningf("NIC ID is not set for VM (%s/%s)", as.manager.config.ResourceGroup, name)
-	} else {
-		nicName, err := resourceName(*nicID)
-		if err != nil {
-			return err
-		}
-		klog.Infof("found nic name for VM (%s/%s): %s", as.manager.config.ResourceGroup, name, nicName)
-	}
-
-	klog.Infof("deleting VM: %s/%s", as.manager.config.ResourceGroup, name)
-	deleteCtx, deleteCancel := getContextWithCancel()
-	defer deleteCancel()
-
-	klog.Infof("waiting for VirtualMachine deletion: %s/%s", as.manager.config.ResourceGroup, name)
-	rerr = as.manager.azClient.virtualMachinesClient.Delete(deleteCtx, as.manager.config.ResourceGroup, name)
-	_, realErr := checkResourceExistsFromRetryError(rerr)
-	if realErr != nil {
-		return realErr
-	}
-	klog.V(2).Infof("VirtualMachine %s/%s removed", as.manager.config.ResourceGroup, name)
-
-	if len(nicName) > 0 {
-		klog.Infof("deleting nic: %s/%s", as.manager.config.ResourceGroup, nicName)
-		interfaceCtx, interfaceCancel := getContextWithCancel()
-		defer interfaceCancel()
-		rerr := as.manager.azClient.interfacesClient.Delete(interfaceCtx, as.manager.config.ResourceGroup, nicName)
-		klog.Infof("waiting for nic deletion: %s/%s", as.manager.config.ResourceGroup, nicName)
-		_, realErr := checkResourceExistsFromRetryError(rerr)
-		if realErr != nil {
-			return realErr
-		}
-		klog.V(2).Infof("interface %s/%s removed", as.manager.config.ResourceGroup, nicName)
-	}
-
-	if vhd != nil {
-		accountName, vhdContainer, vhdBlob, err := splitBlobURI(*vhd.URI)
-		if err != nil {
-			return err
-		}
-
-		klog.Infof("found os disk storage reference: %s %s %s", accountName, vhdContainer, vhdBlob)
-
-		klog.Infof("deleting blob: %s/%s", vhdContainer, vhdBlob)
-		if err = as.deleteBlob(accountName, vhdContainer, vhdBlob); err != nil {
-			_, realErr := checkResourceExistsFromError(err)
-			if realErr != nil {
-				return realErr
-			}
-			klog.V(2).Infof("Blob %s/%s removed", as.manager.config.ResourceGroup, vhdBlob)
-		}
-	} else if managedDisk != nil {
-		if osDiskName == nil {
-			klog.Warningf("osDisk is not set for VM %s/%s", as.manager.config.ResourceGroup, name)
-		} else {
-			klog.Infof("deleting managed disk: %s/%s", as.manager.config.ResourceGroup, *osDiskName)
-			disksCtx, disksCancel := getContextWithCancel()
-			defer disksCancel()
-			rerr := as.manager.azClient.disksClient.Delete(disksCtx, as.manager.config.ResourceGroup, *osDiskName)
-			_, realErr := checkResourceExistsFromRetryError(rerr)
-			if realErr != nil {
-				return realErr
-			}
-			klog.V(2).Infof("disk %s/%s removed", as.manager.config.ResourceGroup, *osDiskName)
-		}
-	}
-
-	return nil
-}
-
-// getAzureRef gets AzureRef for the as.
-func (as *AgentPool) getAzureRef() azureRef {
-	return as.azureRef
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_agent_pool_test.go b/cluster-autoscaler/cloudprovider/azure/azure_agent_pool_test.go
deleted file mode 100644
index 0c32de654..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_agent_pool_test.go
+++ /dev/null
@@ -1,521 +0,0 @@
-/*
-Copyright 2019 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"context"
-	"fmt"
-	"net/http"
-	"strings"
-	"testing"
-	"time"
-
-	apiv1 "k8s.io/api/core/v1"
-	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient/mockstorageaccountclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/vmclient/mockvmclient"
-	"k8s.io/legacy-cloud-providers/azure/retry"
-
-	"github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2019-12-01/compute"
-	"github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2017-05-10/resources"
-	"github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2019-06-01/storage"
-	"github.com/Azure/go-autorest/autorest/date"
-	"github.com/Azure/go-autorest/autorest/to"
-	"github.com/golang/mock/gomock"
-	"github.com/stretchr/testify/assert"
-)
-
-var (
-	rerrTooManyReqs       = retry.Error{HTTPStatusCode: http.StatusTooManyRequests}
-	rerrInternalErr       = retry.Error{HTTPStatusCode: http.StatusInternalServerError}
-	testValidProviderID0  = "/subscriptions/sub/resourceGroups/rg/providers/Microsoft.Compute/virtualMachines/as-vm-0"
-	testValidProviderID1  = "/subscriptions/sub/resourceGroups/rg/providers/Microsoft.Compute/virtualMachines/as-vm-1"
-	testInvalidProviderID = "/subscriptions/sub/resourceGroups/rg/providers/provider/virtualMachines/as-vm-0/"
-)
-
-func newTestAgentPool(manager *AzureManager, name string) *AgentPool {
-	return &AgentPool{
-		azureRef: azureRef{
-			Name: name,
-		},
-		manager:    manager,
-		minSize:    1,
-		maxSize:    5,
-		parameters: make(map[string]interface{}),
-		template:   make(map[string]interface{}),
-	}
-}
-
-func getExpectedVMs() []compute.VirtualMachine {
-	expectedVMs := []compute.VirtualMachine{
-		{
-			Name: to.StringPtr("000-0-00000000-0"),
-			ID:   to.StringPtr("/subscriptions/sub/resourceGroups/rg/providers/provider/0"),
-			Tags: map[string]*string{"poolName": to.StringPtr("as")},
-			VirtualMachineProperties: &compute.VirtualMachineProperties{
-				StorageProfile: &compute.StorageProfile{
-					OsDisk: &compute.OSDisk{
-						OsType: compute.Linux,
-						Vhd:    &compute.VirtualHardDisk{URI: to.StringPtr("https://foo.blob/vhds/bar.vhd")},
-					},
-				},
-				NetworkProfile: &compute.NetworkProfile{
-					NetworkInterfaces: &[]compute.NetworkInterfaceReference{
-						{},
-					},
-				},
-			},
-		},
-		{
-			Name: to.StringPtr("00000000001"),
-			ID:   to.StringPtr("/subscriptions/sub/resourceGroups/rg/providers/provider/0"),
-			Tags: map[string]*string{"poolName": to.StringPtr("as")},
-			VirtualMachineProperties: &compute.VirtualMachineProperties{
-				StorageProfile: &compute.StorageProfile{
-					OsDisk: &compute.OSDisk{OsType: compute.Windows},
-				},
-			},
-		},
-	}
-
-	return expectedVMs
-}
-
-func TestInitialize(t *testing.T) {
-	as := newTestAgentPool(newTestAzureManager(t), "as")
-
-	err := as.initialize()
-	assert.NoError(t, err)
-	assert.NotNil(t, as.template)
-}
-
-func TestDeleteOutdatedDeployments(t *testing.T) {
-	timeLayout := "2006-01-02 15:04:05"
-	timeBenchMark, _ := time.Parse(timeLayout, "2000-01-01 00:00:00")
-
-	testCases := []struct {
-		deployments              map[string]resources.DeploymentExtended
-		expectedDeploymentsNames map[string]bool
-		expectedErr              error
-		desc                     string
-	}{
-		{
-			deployments: map[string]resources.DeploymentExtended{
-				"non-cluster-autoscaler-0000": {
-					Name: to.StringPtr("non-cluster-autoscaler-0000"),
-					Properties: &resources.DeploymentPropertiesExtended{
-						ProvisioningState: to.StringPtr("Succeeded"),
-						Timestamp:         &date.Time{Time: timeBenchMark.Add(2 * time.Minute)},
-					},
-				},
-				"cluster-autoscaler-0000": {
-					Name: to.StringPtr("cluster-autoscaler-0000"),
-					Properties: &resources.DeploymentPropertiesExtended{
-						ProvisioningState: to.StringPtr("Succeeded"),
-						Timestamp:         &date.Time{Time: timeBenchMark},
-					},
-				},
-				"cluster-autoscaler-0001": {
-					Name: to.StringPtr("cluster-autoscaler-0001"),
-					Properties: &resources.DeploymentPropertiesExtended{
-						ProvisioningState: to.StringPtr("Succeeded"),
-						Timestamp:         &date.Time{Time: timeBenchMark.Add(time.Minute)},
-					},
-				},
-				"cluster-autoscaler-0002": {
-					Name: to.StringPtr("cluster-autoscaler-0002"),
-					Properties: &resources.DeploymentPropertiesExtended{
-						ProvisioningState: to.StringPtr("Succeeded"),
-						Timestamp:         &date.Time{Time: timeBenchMark.Add(2 * time.Minute)},
-					},
-				},
-			},
-			expectedDeploymentsNames: map[string]bool{
-				"non-cluster-autoscaler-0000": true,
-				"cluster-autoscaler-0001":     true,
-				"cluster-autoscaler-0002":     true,
-			},
-			expectedErr: nil,
-			desc:        "cluster autoscaler provider azure should delete outdated deployments created by cluster autoscaler",
-		},
-	}
-
-	for _, test := range testCases {
-		testAS := newTestAgentPool(newTestAzureManager(t), "testAS")
-		testAS.manager.azClient.deploymentsClient = &DeploymentsClientMock{
-			FakeStore: test.deployments,
-		}
-
-		err := testAS.deleteOutdatedDeployments()
-		assert.Equal(t, test.expectedErr, err, test.desc)
-		existedDeployments, err := testAS.manager.azClient.deploymentsClient.List(context.Background(), "", "", to.Int32Ptr(0))
-		existedDeploymentsNames := make(map[string]bool)
-		for _, deployment := range existedDeployments {
-			existedDeploymentsNames[*deployment.Name] = true
-		}
-		assert.Equal(t, test.expectedDeploymentsNames, existedDeploymentsNames, test.desc)
-	}
-}
-
-func TestGetVMsFromCache(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	testAS := newTestAgentPool(newTestAzureManager(t), "testAS")
-	expectedVMs := []compute.VirtualMachine{
-		{
-			Tags: map[string]*string{"poolName": to.StringPtr("testAS")},
-		},
-	}
-
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	testAS.manager.azClient.virtualMachinesClient = mockVMClient
-	mockVMClient.EXPECT().List(gomock.Any(), testAS.manager.config.ResourceGroup).Return(expectedVMs, nil)
-	ac, err := newAzureCache(testAS.manager.azClient, refreshInterval, testAS.manager.config.ResourceGroup, vmTypeStandard)
-	assert.NoError(t, err)
-	testAS.manager.azureCache = ac
-
-	vms, err := testAS.getVMsFromCache()
-	assert.Equal(t, 1, len(vms))
-	assert.NoError(t, err)
-}
-
-func TestGetVMIndexes(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	as := newTestAgentPool(newTestAzureManager(t), "as")
-	expectedVMs := getExpectedVMs()
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	as.manager.azClient.virtualMachinesClient = mockVMClient
-	mockVMClient.EXPECT().List(gomock.Any(), as.manager.config.ResourceGroup).Return(expectedVMs, nil)
-	ac, err := newAzureCache(as.manager.azClient, refreshInterval, as.manager.config.ResourceGroup, vmTypeStandard)
-	assert.NoError(t, err)
-	as.manager.azureCache = ac
-
-	sortedIndexes, indexToVM, err := as.GetVMIndexes()
-	assert.NoError(t, err)
-	assert.Equal(t, 2, len(sortedIndexes))
-	assert.Equal(t, 2, len(indexToVM))
-
-	expectedVMs[0].ID = to.StringPtr("foo")
-	mockVMClient.EXPECT().List(gomock.Any(), as.manager.config.ResourceGroup).Return(expectedVMs, nil)
-	err = as.manager.forceRefresh()
-	assert.NoError(t, err)
-	sortedIndexes, indexToVM, err = as.GetVMIndexes()
-	expectedErr := fmt.Errorf("\"azure://foo\" isn't in Azure resource ID format")
-	assert.Equal(t, expectedErr, err)
-	assert.Nil(t, sortedIndexes)
-	assert.Nil(t, indexToVM)
-
-	expectedVMs[0].Name = to.StringPtr("foo")
-	mockVMClient.EXPECT().List(gomock.Any(), as.manager.config.ResourceGroup).Return(expectedVMs, nil)
-	err = as.manager.forceRefresh()
-	sortedIndexes, indexToVM, err = as.GetVMIndexes()
-	expectedErr = fmt.Errorf("resource name was missing from identifier")
-	assert.Equal(t, expectedErr, err)
-	assert.Nil(t, sortedIndexes)
-	assert.Nil(t, indexToVM)
-}
-
-func TestGetCurSize(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	as := newTestAgentPool(newTestAzureManager(t), "as")
-	as.curSize = 1
-	expectedVMs := getExpectedVMs()
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	as.manager.azClient.virtualMachinesClient = mockVMClient
-	mockVMClient.EXPECT().List(gomock.Any(), as.manager.config.ResourceGroup).Return(expectedVMs, nil)
-	ac, err := newAzureCache(as.manager.azClient, refreshInterval, as.manager.config.ResourceGroup, vmTypeStandard)
-	assert.NoError(t, err)
-	as.manager.azureCache = ac
-
-	as.lastRefresh = time.Now()
-	curSize, err := as.getCurSize()
-	assert.NoError(t, err)
-	assert.Equal(t, int64(1), curSize)
-
-	as.lastRefresh = time.Now().Add(-1 * 3 * time.Minute)
-	curSize, err = as.getCurSize()
-	assert.NoError(t, err)
-	assert.Equal(t, int64(2), curSize)
-}
-
-func TestAgentPoolTargetSize(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	as := newTestAgentPool(newTestAzureManager(t), "as")
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	as.manager.azClient.virtualMachinesClient = mockVMClient
-	expectedVMs := getExpectedVMs()
-	mockVMClient.EXPECT().List(gomock.Any(), as.manager.config.ResourceGroup).Return(expectedVMs, nil)
-	ac, err := newAzureCache(as.manager.azClient, refreshInterval, as.manager.config.ResourceGroup, vmTypeStandard)
-	assert.NoError(t, err)
-	as.manager.azureCache = ac
-
-	as.lastRefresh = time.Now().Add(-1 * 15 * time.Second)
-	size, err := as.getCurSize()
-	assert.NoError(t, err)
-	assert.Equal(t, int64(2), size)
-}
-
-func TestAgentPoolIncreaseSize(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	as := newTestAgentPool(newTestAzureManager(t), "as")
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	as.manager.azClient.virtualMachinesClient = mockVMClient
-	expectedVMs := getExpectedVMs()
-	mockVMClient.EXPECT().List(gomock.Any(), as.manager.config.ResourceGroup).Return(expectedVMs, nil).MaxTimes(2)
-	ac, err := newAzureCache(as.manager.azClient, refreshInterval, as.manager.config.ResourceGroup, vmTypeStandard)
-	assert.NoError(t, err)
-	as.manager.azureCache = ac
-
-	err = as.IncreaseSize(-1)
-	expectedErr := fmt.Errorf("size increase must be positive")
-	assert.Equal(t, expectedErr, err)
-
-	mockVMClient.EXPECT().List(gomock.Any(), as.manager.config.ResourceGroup).Return(expectedVMs, nil).MaxTimes(2)
-	err = as.manager.Refresh()
-	assert.NoError(t, err)
-	err = as.IncreaseSize(4)
-	expectedErr = fmt.Errorf("size increase too large - desired:6 max:5")
-
-	err = as.IncreaseSize(2)
-	assert.NoError(t, err)
-}
-
-func TestDecreaseTargetSize(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	as := newTestAgentPool(newTestAzureManager(t), "as")
-	as.curSize = 3
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	as.manager.azClient.virtualMachinesClient = mockVMClient
-	expectedVMs := getExpectedVMs()
-	mockVMClient.EXPECT().List(gomock.Any(), as.manager.config.ResourceGroup).Return(expectedVMs, nil).MaxTimes(3)
-	ac, err := newAzureCache(as.manager.azClient, refreshInterval, as.manager.config.ResourceGroup, vmTypeStandard)
-	assert.NoError(t, err)
-	as.manager.azureCache = ac
-
-	err = as.DecreaseTargetSize(-1)
-	assert.NoError(t, err)
-	assert.Equal(t, int64(2), as.curSize)
-
-	mockVMClient.EXPECT().List(gomock.Any(), as.manager.config.ResourceGroup).Return(expectedVMs, nil).MaxTimes(2)
-	err = as.manager.Refresh()
-	assert.NoError(t, err)
-	err = as.DecreaseTargetSize(-1)
-	expectedErr := fmt.Errorf("attempt to delete existing nodes targetSize:2 delta:-1 existingNodes: 2")
-	assert.Equal(t, expectedErr, err)
-}
-
-func TestAgentPoolBelongs(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	as := newTestAgentPool(newTestAzureManager(t), "as")
-	as.manager.azureCache.instanceToNodeGroup[azureRef{Name: testValidProviderID0}] = as
-
-	flag, err := as.Belongs(&apiv1.Node{Spec: apiv1.NodeSpec{ProviderID: testValidProviderID0}})
-	assert.NoError(t, err)
-	assert.True(t, flag)
-
-	flag, err = as.Belongs(&apiv1.Node{
-		Spec:       apiv1.NodeSpec{ProviderID: testInvalidProviderID},
-		ObjectMeta: v1.ObjectMeta{Name: "node"},
-	})
-	expectedErr := fmt.Errorf("node doesn't belong to a known agent pool")
-	assert.Equal(t, expectedErr, err)
-	assert.False(t, flag)
-
-	as1 := newTestAgentPool(newTestAzureManager(t), "as1")
-	as1.manager.azureCache.instanceToNodeGroup[azureRef{Name: testValidProviderID0}] = as
-	flag, err = as1.Belongs(&apiv1.Node{Spec: apiv1.NodeSpec{ProviderID: testValidProviderID0}})
-	assert.NoError(t, err)
-	assert.False(t, flag)
-}
-
-func TestDeleteInstances(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	as := newTestAgentPool(newTestAzureManager(t), "as")
-	as1 := newTestAgentPool(newTestAzureManager(t), "as1")
-	as.manager.azureCache.instanceToNodeGroup[azureRef{Name: testValidProviderID0}] = as
-	as.manager.azureCache.instanceToNodeGroup[azureRef{Name: testValidProviderID1}] = as1
-	as.manager.azureCache.instanceToNodeGroup[azureRef{Name: testInvalidProviderID}] = as
-
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	as.manager.azClient.virtualMachinesClient = mockVMClient
-
-	mockSAClient := mockstorageaccountclient.NewMockInterface(ctrl)
-	as.manager.azClient.storageAccountsClient = mockSAClient
-
-	err := as.DeleteInstances([]*azureRef{})
-	assert.NoError(t, err)
-
-	instances := []*azureRef{
-		{Name: "foo"},
-	}
-	err = as.DeleteInstances(instances)
-	expectedErr := fmt.Errorf("\"foo\" isn't in Azure resource ID format")
-	assert.Equal(t, expectedErr, err)
-
-	instances = []*azureRef{
-		{Name: testValidProviderID0},
-		{Name: "foo"},
-	}
-	err = as.DeleteInstances(instances)
-	assert.Equal(t, expectedErr, err)
-
-	instances = []*azureRef{
-		{Name: testInvalidProviderID},
-	}
-	err = as.DeleteInstances(instances)
-	expectedErr = fmt.Errorf("resource name was missing from identifier")
-	assert.Equal(t, expectedErr, err)
-
-	instances = []*azureRef{
-		{Name: testValidProviderID0},
-		{Name: testValidProviderID1},
-	}
-
-	err = as.DeleteInstances(instances)
-	expectedErr = fmt.Errorf("cannot delete instance (%s) which don't belong to the same node pool (\"as\")", testValidProviderID1)
-	assert.Equal(t, expectedErr, err)
-
-	instances = []*azureRef{
-		{Name: testValidProviderID0},
-	}
-	mockVMClient.EXPECT().Get(gomock.Any(), as.manager.config.ResourceGroup, "as-vm-0", gomock.Any()).Return(getExpectedVMs()[0], nil)
-	mockVMClient.EXPECT().Delete(gomock.Any(), as.manager.config.ResourceGroup, "as-vm-0").Return(nil)
-	mockSAClient.EXPECT().ListKeys(gomock.Any(), as.manager.config.ResourceGroup, "foo").Return(storage.AccountListKeysResult{
-		Keys: &[]storage.AccountKey{
-			{Value: to.StringPtr("dmFsdWUK")},
-		},
-	}, nil)
-	err = as.DeleteInstances(instances)
-	expectedErrStr := "The specified account is disabled."
-	assert.True(t, strings.Contains(err.Error(), expectedErrStr))
-}
-
-func TestAgentPoolDeleteNodes(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	as := newTestAgentPool(newTestAzureManager(t), "as")
-	as.manager.azureCache.instanceToNodeGroup[azureRef{Name: testValidProviderID0}] = as
-	expectedVMs := getExpectedVMs()
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	as.manager.azClient.virtualMachinesClient = mockVMClient
-	mockSAClient := mockstorageaccountclient.NewMockInterface(ctrl)
-	as.manager.azClient.storageAccountsClient = mockSAClient
-	mockVMClient.EXPECT().List(gomock.Any(), as.manager.config.ResourceGroup).Return(expectedVMs, nil)
-	ac, err := newAzureCache(as.manager.azClient, refreshInterval, as.manager.config.ResourceGroup, vmTypeStandard)
-	assert.NoError(t, err)
-	as.manager.azureCache = ac
-
-	err = as.DeleteNodes([]*apiv1.Node{
-		{
-			Spec:       apiv1.NodeSpec{ProviderID: testInvalidProviderID},
-			ObjectMeta: v1.ObjectMeta{Name: "node"},
-		},
-	})
-	expectedErr := fmt.Errorf("node doesn't belong to a known agent pool")
-	assert.Equal(t, expectedErr, err)
-
-	as1 := newTestAgentPool(newTestAzureManager(t), "as1")
-	as.manager.azureCache.instanceToNodeGroup[azureRef{Name: testValidProviderID0}] = as1
-	err = as.DeleteNodes([]*apiv1.Node{
-		{
-			Spec:       apiv1.NodeSpec{ProviderID: testValidProviderID0},
-			ObjectMeta: v1.ObjectMeta{Name: "node"},
-		},
-	})
-	expectedErr = fmt.Errorf("node belongs to a different asg than as")
-	assert.Equal(t, expectedErr, err)
-
-	as.manager.azureCache.instanceToNodeGroup[azureRef{Name: testValidProviderID0}] = as
-	mockVMClient.EXPECT().Get(gomock.Any(), as.manager.config.ResourceGroup, "as-vm-0", gomock.Any()).Return(getExpectedVMs()[0], nil)
-	mockVMClient.EXPECT().Delete(gomock.Any(), as.manager.config.ResourceGroup, "as-vm-0").Return(nil)
-	mockSAClient.EXPECT().ListKeys(gomock.Any(), as.manager.config.ResourceGroup, "foo").Return(storage.AccountListKeysResult{
-		Keys: &[]storage.AccountKey{
-			{Value: to.StringPtr("dmFsdWUK")},
-		},
-	}, nil)
-	err = as.DeleteNodes([]*apiv1.Node{
-		{
-			Spec:       apiv1.NodeSpec{ProviderID: testValidProviderID0},
-			ObjectMeta: v1.ObjectMeta{Name: "node"},
-		},
-	})
-	expectedErrStr := "The specified account is disabled."
-	assert.True(t, strings.Contains(err.Error(), expectedErrStr))
-
-	as.minSize = 3
-	err = as.DeleteNodes([]*apiv1.Node{})
-	expectedErr = fmt.Errorf("min size reached, nodes will not be deleted")
-	assert.Equal(t, expectedErr, err)
-}
-
-func TestAgentPoolNodes(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	as := newTestAgentPool(newTestAzureManager(t), "as")
-	expectedVMs := []compute.VirtualMachine{
-		{
-			Tags: map[string]*string{"poolName": to.StringPtr("as")},
-			ID:   to.StringPtr(""),
-		},
-		{
-			Tags: map[string]*string{"poolName": to.StringPtr("as")},
-			ID:   &testValidProviderID0,
-		},
-	}
-
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	as.manager.azClient.virtualMachinesClient = mockVMClient
-	mockVMClient.EXPECT().List(gomock.Any(), as.manager.config.ResourceGroup).Return(expectedVMs, nil)
-	ac, err := newAzureCache(as.manager.azClient, refreshInterval, as.manager.config.ResourceGroup, vmTypeStandard)
-	assert.NoError(t, err)
-	as.manager.azureCache = ac
-
-	nodes, err := as.Nodes()
-	assert.NoError(t, err)
-	assert.Equal(t, 1, len(nodes))
-
-	expectedVMs = []compute.VirtualMachine{
-		{
-			Tags: map[string]*string{"poolName": to.StringPtr("as")},
-			ID:   to.StringPtr("foo"),
-		},
-	}
-	mockVMClient.EXPECT().List(gomock.Any(), as.manager.config.ResourceGroup).Return(expectedVMs, nil)
-	err = as.manager.forceRefresh()
-	assert.NoError(t, err)
-	nodes, err = as.Nodes()
-	expectedErr := fmt.Errorf("\"azure://foo\" isn't in Azure resource ID format")
-	assert.Equal(t, expectedErr, err)
-	assert.Nil(t, nodes)
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_autodiscovery.go b/cluster-autoscaler/cloudprovider/azure/azure_autodiscovery.go
deleted file mode 100644
index 51112ace9..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_autodiscovery.go
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
-Copyright 2020 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"fmt"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-	"strings"
-)
-
-const (
-	autoDiscovererTypeLabel = "label"
-)
-
-// A labelAutoDiscoveryConfig specifies how to auto-discover Azure node groups.
-type labelAutoDiscoveryConfig struct {
-	// Key-values to match on.
-	Selector map[string]string
-}
-
-// ParseLabelAutoDiscoverySpecs returns any provided NodeGroupAutoDiscoverySpecs
-// parsed into configuration appropriate for node group autodiscovery.
-func ParseLabelAutoDiscoverySpecs(o cloudprovider.NodeGroupDiscoveryOptions) ([]labelAutoDiscoveryConfig, error) {
-	cfgs := make([]labelAutoDiscoveryConfig, len(o.NodeGroupAutoDiscoverySpecs))
-	var err error
-	for i, spec := range o.NodeGroupAutoDiscoverySpecs {
-		cfgs[i], err = parseLabelAutoDiscoverySpec(spec)
-		if err != nil {
-			return nil, err
-		}
-	}
-	return cfgs, nil
-}
-
-// parseLabelAutoDiscoverySpec parses a single spec and returns the corresponding node group spec.
-func parseLabelAutoDiscoverySpec(spec string) (labelAutoDiscoveryConfig, error) {
-	cfg := labelAutoDiscoveryConfig{
-		Selector: make(map[string]string),
-	}
-
-	tokens := strings.Split(spec, ":")
-	if len(tokens) != 2 {
-		return cfg, fmt.Errorf("spec \"%s\" should be discoverer:key=value,key=value", spec)
-	}
-	discoverer := tokens[0]
-	if discoverer != autoDiscovererTypeLabel {
-		return cfg, fmt.Errorf("unsupported discoverer specified: %s", discoverer)
-	}
-
-	for _, arg := range strings.Split(tokens[1], ",") {
-		kv := strings.Split(arg, "=")
-		if len(kv) != 2 {
-			return cfg, fmt.Errorf("invalid key=value pair %s", kv)
-		}
-		k, v := kv[0], kv[1]
-		if k == "" || v == "" {
-			return cfg, fmt.Errorf("empty value not allowed in key=value tag pairs")
-		}
-		cfg.Selector[k] = v
-	}
-	return cfg, nil
-}
-
-func matchDiscoveryConfig(labels map[string]*string, configs []labelAutoDiscoveryConfig) bool {
-	if len(configs) == 0 {
-		return false
-	}
-
-	for _, c := range configs {
-		if len(c.Selector) == 0 {
-			return false
-		}
-
-		for k, v := range c.Selector {
-			value, ok := labels[k]
-			if !ok {
-				return false
-			}
-
-			if len(v) > 0 {
-				if value == nil || *value != v {
-					return false
-				}
-			}
-		}
-	}
-
-	return true
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_autodiscovery_test.go b/cluster-autoscaler/cloudprovider/azure/azure_autodiscovery_test.go
deleted file mode 100644
index f119ed917..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_autodiscovery_test.go
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
-Copyright 2020 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"github.com/stretchr/testify/assert"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-	"testing"
-)
-
-func TestParseLabelAutoDiscoverySpecs(t *testing.T) {
-	testCases := []struct {
-		name        string
-		specs       []string
-		expected    []labelAutoDiscoveryConfig
-		expectedErr bool
-	}{
-		{
-			name: "ValidSpec",
-			specs: []string{
-				"label:cluster-autoscaler-enabled=true,cluster-autoscaler-name=fake-cluster",
-				"label:test-tag=test-value,another-test-tag=another-test-value",
-			},
-			expected: []labelAutoDiscoveryConfig{
-				{Selector: map[string]string{"cluster-autoscaler-enabled": "true", "cluster-autoscaler-name": "fake-cluster"}},
-				{Selector: map[string]string{"test-tag": "test-value", "another-test-tag": "another-test-value"}},
-			},
-		},
-		{
-			name:        "MissingAutoDiscoverLabel",
-			specs:       []string{"test-tag=test-value,another-test-tag"},
-			expectedErr: true,
-		},
-		{
-			name:        "InvalidAutoDiscoerLabel",
-			specs:       []string{"invalid:test-tag=test-value,another-test-tag"},
-			expectedErr: true,
-		},
-		{
-			name:        "MissingValue",
-			specs:       []string{"label:test-tag="},
-			expectedErr: true,
-		},
-		{
-			name:        "MissingKey",
-			specs:       []string{"label:=test-val"},
-			expectedErr: true,
-		},
-	}
-
-	for _, tc := range testCases {
-		t.Run(tc.name, func(t *testing.T) {
-			ngdo := cloudprovider.NodeGroupDiscoveryOptions{NodeGroupAutoDiscoverySpecs: tc.specs}
-			actual, err := ParseLabelAutoDiscoverySpecs(ngdo)
-			if tc.expectedErr {
-				assert.Error(t, err)
-				return
-			}
-			assert.NoError(t, err)
-			assert.True(t, assert.ObjectsAreEqualValues(tc.expected, actual), "expected %#v, but found: %#v", tc.expected, actual)
-		})
-	}
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_cache.go b/cluster-autoscaler/cloudprovider/azure/azure_cache.go
deleted file mode 100644
index 43a160372..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_cache.go
+++ /dev/null
@@ -1,316 +0,0 @@
-/*
-Copyright 2018 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"regexp"
-	"strings"
-	"sync"
-	"time"
-
-	"github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2019-12-01/compute"
-	"github.com/Azure/go-autorest/autorest/to"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-
-	"k8s.io/klog/v2"
-)
-
-var (
-	virtualMachineRE = regexp.MustCompile(`^azure://(?:.*)/providers/Microsoft.Compute/virtualMachines/(.+)$`)
-)
-
-// azureCache is used for caching cluster resources state.
-//
-// It is needed to:
-// - keep track of node groups (AKS, VM and VMSS types) in the cluster,
-// - keep track of instances and which node group they belong to,
-// - limit repetitive Azure API calls.
-type azureCache struct {
-	mutex           sync.Mutex
-	interrupt       chan struct{}
-	azClient        *azClient
-	refreshInterval time.Duration
-
-	// Cache content.
-	resourceGroup        string
-	vmType               string
-	scaleSets            map[string]compute.VirtualMachineScaleSet
-	virtualMachines      map[string][]compute.VirtualMachine
-	registeredNodeGroups []cloudprovider.NodeGroup
-	instanceToNodeGroup  map[azureRef]cloudprovider.NodeGroup
-	unownedInstances     map[azureRef]bool
-}
-
-func newAzureCache(client *azClient, cacheTTL time.Duration, resourceGroup, vmType string) (*azureCache, error) {
-	cache := &azureCache{
-		interrupt:            make(chan struct{}),
-		azClient:             client,
-		refreshInterval:      cacheTTL,
-		resourceGroup:        resourceGroup,
-		vmType:               vmType,
-		scaleSets:            make(map[string]compute.VirtualMachineScaleSet),
-		virtualMachines:      make(map[string][]compute.VirtualMachine),
-		registeredNodeGroups: make([]cloudprovider.NodeGroup, 0),
-		instanceToNodeGroup:  make(map[azureRef]cloudprovider.NodeGroup),
-		unownedInstances:     make(map[azureRef]bool),
-	}
-
-	if err := cache.regenerate(); err != nil {
-		klog.Errorf("Error while regenerating Azure cache: %v", err)
-	}
-
-	return cache, nil
-}
-
-func (m *azureCache) getVirtualMachines() map[string][]compute.VirtualMachine {
-	m.mutex.Lock()
-	defer m.mutex.Unlock()
-
-	return m.virtualMachines
-}
-
-func (m *azureCache) getScaleSets() map[string]compute.VirtualMachineScaleSet {
-	m.mutex.Lock()
-	defer m.mutex.Unlock()
-
-	return m.scaleSets
-}
-
-// Cleanup closes the channel to signal the go routine to stop that is handling the cache
-func (m *azureCache) Cleanup() {
-	close(m.interrupt)
-}
-
-func (m *azureCache) regenerate() error {
-	err := m.fetchAzureResources()
-	if err != nil {
-		return err
-	}
-
-	// Regenerate instance to node groups mapping.
-	newInstanceToNodeGroupCache := make(map[azureRef]cloudprovider.NodeGroup)
-	for _, ng := range m.registeredNodeGroups {
-		klog.V(4).Infof("regenerate: finding nodes for node group %s", ng.Id())
-		instances, err := ng.Nodes()
-		if err != nil {
-			return err
-		}
-		klog.V(4).Infof("regenerate: found nodes for node group %s: %+v", ng.Id(), instances)
-
-		for _, instance := range instances {
-			ref := azureRef{Name: instance.Id}
-			newInstanceToNodeGroupCache[ref] = ng
-		}
-	}
-
-	m.mutex.Lock()
-	defer m.mutex.Unlock()
-
-	m.instanceToNodeGroup = newInstanceToNodeGroupCache
-
-	// Reset unowned instances cache.
-	m.unownedInstances = make(map[azureRef]bool)
-
-	return nil
-}
-
-func (m *azureCache) fetchAzureResources() error {
-	m.mutex.Lock()
-	defer m.mutex.Unlock()
-
-	switch m.vmType {
-	case vmTypeVMSS:
-		// List all VMSS in the RG.
-		vmssResult, err := m.fetchScaleSets()
-		if err == nil {
-			m.scaleSets = vmssResult
-		} else {
-			return err
-		}
-	case vmTypeStandard, vmTypeAKS:
-		// List all VMs in the RG.
-		vmResult, err := m.fetchVirtualMachines()
-		if err == nil {
-			m.virtualMachines = vmResult
-		} else {
-			return err
-		}
-	}
-
-	return nil
-}
-
-// fetchVirtualMachines returns the updated list of virtual machines in the config resource group using the Azure API.
-func (m *azureCache) fetchVirtualMachines() (map[string][]compute.VirtualMachine, error) {
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-
-	result, err := m.azClient.virtualMachinesClient.List(ctx, m.resourceGroup)
-	if err != nil {
-		klog.Errorf("VirtualMachinesClient.List in resource group %q failed: %v", m.resourceGroup, err)
-		return nil, err.Error()
-	}
-
-	instances := make(map[string][]compute.VirtualMachine)
-	for _, instance := range result {
-		if instance.Tags == nil {
-			continue
-		}
-
-		tags := instance.Tags
-		vmPoolName := tags["poolName"]
-		if vmPoolName == nil {
-			continue
-		}
-
-		instances[to.String(vmPoolName)] = append(instances[to.String(vmPoolName)], instance)
-	}
-	return instances, nil
-}
-
-// fetchScaleSets returns the updated list of scale sets in the config resource group using the Azure API.
-func (m *azureCache) fetchScaleSets() (map[string]compute.VirtualMachineScaleSet, error) {
-	ctx, cancel := getContextWithTimeout(vmssContextTimeout)
-	defer cancel()
-
-	result, err := m.azClient.virtualMachineScaleSetsClient.List(ctx, m.resourceGroup)
-	if err != nil {
-		klog.Errorf("VirtualMachineScaleSetsClient.List in resource group %q failed: %v", m.resourceGroup, err)
-		return nil, err.Error()
-	}
-
-	sets := make(map[string]compute.VirtualMachineScaleSet)
-	for _, vmss := range result {
-		sets[*vmss.Name] = vmss
-	}
-	return sets, nil
-}
-
-// Register registers a node group if it hasn't been registered.
-func (m *azureCache) Register(nodeGroup cloudprovider.NodeGroup) bool {
-	m.mutex.Lock()
-	defer m.mutex.Unlock()
-
-	for i := range m.registeredNodeGroups {
-		if existing := m.registeredNodeGroups[i]; strings.EqualFold(existing.Id(), nodeGroup.Id()) {
-			if existing.MinSize() == nodeGroup.MinSize() && existing.MaxSize() == nodeGroup.MaxSize() {
-				// Node group is already registered and min/max size haven't changed, no action required.
-				return false
-			}
-
-			m.registeredNodeGroups[i] = nodeGroup
-			klog.V(4).Infof("Node group %q updated", nodeGroup.Id())
-			m.invalidateUnownedInstanceCache()
-			return true
-		}
-	}
-
-	klog.V(4).Infof("Registering Node Group %q", nodeGroup.Id())
-	m.registeredNodeGroups = append(m.registeredNodeGroups, nodeGroup)
-	m.invalidateUnownedInstanceCache()
-	return true
-}
-
-func (m *azureCache) invalidateUnownedInstanceCache() {
-	klog.V(4).Info("Invalidating unowned instance cache")
-	m.unownedInstances = make(map[azureRef]bool)
-}
-
-// Unregister node group. Returns true if the node group was unregistered.
-func (m *azureCache) Unregister(nodeGroup cloudprovider.NodeGroup) bool {
-	m.mutex.Lock()
-	defer m.mutex.Unlock()
-
-	updated := make([]cloudprovider.NodeGroup, 0, len(m.registeredNodeGroups))
-	changed := false
-	for _, existing := range m.registeredNodeGroups {
-		if strings.EqualFold(existing.Id(), nodeGroup.Id()) {
-			klog.V(1).Infof("Unregistered node group %s", nodeGroup.Id())
-			changed = true
-			continue
-		}
-		updated = append(updated, existing)
-	}
-	m.registeredNodeGroups = updated
-	return changed
-}
-
-func (m *azureCache) getRegisteredNodeGroups() []cloudprovider.NodeGroup {
-	m.mutex.Lock()
-	defer m.mutex.Unlock()
-
-	return m.registeredNodeGroups
-}
-
-// FindForInstance returns node group of the given Instance
-func (m *azureCache) FindForInstance(instance *azureRef, vmType string) (cloudprovider.NodeGroup, error) {
-	m.mutex.Lock()
-	defer m.mutex.Unlock()
-
-	klog.V(4).Infof("FindForInstance: starts, ref: %s", instance.Name)
-	resourceID, err := convertResourceGroupNameToLower(instance.Name)
-	klog.V(4).Infof("FindForInstance: resourceID: %s", resourceID)
-	if err != nil {
-		return nil, err
-	}
-	inst := azureRef{Name: resourceID}
-	if m.unownedInstances[inst] {
-		// We already know we don't own this instance. Return early and avoid
-		// additional calls.
-		klog.V(4).Infof("FindForInstance: Couldn't find NodeGroup of instance %q", inst)
-		return nil, nil
-	}
-
-	if vmType == vmTypeVMSS {
-		// Omit virtual machines not managed by vmss.
-		if ok := virtualMachineRE.Match([]byte(inst.Name)); ok {
-			klog.V(3).Infof("Instance %q is not managed by vmss, omit it in autoscaler", instance.Name)
-			m.unownedInstances[inst] = true
-			return nil, nil
-		}
-	}
-
-	if vmType == vmTypeStandard {
-		// Omit virtual machines with providerID not in Azure resource ID format.
-		if ok := virtualMachineRE.Match([]byte(inst.Name)); !ok {
-			klog.V(3).Infof("Instance %q is not in Azure resource ID format, omit it in autoscaler", instance.Name)
-			m.unownedInstances[inst] = true
-			return nil, nil
-		}
-	}
-
-	// Look up caches for the instance.
-	klog.V(6).Infof("FindForInstance: attempting to retrieve instance %v from cache", m.instanceToNodeGroup)
-	if nodeGroup := m.getInstanceFromCache(inst.Name); nodeGroup != nil {
-		klog.V(4).Infof("FindForInstance: found node group %q in cache", nodeGroup.Id())
-		return nodeGroup, nil
-	}
-	klog.V(4).Infof("FindForInstance: Couldn't find node group of instance %q", inst)
-	return nil, nil
-}
-
-// getInstanceFromCache gets the node group from cache. Returns nil if not found.
-// Should be called with lock.
-func (m *azureCache) getInstanceFromCache(providerID string) cloudprovider.NodeGroup {
-	for instanceID, nodeGroup := range m.instanceToNodeGroup {
-		if strings.EqualFold(instanceID.GetKey(), providerID) {
-			return nodeGroup
-		}
-	}
-
-	return nil
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_cache_test.go b/cluster-autoscaler/cloudprovider/azure/azure_cache_test.go
deleted file mode 100644
index 2b87ab938..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_cache_test.go
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
-Copyright 2020 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"testing"
-
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-
-	"github.com/stretchr/testify/assert"
-)
-
-func TestRegister(t *testing.T) {
-	provider := newTestProvider(t)
-	ss := newTestScaleSet(provider.azureManager, "ss")
-
-	ac := provider.azureManager.azureCache
-	ac.registeredNodeGroups = []cloudprovider.NodeGroup{ss}
-
-	isSuccess := ac.Register(ss)
-	assert.False(t, isSuccess)
-
-	ss1 := newTestScaleSet(provider.azureManager, "ss")
-	ss1.minSize = 2
-	isSuccess = ac.Register(ss1)
-	assert.True(t, isSuccess)
-}
-
-func TestUnRegister(t *testing.T) {
-	provider := newTestProvider(t)
-	ss := newTestScaleSet(provider.azureManager, "ss")
-	ss1 := newTestScaleSet(provider.azureManager, "ss1")
-
-	ac := provider.azureManager.azureCache
-	ac.registeredNodeGroups = []cloudprovider.NodeGroup{ss, ss1}
-
-	isSuccess := ac.Unregister(ss)
-	assert.True(t, isSuccess)
-	assert.Equal(t, 1, len(ac.registeredNodeGroups))
-}
-
-func TestFindForInstance(t *testing.T) {
-	provider := newTestProvider(t)
-	ac := provider.azureManager.azureCache
-
-	inst := azureRef{Name: "/subscriptions/sub/resourceGroups/rg/providers/foo"}
-	ac.unownedInstances = make(map[azureRef]bool)
-	ac.unownedInstances[inst] = true
-	nodeGroup, err := ac.FindForInstance(&inst, vmTypeVMSS)
-	assert.Nil(t, nodeGroup)
-	assert.NoError(t, err)
-
-	ac.unownedInstances[inst] = false
-	nodeGroup, err = ac.FindForInstance(&inst, vmTypeStandard)
-	assert.Nil(t, nodeGroup)
-	assert.NoError(t, err)
-	assert.True(t, ac.unownedInstances[inst])
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_client.go b/cluster-autoscaler/cloudprovider/azure/azure_client.go
deleted file mode 100644
index 14160c06a..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_client.go
+++ /dev/null
@@ -1,259 +0,0 @@
-/*
-Copyright 2018 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"context"
-	"fmt"
-	"io/ioutil"
-	"net/http"
-	"time"
-
-	"github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2017-05-10/resources"
-	"github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage"
-	"github.com/Azure/go-autorest/autorest"
-	"github.com/Azure/go-autorest/autorest/adal"
-	"github.com/Azure/go-autorest/autorest/azure"
-
-	klog "k8s.io/klog/v2"
-	"k8s.io/legacy-cloud-providers/azure/clients/containerserviceclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/diskclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/interfaceclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/vmclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/vmssclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/vmssvmclient"
-)
-
-// DeploymentsClient defines needed functions for azure network.DeploymentsClient.
-type DeploymentsClient interface {
-	Get(ctx context.Context, resourceGroupName string, deploymentName string) (result resources.DeploymentExtended, err error)
-	List(ctx context.Context, resourceGroupName string, filter string, top *int32) (result []resources.DeploymentExtended, err error)
-	ExportTemplate(ctx context.Context, resourceGroupName string, deploymentName string) (result resources.DeploymentExportResult, err error)
-	CreateOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters resources.Deployment) (resp *http.Response, err error)
-	Delete(ctx context.Context, resourceGroupName string, deploymentName string) (resp *http.Response, err error)
-}
-
-type azDeploymentsClient struct {
-	client resources.DeploymentsClient
-}
-
-func newAzDeploymentsClient(subscriptionID, endpoint string, servicePrincipalToken *adal.ServicePrincipalToken) *azDeploymentsClient {
-	deploymentsClient := resources.NewDeploymentsClient(subscriptionID)
-	deploymentsClient.BaseURI = endpoint
-	deploymentsClient.Authorizer = autorest.NewBearerAuthorizer(servicePrincipalToken)
-	deploymentsClient.PollingDelay = 5 * time.Second
-	configureUserAgent(&deploymentsClient.Client)
-
-	return &azDeploymentsClient{
-		client: deploymentsClient,
-	}
-}
-
-func (az *azDeploymentsClient) Get(ctx context.Context, resourceGroupName string, deploymentName string) (result resources.DeploymentExtended, err error) {
-	klog.V(10).Infof("azDeploymentsClient.Get(%q,%q): start", resourceGroupName, deploymentName)
-	defer func() {
-		klog.V(10).Infof("azDeploymentsClient.Get(%q,%q): end", resourceGroupName, deploymentName)
-	}()
-
-	return az.client.Get(ctx, resourceGroupName, deploymentName)
-}
-
-func (az *azDeploymentsClient) ExportTemplate(ctx context.Context, resourceGroupName string, deploymentName string) (result resources.DeploymentExportResult, err error) {
-	klog.V(10).Infof("azDeploymentsClient.ExportTemplate(%q,%q): start", resourceGroupName, deploymentName)
-	defer func() {
-		klog.V(10).Infof("azDeploymentsClient.ExportTemplate(%q,%q): end", resourceGroupName, deploymentName)
-	}()
-
-	return az.client.ExportTemplate(ctx, resourceGroupName, deploymentName)
-}
-
-func (az *azDeploymentsClient) CreateOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters resources.Deployment) (resp *http.Response, err error) {
-	klog.V(10).Infof("azDeploymentsClient.CreateOrUpdate(%q,%q): start", resourceGroupName, deploymentName)
-	defer func() {
-		klog.V(10).Infof("azDeploymentsClient.CreateOrUpdate(%q,%q): end", resourceGroupName, deploymentName)
-	}()
-
-	future, err := az.client.CreateOrUpdate(ctx, resourceGroupName, deploymentName, parameters)
-	if err != nil {
-		return future.Response(), err
-	}
-
-	err = future.WaitForCompletionRef(ctx, az.client.Client)
-	return future.Response(), err
-}
-
-func (az *azDeploymentsClient) List(ctx context.Context, resourceGroupName, filter string, top *int32) (result []resources.DeploymentExtended, err error) {
-	klog.V(10).Infof("azDeploymentsClient.List(%q): start", resourceGroupName)
-	defer func() {
-		klog.V(10).Infof("azDeploymentsClient.List(%q): end", resourceGroupName)
-	}()
-
-	iterator, err := az.client.ListByResourceGroupComplete(ctx, resourceGroupName, filter, top)
-	if err != nil {
-		return nil, err
-	}
-
-	result = make([]resources.DeploymentExtended, 0)
-	for ; iterator.NotDone(); err = iterator.Next() {
-		if err != nil {
-			return nil, err
-		}
-
-		result = append(result, iterator.Value())
-	}
-
-	return result, err
-}
-
-func (az *azDeploymentsClient) Delete(ctx context.Context, resourceGroupName, deploymentName string) (resp *http.Response, err error) {
-	klog.V(10).Infof("azDeploymentsClient.Delete(%q,%q): start", resourceGroupName, deploymentName)
-	defer func() {
-		klog.V(10).Infof("azDeploymentsClient.Delete(%q,%q): end", resourceGroupName, deploymentName)
-	}()
-
-	future, err := az.client.Delete(ctx, resourceGroupName, deploymentName)
-	if err != nil {
-		return future.Response(), err
-	}
-
-	err = future.WaitForCompletionRef(ctx, az.client.Client)
-	return future.Response(), err
-}
-
-type azAccountsClient struct {
-	client storage.AccountsClient
-}
-
-type azClient struct {
-	virtualMachineScaleSetsClient   vmssclient.Interface
-	virtualMachineScaleSetVMsClient vmssvmclient.Interface
-	virtualMachinesClient           vmclient.Interface
-	deploymentsClient               DeploymentsClient
-	interfacesClient                interfaceclient.Interface
-	disksClient                     diskclient.Interface
-	storageAccountsClient           storageaccountclient.Interface
-	managedKubernetesServicesClient containerserviceclient.Interface
-}
-
-// newServicePrincipalTokenFromCredentials creates a new ServicePrincipalToken using values of the
-// passed credentials map.
-func newServicePrincipalTokenFromCredentials(config *Config, env *azure.Environment) (*adal.ServicePrincipalToken, error) {
-	oauthConfig, err := adal.NewOAuthConfig(env.ActiveDirectoryEndpoint, config.TenantID)
-	if err != nil {
-		return nil, fmt.Errorf("creating the OAuth config: %v", err)
-	}
-
-	if config.UseManagedIdentityExtension {
-		klog.V(2).Infoln("azure: using managed identity extension to retrieve access token")
-		msiEndpoint, err := adal.GetMSIVMEndpoint()
-		if err != nil {
-			return nil, fmt.Errorf("getting the managed service identity endpoint: %v", err)
-		}
-		if len(config.UserAssignedIdentityID) > 0 {
-			klog.V(4).Info("azure: using User Assigned MSI ID to retrieve access token")
-			return adal.NewServicePrincipalTokenFromMSIWithUserAssignedID(msiEndpoint,
-				env.ServiceManagementEndpoint,
-				config.UserAssignedIdentityID)
-		}
-		klog.V(4).Info("azure: using System Assigned MSI to retrieve access token")
-		return adal.NewServicePrincipalTokenFromMSI(
-			msiEndpoint,
-			env.ServiceManagementEndpoint)
-	}
-
-	if len(config.AADClientSecret) > 0 {
-		klog.V(2).Infoln("azure: using client_id+client_secret to retrieve access token")
-		return adal.NewServicePrincipalToken(
-			*oauthConfig,
-			config.AADClientID,
-			config.AADClientSecret,
-			env.ServiceManagementEndpoint)
-	}
-
-	if len(config.AADClientCertPath) > 0 && len(config.AADClientCertPassword) > 0 {
-		klog.V(2).Infoln("azure: using jwt client_assertion (client_cert+client_private_key) to retrieve access token")
-		certData, err := ioutil.ReadFile(config.AADClientCertPath)
-		if err != nil {
-			return nil, fmt.Errorf("reading the client certificate from file %s: %v", config.AADClientCertPath, err)
-		}
-		certificate, privateKey, err := decodePkcs12(certData, config.AADClientCertPassword)
-		if err != nil {
-			return nil, fmt.Errorf("decoding the client certificate: %v", err)
-		}
-		return adal.NewServicePrincipalTokenFromCertificate(
-			*oauthConfig,
-			config.AADClientID,
-			certificate,
-			privateKey,
-			env.ServiceManagementEndpoint)
-	}
-
-	return nil, fmt.Errorf("no credentials provided for AAD application %s", config.AADClientID)
-}
-
-func newAzClient(cfg *Config, env *azure.Environment) (*azClient, error) {
-	spt, err := newServicePrincipalTokenFromCredentials(cfg, env)
-	if err != nil {
-		return nil, err
-	}
-
-	azClientConfig := cfg.getAzureClientConfig(spt, env)
-	azClientConfig.UserAgent = getUserAgentExtension()
-
-	vmssClientConfig := azClientConfig.WithRateLimiter(cfg.VirtualMachineScaleSetRateLimit)
-	scaleSetsClient := vmssclient.New(vmssClientConfig)
-	klog.V(5).Infof("Created scale set client with authorizer: %v", scaleSetsClient)
-
-	vmssVMClientConfig := azClientConfig.WithRateLimiter(cfg.VirtualMachineScaleSetRateLimit)
-	scaleSetVMsClient := vmssvmclient.New(vmssVMClientConfig)
-	klog.V(5).Infof("Created scale set vm client with authorizer: %v", scaleSetVMsClient)
-
-	vmClientConfig := azClientConfig.WithRateLimiter(cfg.VirtualMachineRateLimit)
-	virtualMachinesClient := vmclient.New(vmClientConfig)
-	klog.V(5).Infof("Created vm client with authorizer: %v", virtualMachinesClient)
-
-	deploymentsClient := newAzDeploymentsClient(cfg.SubscriptionID, env.ResourceManagerEndpoint, spt)
-	klog.V(5).Infof("Created deployments client with authorizer: %v", deploymentsClient)
-
-	interfaceClientConfig := azClientConfig.WithRateLimiter(cfg.InterfaceRateLimit)
-	interfacesClient := interfaceclient.New(interfaceClientConfig)
-	klog.V(5).Infof("Created interfaces client with authorizer: %v", interfacesClient)
-
-	accountClientConfig := azClientConfig.WithRateLimiter(cfg.StorageAccountRateLimit)
-	storageAccountsClient := storageaccountclient.New(accountClientConfig)
-	klog.V(5).Infof("Created storage accounts client with authorizer: %v", storageAccountsClient)
-
-	diskClientConfig := azClientConfig.WithRateLimiter(cfg.DiskRateLimit)
-	disksClient := diskclient.New(diskClientConfig)
-	klog.V(5).Infof("Created disks client with authorizer: %v", disksClient)
-
-	aksClientConfig := azClientConfig.WithRateLimiter(cfg.KubernetesServiceRateLimit)
-	kubernetesServicesClient := containerserviceclient.New(aksClientConfig)
-	klog.V(5).Infof("Created kubernetes services client with authorizer: %v", kubernetesServicesClient)
-
-	return &azClient{
-		disksClient:                     disksClient,
-		interfacesClient:                interfacesClient,
-		virtualMachineScaleSetsClient:   scaleSetsClient,
-		virtualMachineScaleSetVMsClient: scaleSetVMsClient,
-		deploymentsClient:               deploymentsClient,
-		virtualMachinesClient:           virtualMachinesClient,
-		storageAccountsClient:           storageAccountsClient,
-		managedKubernetesServicesClient: kubernetesServicesClient,
-	}, nil
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_cloud_provider.go b/cluster-autoscaler/cloudprovider/azure/azure_cloud_provider.go
deleted file mode 100644
index 18ca771b7..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_cloud_provider.go
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
-Copyright 2017 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"io"
-	"os"
-
-	apiv1 "k8s.io/api/core/v1"
-	"k8s.io/apimachinery/pkg/api/resource"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-	"k8s.io/autoscaler/cluster-autoscaler/config"
-	"k8s.io/autoscaler/cluster-autoscaler/utils/errors"
-	klog "k8s.io/klog/v2"
-)
-
-const (
-	// GPULabel is the label added to nodes with GPU resource.
-	GPULabel = "accelerator"
-)
-
-var (
-	availableGPUTypes = map[string]struct{}{
-		"nvidia-tesla-k80":  {},
-		"nvidia-tesla-p100": {},
-		"nvidia-tesla-v100": {},
-	}
-)
-
-// AzureCloudProvider provides implementation of CloudProvider interface for Azure.
-type AzureCloudProvider struct {
-	azureManager    *AzureManager
-	resourceLimiter *cloudprovider.ResourceLimiter
-}
-
-// BuildAzureCloudProvider creates new AzureCloudProvider
-func BuildAzureCloudProvider(azureManager *AzureManager, resourceLimiter *cloudprovider.ResourceLimiter) (cloudprovider.CloudProvider, error) {
-	azure := &AzureCloudProvider{
-		azureManager:    azureManager,
-		resourceLimiter: resourceLimiter,
-	}
-
-	return azure, nil
-}
-
-// Cleanup stops the go routine that is handling the current view of the ASGs in the form of a cache
-func (azure *AzureCloudProvider) Cleanup() error {
-	azure.azureManager.Cleanup()
-	return nil
-}
-
-// Name returns name of the cloud provider.
-func (azure *AzureCloudProvider) Name() string {
-	return "azure"
-}
-
-// GPULabel returns the label added to nodes with GPU resource.
-func (azure *AzureCloudProvider) GPULabel() string {
-	return GPULabel
-}
-
-// GetAvailableGPUTypes return all available GPU types cloud provider supports
-func (azure *AzureCloudProvider) GetAvailableGPUTypes() map[string]struct{} {
-	return availableGPUTypes
-}
-
-// NodeGroups returns all node groups configured for this cloud provider.
-func (azure *AzureCloudProvider) NodeGroups() []cloudprovider.NodeGroup {
-	asgs := azure.azureManager.getNodeGroups()
-
-	ngs := make([]cloudprovider.NodeGroup, len(asgs))
-	for i, asg := range asgs {
-		ngs[i] = asg
-	}
-	return ngs
-}
-
-// NodeGroupForNode returns the node group for the given node.
-func (azure *AzureCloudProvider) NodeGroupForNode(node *apiv1.Node) (cloudprovider.NodeGroup, error) {
-	klog.V(6).Infof("NodeGroupForNode: starts")
-	if node.Spec.ProviderID == "" {
-		klog.V(6).Infof("Skipping the search for node group for the node '%s' because it has no spec.ProviderID", node.ObjectMeta.Name)
-		return nil, nil
-	}
-	klog.V(6).Infof("Searching for node group for the node: %s\n", node.Spec.ProviderID)
-	ref := &azureRef{
-		Name: node.Spec.ProviderID,
-	}
-
-	klog.V(6).Infof("NodeGroupForNode: ref.Name %s", ref.Name)
-	return azure.azureManager.GetNodeGroupForInstance(ref)
-}
-
-// Pricing returns pricing model for this cloud provider or error if not available.
-func (azure *AzureCloudProvider) Pricing() (cloudprovider.PricingModel, errors.AutoscalerError) {
-	return nil, cloudprovider.ErrNotImplemented
-}
-
-// GetAvailableMachineTypes get all machine types that can be requested from the cloud provider.
-func (azure *AzureCloudProvider) GetAvailableMachineTypes() ([]string, error) {
-	return []string{}, nil
-}
-
-// NewNodeGroup builds a theoretical node group based on the node definition provided. The node group is not automatically
-// created on the cloud provider side. The node group is not returned by NodeGroups() until it is created.
-func (azure *AzureCloudProvider) NewNodeGroup(machineType string, labels map[string]string, systemLabels map[string]string,
-	taints []apiv1.Taint, extraResources map[string]resource.Quantity) (cloudprovider.NodeGroup, error) {
-	return nil, cloudprovider.ErrNotImplemented
-}
-
-// GetResourceLimiter returns struct containing limits (max, min) for resources (cores, memory etc.).
-func (azure *AzureCloudProvider) GetResourceLimiter() (*cloudprovider.ResourceLimiter, error) {
-	return azure.resourceLimiter, nil
-}
-
-// Refresh is called before every main loop and can be used to dynamically update cloud provider state.
-// In particular the list of node groups returned by NodeGroups can change as a result of CloudProvider.Refresh().
-func (azure *AzureCloudProvider) Refresh() error {
-	return azure.azureManager.Refresh()
-}
-
-// azureRef contains a reference to some entity in Azure world.
-type azureRef struct {
-	Name string
-}
-
-// GetKey returns key of the given azure reference.
-func (m *azureRef) GetKey() string {
-	return m.Name
-}
-
-// String is represented by calling GetKey()
-func (m *azureRef) String() string {
-	return m.GetKey()
-}
-
-// BuildAzure builds Azure cloud provider, manager etc.
-func BuildAzure(opts config.AutoscalingOptions, do cloudprovider.NodeGroupDiscoveryOptions, rl *cloudprovider.ResourceLimiter) cloudprovider.CloudProvider {
-	var config io.ReadCloser
-	if opts.CloudConfig != "" {
-		klog.Infof("Creating Azure Manager using cloud-config file: %v", opts.CloudConfig)
-		var err error
-		config, err = os.Open(opts.CloudConfig)
-		if err != nil {
-			klog.Fatalf("Couldn't open cloud provider configuration %s: %#v", opts.CloudConfig, err)
-		}
-		defer config.Close()
-	} else {
-		klog.Info("Creating Azure Manager with default configuration.")
-	}
-	manager, err := CreateAzureManager(config, do)
-	if err != nil {
-		klog.Fatalf("Failed to create Azure Manager: %v", err)
-	}
-	provider, err := BuildAzureCloudProvider(manager, rl)
-	if err != nil {
-		klog.Fatalf("Failed to create Azure cloud provider: %v", err)
-	}
-	return provider
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_cloud_provider_test.go b/cluster-autoscaler/cloudprovider/azure/azure_cloud_provider_test.go
deleted file mode 100644
index e87fd0cdc..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_cloud_provider_test.go
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
-Copyright 2017 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"fmt"
-	"github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2017-05-10/resources"
-	"github.com/Azure/go-autorest/autorest/to"
-	"testing"
-
-	apiv1 "k8s.io/api/core/v1"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-	"k8s.io/legacy-cloud-providers/azure/clients/vmssclient/mockvmssclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/vmssvmclient/mockvmssvmclient"
-
-	"github.com/Azure/go-autorest/autorest/azure"
-	"github.com/golang/mock/gomock"
-	"github.com/stretchr/testify/assert"
-)
-
-func newTestAzureManager(t *testing.T) *AzureManager {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	expectedScaleSets := newTestVMSSList(3, "test-vmss", "eastus")
-	expectedVMSSVMs := newTestVMSSVMList(3)
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), "rg").Return(expectedScaleSets, nil).AnyTimes()
-	mockVMSSVMClient := mockvmssvmclient.NewMockInterface(ctrl)
-	mockVMSSVMClient.EXPECT().List(gomock.Any(), "rg", "test-vmss", gomock.Any()).Return(expectedVMSSVMs, nil).AnyTimes()
-
-	manager := &AzureManager{
-		env:                  azure.PublicCloud,
-		explicitlyConfigured: make(map[string]bool),
-		config: &Config{
-			ResourceGroup:       "rg",
-			VMType:              vmTypeVMSS,
-			MaxDeploymentsCount: 2,
-			Deployment:          "deployment",
-		},
-		azClient: &azClient{
-			virtualMachineScaleSetsClient:   mockVMSSClient,
-			virtualMachineScaleSetVMsClient: mockVMSSVMClient,
-			deploymentsClient: &DeploymentsClientMock{
-				FakeStore: map[string]resources.DeploymentExtended{
-					"deployment": {
-						Name: to.StringPtr("deployment"),
-						Properties: &resources.DeploymentPropertiesExtended{Template: map[string]interface{}{
-							resourcesFieldName: []interface{}{
-								map[string]interface{}{
-									typeFieldName: nsgResourceType,
-								},
-								map[string]interface{}{
-									typeFieldName: rtResourceType,
-								},
-							},
-						}},
-					},
-				},
-			},
-		},
-	}
-
-	cache, error := newAzureCache(manager.azClient, refreshInterval, manager.config.ResourceGroup, vmTypeVMSS)
-	assert.NoError(t, error)
-
-	manager.azureCache = cache
-	return manager
-}
-
-func newTestProvider(t *testing.T) *AzureCloudProvider {
-	manager := newTestAzureManager(t)
-	resourceLimiter := cloudprovider.NewResourceLimiter(
-		map[string]int64{cloudprovider.ResourceNameCores: 1, cloudprovider.ResourceNameMemory: 10000000},
-		map[string]int64{cloudprovider.ResourceNameCores: 10, cloudprovider.ResourceNameMemory: 100000000})
-
-	return &AzureCloudProvider{
-		azureManager:    manager,
-		resourceLimiter: resourceLimiter,
-	}
-}
-
-func TestBuildAzureCloudProvider(t *testing.T) {
-	resourceLimiter := cloudprovider.NewResourceLimiter(
-		map[string]int64{cloudprovider.ResourceNameCores: 1, cloudprovider.ResourceNameMemory: 10000000},
-		map[string]int64{cloudprovider.ResourceNameCores: 10, cloudprovider.ResourceNameMemory: 100000000})
-	m := newTestAzureManager(t)
-	_, err := BuildAzureCloudProvider(m, resourceLimiter)
-	assert.NoError(t, err)
-}
-
-func TestName(t *testing.T) {
-	provider := newTestProvider(t)
-	assert.Equal(t, provider.Name(), "azure")
-}
-
-func TestNodeGroups(t *testing.T) {
-	provider := newTestProvider(t)
-	assert.Equal(t, len(provider.NodeGroups()), 0)
-
-	registered := provider.azureManager.RegisterNodeGroup(
-		newTestScaleSet(provider.azureManager, "test-asg"))
-	assert.True(t, registered)
-	assert.Equal(t, len(provider.NodeGroups()), 1)
-}
-
-func TestNodeGroupForNode(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	expectedVMSSVMs := newTestVMSSVMList(3)
-	expectedScaleSets := newTestVMSSList(3, "test-asg", "eastus")
-
-	provider := newTestProvider(t)
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), provider.azureManager.config.ResourceGroup).Return(expectedScaleSets, nil)
-	provider.azureManager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	mockVMSSVMClient := mockvmssvmclient.NewMockInterface(ctrl)
-	mockVMSSVMClient.EXPECT().List(gomock.Any(), provider.azureManager.config.ResourceGroup, "test-asg", gomock.Any()).Return(expectedVMSSVMs, nil).AnyTimes()
-	provider.azureManager.azClient.virtualMachineScaleSetVMsClient = mockVMSSVMClient
-
-	registered := provider.azureManager.RegisterNodeGroup(
-		newTestScaleSet(provider.azureManager, "test-asg"))
-	provider.azureManager.explicitlyConfigured["test-asg"] = true
-	assert.True(t, registered)
-	assert.Equal(t, len(provider.NodeGroups()), 1)
-
-	node := &apiv1.Node{
-		Spec: apiv1.NodeSpec{
-			ProviderID: "azure://" + fmt.Sprintf(fakeVirtualMachineScaleSetVMID, 0),
-		},
-	}
-	// refresh cache
-	provider.azureManager.forceRefresh()
-	group, err := provider.NodeGroupForNode(node)
-	assert.NoError(t, err)
-	assert.NotNil(t, group, "Group should not be nil")
-	assert.Equal(t, group.Id(), "test-asg")
-	assert.Equal(t, group.MinSize(), 1)
-	assert.Equal(t, group.MaxSize(), 5)
-
-	// test node in cluster that is not in a group managed by cluster autoscaler
-	nodeNotInGroup := &apiv1.Node{
-		Spec: apiv1.NodeSpec{
-			ProviderID: "azure:///subscriptions/subscripion/resourceGroups/test-resource-group/providers/Microsoft.Compute/virtualMachines/test-instance-id-not-in-group",
-		},
-	}
-	group, err = provider.NodeGroupForNode(nodeNotInGroup)
-	assert.NoError(t, err)
-	assert.Nil(t, group)
-}
-
-func TestNodeGroupForNodeWithNoProviderId(t *testing.T) {
-	provider := newTestProvider(t)
-	registered := provider.azureManager.RegisterNodeGroup(
-		newTestScaleSet(provider.azureManager, "test-asg"))
-	assert.True(t, registered)
-	assert.Equal(t, len(provider.NodeGroups()), 1)
-
-	node := &apiv1.Node{
-		Spec: apiv1.NodeSpec{
-			ProviderID: "",
-		},
-	}
-	group, err := provider.NodeGroupForNode(node)
-
-	assert.NoError(t, err)
-	assert.Equal(t, group, nil)
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_config.go b/cluster-autoscaler/cloudprovider/azure/azure_config.go
deleted file mode 100644
index 1a8dac26d..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_config.go
+++ /dev/null
@@ -1,476 +0,0 @@
-/*
-Copyright 2020 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"encoding/json"
-	"fmt"
-	"github.com/Azure/go-autorest/autorest"
-	"github.com/Azure/go-autorest/autorest/adal"
-	"github.com/Azure/go-autorest/autorest/azure"
-	"io"
-	"io/ioutil"
-	"k8s.io/klog/v2"
-	providerazure "k8s.io/legacy-cloud-providers/azure"
-	azclients "k8s.io/legacy-cloud-providers/azure/clients"
-	"k8s.io/legacy-cloud-providers/azure/retry"
-	"os"
-	"strconv"
-	"strings"
-	"time"
-)
-
-const (
-	// The path of deployment parameters for standard vm.
-	deploymentParametersPath = "/var/lib/azure/azuredeploy.parameters.json"
-
-	metadataURL = "http://169.254.169.254/metadata/instance"
-
-	// backoff
-	backoffRetriesDefault  = 6
-	backoffExponentDefault = 1.5
-	backoffDurationDefault = 5 // in seconds
-	backoffJitterDefault   = 1.0
-
-	// rate limit
-	rateLimitQPSDefault         float32 = 1.0
-	rateLimitBucketDefault              = 5
-	rateLimitReadQPSEnvVar              = "RATE_LIMIT_READ_QPS"
-	rateLimitReadBucketsEnvVar          = "RATE_LIMIT_READ_BUCKETS"
-	rateLimitWriteQPSEnvVar             = "RATE_LIMIT_WRITE_QPS"
-	rateLimitWriteBucketsEnvVar         = "RATE_LIMIT_WRITE_BUCKETS"
-)
-
-// CloudProviderRateLimitConfig indicates the rate limit config for each clients.
-type CloudProviderRateLimitConfig struct {
-	// The default rate limit config options.
-	azclients.RateLimitConfig
-
-	// Rate limit config for each clients. Values would override default settings above.
-	InterfaceRateLimit              *azclients.RateLimitConfig `json:"interfaceRateLimit,omitempty" yaml:"interfaceRateLimit,omitempty"`
-	VirtualMachineRateLimit         *azclients.RateLimitConfig `json:"virtualMachineRateLimit,omitempty" yaml:"virtualMachineRateLimit,omitempty"`
-	StorageAccountRateLimit         *azclients.RateLimitConfig `json:"storageAccountRateLimit,omitempty" yaml:"storageAccountRateLimit,omitempty"`
-	DiskRateLimit                   *azclients.RateLimitConfig `json:"diskRateLimit,omitempty" yaml:"diskRateLimit,omitempty"`
-	VirtualMachineScaleSetRateLimit *azclients.RateLimitConfig `json:"virtualMachineScaleSetRateLimit,omitempty" yaml:"virtualMachineScaleSetRateLimit,omitempty"`
-	KubernetesServiceRateLimit      *azclients.RateLimitConfig `json:"kubernetesServiceRateLimit,omitempty" yaml:"kubernetesServiceRateLimit,omitempty"`
-}
-
-// Config holds the configuration parsed from the --cloud-config flag
-type Config struct {
-	CloudProviderRateLimitConfig
-
-	Cloud          string `json:"cloud" yaml:"cloud"`
-	Location       string `json:"location" yaml:"location"`
-	TenantID       string `json:"tenantId" yaml:"tenantId"`
-	SubscriptionID string `json:"subscriptionId" yaml:"subscriptionId"`
-	ResourceGroup  string `json:"resourceGroup" yaml:"resourceGroup"`
-	VMType         string `json:"vmType" yaml:"vmType"`
-
-	AADClientID                 string `json:"aadClientId" yaml:"aadClientId"`
-	AADClientSecret             string `json:"aadClientSecret" yaml:"aadClientSecret"`
-	AADClientCertPath           string `json:"aadClientCertPath" yaml:"aadClientCertPath"`
-	AADClientCertPassword       string `json:"aadClientCertPassword" yaml:"aadClientCertPassword"`
-	UseManagedIdentityExtension bool   `json:"useManagedIdentityExtension" yaml:"useManagedIdentityExtension"`
-	UserAssignedIdentityID      string `json:"userAssignedIdentityID" yaml:"userAssignedIdentityID"`
-
-	// Configs only for standard vmType (agent pools).
-	Deployment           string                 `json:"deployment" yaml:"deployment"`
-	DeploymentParameters map[string]interface{} `json:"deploymentParameters" yaml:"deploymentParameters"`
-
-	//Configs only for AKS
-	ClusterName string `json:"clusterName" yaml:"clusterName"`
-	//Config only for AKS
-	NodeResourceGroup string `json:"nodeResourceGroup" yaml:"nodeResourceGroup"`
-
-	// VMSS metadata cache TTL in seconds, only applies for vmss type
-	VmssCacheTTL int64 `json:"vmssCacheTTL" yaml:"vmssCacheTTL"`
-
-	// VMSS instances cache TTL in seconds, only applies for vmss type
-	VmssVmsCacheTTL int64 `json:"vmssVmsCacheTTL" yaml:"vmssVmsCacheTTL"`
-
-	// Jitter in seconds subtracted from the VMSS cache TTL before the first refresh
-	VmssVmsCacheJitter int `json:"vmssVmsCacheJitter" yaml:"vmssVmsCacheJitter"`
-
-	// number of latest deployments that will not be deleted
-	MaxDeploymentsCount int64 `json:"maxDeploymentsCount" yaml:"maxDeploymentsCount"`
-
-	// Enable exponential backoff to manage resource request retries
-	CloudProviderBackoff         bool    `json:"cloudProviderBackoff,omitempty" yaml:"cloudProviderBackoff,omitempty"`
-	CloudProviderBackoffRetries  int     `json:"cloudProviderBackoffRetries,omitempty" yaml:"cloudProviderBackoffRetries,omitempty"`
-	CloudProviderBackoffExponent float64 `json:"cloudProviderBackoffExponent,omitempty" yaml:"cloudProviderBackoffExponent,omitempty"`
-	CloudProviderBackoffDuration int     `json:"cloudProviderBackoffDuration,omitempty" yaml:"cloudProviderBackoffDuration,omitempty"`
-	CloudProviderBackoffJitter   float64 `json:"cloudProviderBackoffJitter,omitempty" yaml:"cloudProviderBackoffJitter,omitempty"`
-}
-
-// BuildAzureConfig returns a Config object for the Azure clients
-func BuildAzureConfig(configReader io.Reader) (*Config, error) {
-	var err error
-	cfg := &Config{}
-
-	if configReader != nil {
-		body, err := ioutil.ReadAll(configReader)
-		if err != nil {
-			return nil, fmt.Errorf("failed to read config: %v", err)
-		}
-		err = json.Unmarshal(body, cfg)
-		if err != nil {
-			return nil, fmt.Errorf("failed to unmarshal config body: %v", err)
-		}
-	} else {
-		cfg.Cloud = os.Getenv("ARM_CLOUD")
-		cfg.Location = os.Getenv("LOCATION")
-		cfg.ResourceGroup = os.Getenv("ARM_RESOURCE_GROUP")
-		cfg.TenantID = os.Getenv("ARM_TENANT_ID")
-		cfg.AADClientID = os.Getenv("ARM_CLIENT_ID")
-		cfg.AADClientSecret = os.Getenv("ARM_CLIENT_SECRET")
-		cfg.VMType = strings.ToLower(os.Getenv("ARM_VM_TYPE"))
-		cfg.AADClientCertPath = os.Getenv("ARM_CLIENT_CERT_PATH")
-		cfg.AADClientCertPassword = os.Getenv("ARM_CLIENT_CERT_PASSWORD")
-		cfg.Deployment = os.Getenv("ARM_DEPLOYMENT")
-		cfg.ClusterName = os.Getenv("AZURE_CLUSTER_NAME")
-		cfg.NodeResourceGroup = os.Getenv("AZURE_NODE_RESOURCE_GROUP")
-
-		subscriptionID, err := getSubscriptionIdFromInstanceMetadata()
-		if err != nil {
-			return nil, err
-		}
-		cfg.SubscriptionID = subscriptionID
-
-		useManagedIdentityExtensionFromEnv := os.Getenv("ARM_USE_MANAGED_IDENTITY_EXTENSION")
-		if len(useManagedIdentityExtensionFromEnv) > 0 {
-			cfg.UseManagedIdentityExtension, err = strconv.ParseBool(useManagedIdentityExtensionFromEnv)
-			if err != nil {
-				return nil, err
-			}
-		}
-
-		userAssignedIdentityIDFromEnv := os.Getenv("ARM_USER_ASSIGNED_IDENTITY_ID")
-		if userAssignedIdentityIDFromEnv != "" {
-			cfg.UserAssignedIdentityID = userAssignedIdentityIDFromEnv
-		}
-
-		if vmssCacheTTL := os.Getenv("AZURE_VMSS_CACHE_TTL"); vmssCacheTTL != "" {
-			cfg.VmssCacheTTL, err = strconv.ParseInt(vmssCacheTTL, 10, 0)
-			if err != nil {
-				return nil, fmt.Errorf("failed to parse AZURE_VMSS_CACHE_TTL %q: %v", vmssCacheTTL, err)
-			}
-		}
-
-		if vmssVmsCacheTTL := os.Getenv("AZURE_VMSS_VMS_CACHE_TTL"); vmssVmsCacheTTL != "" {
-			cfg.VmssVmsCacheTTL, err = strconv.ParseInt(vmssVmsCacheTTL, 10, 0)
-			if err != nil {
-				return nil, fmt.Errorf("failed to parse AZURE_VMSS_VMS_CACHE_TTL %q: %v", vmssVmsCacheTTL, err)
-			}
-		}
-
-		if vmssVmsCacheJitter := os.Getenv("AZURE_VMSS_VMS_CACHE_JITTER"); vmssVmsCacheJitter != "" {
-			cfg.VmssVmsCacheJitter, err = strconv.Atoi(vmssVmsCacheJitter)
-			if err != nil {
-				return nil, fmt.Errorf("failed to parse AZURE_VMSS_VMS_CACHE_JITTER %q: %v", vmssVmsCacheJitter, err)
-			}
-		}
-
-		if threshold := os.Getenv("AZURE_MAX_DEPLOYMENT_COUNT"); threshold != "" {
-			cfg.MaxDeploymentsCount, err = strconv.ParseInt(threshold, 10, 0)
-			if err != nil {
-				return nil, fmt.Errorf("failed to parse AZURE_MAX_DEPLOYMENT_COUNT %q: %v", threshold, err)
-			}
-		}
-
-		if enableBackoff := os.Getenv("ENABLE_BACKOFF"); enableBackoff != "" {
-			cfg.CloudProviderBackoff, err = strconv.ParseBool(enableBackoff)
-			if err != nil {
-				return nil, fmt.Errorf("failed to parse ENABLE_BACKOFF %q: %v", enableBackoff, err)
-			}
-		}
-
-		if cfg.CloudProviderBackoff {
-			if backoffRetries := os.Getenv("BACKOFF_RETRIES"); backoffRetries != "" {
-				retries, err := strconv.ParseInt(backoffRetries, 10, 0)
-				if err != nil {
-					return nil, fmt.Errorf("failed to parse BACKOFF_RETRIES %q: %v", retries, err)
-				}
-				cfg.CloudProviderBackoffRetries = int(retries)
-			} else {
-				cfg.CloudProviderBackoffRetries = backoffRetriesDefault
-			}
-
-			if backoffExponent := os.Getenv("BACKOFF_EXPONENT"); backoffExponent != "" {
-				cfg.CloudProviderBackoffExponent, err = strconv.ParseFloat(backoffExponent, 64)
-				if err != nil {
-					return nil, fmt.Errorf("failed to parse BACKOFF_EXPONENT %q: %v", backoffExponent, err)
-				}
-			} else {
-				cfg.CloudProviderBackoffExponent = backoffExponentDefault
-			}
-
-			if backoffDuration := os.Getenv("BACKOFF_DURATION"); backoffDuration != "" {
-				duration, err := strconv.ParseInt(backoffDuration, 10, 0)
-				if err != nil {
-					return nil, fmt.Errorf("failed to parse BACKOFF_DURATION %q: %v", backoffDuration, err)
-				}
-				cfg.CloudProviderBackoffDuration = int(duration)
-			} else {
-				cfg.CloudProviderBackoffDuration = backoffDurationDefault
-			}
-
-			if backoffJitter := os.Getenv("BACKOFF_JITTER"); backoffJitter != "" {
-				cfg.CloudProviderBackoffJitter, err = strconv.ParseFloat(backoffJitter, 64)
-				if err != nil {
-					return nil, fmt.Errorf("failed to parse BACKOFF_JITTER %q: %v", backoffJitter, err)
-				}
-			} else {
-				cfg.CloudProviderBackoffJitter = backoffJitterDefault
-			}
-		}
-	}
-	cfg.TrimSpace()
-
-	if cloudProviderRateLimit := os.Getenv("CLOUD_PROVIDER_RATE_LIMIT"); cloudProviderRateLimit != "" {
-		cfg.CloudProviderRateLimit, err = strconv.ParseBool(cloudProviderRateLimit)
-		if err != nil {
-			return nil, fmt.Errorf("failed to parse CLOUD_PROVIDER_RATE_LIMIT: %q, %v", cloudProviderRateLimit, err)
-		}
-	}
-
-	err = initializeCloudProviderRateLimitConfig(&cfg.CloudProviderRateLimitConfig)
-	if err != nil {
-		return nil, err
-	}
-
-	// Defaulting vmType to vmss.
-	if cfg.VMType == "" {
-		cfg.VMType = vmTypeVMSS
-	}
-
-	// Read parameters from deploymentParametersPath if it is not set.
-	if cfg.VMType == vmTypeStandard && len(cfg.DeploymentParameters) == 0 {
-		parameters, err := readDeploymentParameters(deploymentParametersPath)
-		if err != nil {
-			klog.Errorf("readDeploymentParameters failed with error: %v", err)
-			return nil, err
-		}
-
-		cfg.DeploymentParameters = parameters
-	}
-
-	if cfg.MaxDeploymentsCount == 0 {
-		cfg.MaxDeploymentsCount = int64(defaultMaxDeploymentsCount)
-	}
-
-	if err := cfg.validate(); err != nil {
-		return nil, err
-	}
-	return cfg, nil
-}
-
-// initializeCloudProviderRateLimitConfig initializes rate limit configs.
-func initializeCloudProviderRateLimitConfig(config *CloudProviderRateLimitConfig) error {
-	if config == nil {
-		return nil
-	}
-
-	// Assign read rate limit defaults if no configuration was passed in.
-	if config.CloudProviderRateLimitQPS == 0 {
-		if rateLimitQPSFromEnv := os.Getenv(rateLimitReadQPSEnvVar); rateLimitQPSFromEnv != "" {
-			rateLimitQPS, err := strconv.ParseFloat(rateLimitQPSFromEnv, 0)
-			if err != nil {
-				return fmt.Errorf("failed to parse %s: %q, %v", rateLimitReadQPSEnvVar, rateLimitQPSFromEnv, err)
-			}
-			config.CloudProviderRateLimitQPS = float32(rateLimitQPS)
-		} else {
-			config.CloudProviderRateLimitQPS = rateLimitQPSDefault
-		}
-	}
-
-	if config.CloudProviderRateLimitBucket == 0 {
-		if rateLimitBucketFromEnv := os.Getenv(rateLimitReadBucketsEnvVar); rateLimitBucketFromEnv != "" {
-			rateLimitBucket, err := strconv.ParseInt(rateLimitBucketFromEnv, 10, 0)
-			if err != nil {
-				return fmt.Errorf("failed to parse %s: %q, %v", rateLimitReadBucketsEnvVar, rateLimitBucketFromEnv, err)
-			}
-			config.CloudProviderRateLimitBucket = int(rateLimitBucket)
-		} else {
-			config.CloudProviderRateLimitBucket = rateLimitBucketDefault
-		}
-	}
-
-	// Assign write rate limit defaults if no configuration was passed in.
-	if config.CloudProviderRateLimitQPSWrite == 0 {
-		if rateLimitQPSWriteFromEnv := os.Getenv(rateLimitWriteQPSEnvVar); rateLimitQPSWriteFromEnv != "" {
-			rateLimitQPSWrite, err := strconv.ParseFloat(rateLimitQPSWriteFromEnv, 0)
-			if err != nil {
-				return fmt.Errorf("failed to parse %s: %q, %v", rateLimitWriteQPSEnvVar, rateLimitQPSWriteFromEnv, err)
-			}
-			config.CloudProviderRateLimitQPSWrite = float32(rateLimitQPSWrite)
-		} else {
-			config.CloudProviderRateLimitQPSWrite = config.CloudProviderRateLimitQPS
-		}
-	}
-
-	if config.CloudProviderRateLimitBucketWrite == 0 {
-		if rateLimitBucketWriteFromEnv := os.Getenv(rateLimitWriteBucketsEnvVar); rateLimitBucketWriteFromEnv != "" {
-			rateLimitBucketWrite, err := strconv.ParseInt(rateLimitBucketWriteFromEnv, 10, 0)
-			if err != nil {
-				return fmt.Errorf("failed to parse %s: %q, %v", rateLimitWriteBucketsEnvVar, rateLimitBucketWriteFromEnv, err)
-			}
-			config.CloudProviderRateLimitBucketWrite = int(rateLimitBucketWrite)
-		} else {
-			config.CloudProviderRateLimitBucketWrite = config.CloudProviderRateLimitBucket
-		}
-	}
-
-	config.InterfaceRateLimit = overrideDefaultRateLimitConfig(&config.RateLimitConfig, config.InterfaceRateLimit)
-	config.VirtualMachineRateLimit = overrideDefaultRateLimitConfig(&config.RateLimitConfig, config.VirtualMachineRateLimit)
-	config.StorageAccountRateLimit = overrideDefaultRateLimitConfig(&config.RateLimitConfig, config.StorageAccountRateLimit)
-	config.DiskRateLimit = overrideDefaultRateLimitConfig(&config.RateLimitConfig, config.DiskRateLimit)
-	config.VirtualMachineScaleSetRateLimit = overrideDefaultRateLimitConfig(&config.RateLimitConfig, config.VirtualMachineScaleSetRateLimit)
-	config.KubernetesServiceRateLimit = overrideDefaultRateLimitConfig(&config.RateLimitConfig, config.KubernetesServiceRateLimit)
-
-	return nil
-}
-
-// overrideDefaultRateLimitConfig overrides the default CloudProviderRateLimitConfig.
-func overrideDefaultRateLimitConfig(defaults, config *azclients.RateLimitConfig) *azclients.RateLimitConfig {
-	// If config not set, apply defaults.
-	if config == nil {
-		return defaults
-	}
-
-	// Remain disabled if it's set explicitly.
-	if !config.CloudProviderRateLimit {
-		return &azclients.RateLimitConfig{CloudProviderRateLimit: false}
-	}
-
-	// Apply default values.
-	if config.CloudProviderRateLimitQPS == 0 {
-		config.CloudProviderRateLimitQPS = defaults.CloudProviderRateLimitQPS
-	}
-	if config.CloudProviderRateLimitBucket == 0 {
-		config.CloudProviderRateLimitBucket = defaults.CloudProviderRateLimitBucket
-	}
-	if config.CloudProviderRateLimitQPSWrite == 0 {
-		config.CloudProviderRateLimitQPSWrite = defaults.CloudProviderRateLimitQPSWrite
-	}
-	if config.CloudProviderRateLimitBucketWrite == 0 {
-		config.CloudProviderRateLimitBucketWrite = defaults.CloudProviderRateLimitBucketWrite
-	}
-
-	return config
-}
-
-func (cfg *Config) getAzureClientConfig(servicePrincipalToken *adal.ServicePrincipalToken, env *azure.Environment) *azclients.ClientConfig {
-	azClientConfig := &azclients.ClientConfig{
-		Location:                cfg.Location,
-		SubscriptionID:          cfg.SubscriptionID,
-		ResourceManagerEndpoint: env.ResourceManagerEndpoint,
-		Authorizer:              autorest.NewBearerAuthorizer(servicePrincipalToken),
-		Backoff:                 &retry.Backoff{Steps: 1},
-	}
-
-	if cfg.CloudProviderBackoff {
-		azClientConfig.Backoff = &retry.Backoff{
-			Steps:    cfg.CloudProviderBackoffRetries,
-			Factor:   cfg.CloudProviderBackoffExponent,
-			Duration: time.Duration(cfg.CloudProviderBackoffDuration) * time.Second,
-			Jitter:   cfg.CloudProviderBackoffJitter,
-		}
-	}
-
-	return azClientConfig
-}
-
-// TrimSpace removes all leading and trailing white spaces.
-func (cfg *Config) TrimSpace() {
-	cfg.Cloud = strings.TrimSpace(cfg.Cloud)
-	cfg.Location = strings.TrimSpace(cfg.Location)
-	cfg.TenantID = strings.TrimSpace(cfg.TenantID)
-	cfg.SubscriptionID = strings.TrimSpace(cfg.SubscriptionID)
-	cfg.ResourceGroup = strings.TrimSpace(cfg.ResourceGroup)
-	cfg.VMType = strings.TrimSpace(cfg.VMType)
-	cfg.AADClientID = strings.TrimSpace(cfg.AADClientID)
-	cfg.AADClientSecret = strings.TrimSpace(cfg.AADClientSecret)
-	cfg.AADClientCertPath = strings.TrimSpace(cfg.AADClientCertPath)
-	cfg.AADClientCertPassword = strings.TrimSpace(cfg.AADClientCertPassword)
-	cfg.Deployment = strings.TrimSpace(cfg.Deployment)
-	cfg.ClusterName = strings.TrimSpace(cfg.ClusterName)
-	cfg.NodeResourceGroup = strings.TrimSpace(cfg.NodeResourceGroup)
-}
-
-func (cfg *Config) validate() error {
-	if cfg.ResourceGroup == "" {
-		return fmt.Errorf("resource group not set")
-	}
-
-	if cfg.VMType == vmTypeStandard {
-		if cfg.Deployment == "" {
-			return fmt.Errorf("deployment not set")
-		}
-
-		if len(cfg.DeploymentParameters) == 0 {
-			return fmt.Errorf("deploymentParameters not set")
-		}
-	}
-
-	if cfg.VMType == vmTypeAKS {
-		// Cluster name is a mandatory param to proceed.
-		if cfg.ClusterName == "" {
-			return fmt.Errorf("cluster name not set for type %+v", cfg.VMType)
-		}
-	}
-
-	if cfg.SubscriptionID == "" {
-		return fmt.Errorf("subscription ID not set")
-	}
-
-	if cfg.UseManagedIdentityExtension {
-		return nil
-	}
-
-	if cfg.TenantID == "" {
-		return fmt.Errorf("tenant ID not set")
-	}
-
-	if cfg.AADClientID == "" {
-		return fmt.Errorf("ARM Client ID not set")
-	}
-
-	if cfg.CloudProviderBackoff && cfg.CloudProviderBackoffRetries == 0 {
-		return fmt.Errorf("Cloud provider backoff is enabled but retries are not set")
-	}
-
-	return nil
-}
-
-// getSubscriptionId reads the Subscription ID from the instance metadata.
-func getSubscriptionIdFromInstanceMetadata() (string, error) {
-	subscriptionID, present := os.LookupEnv("ARM_SUBSCRIPTION_ID")
-	if !present {
-		metadataService, err := providerazure.NewInstanceMetadataService(metadataURL)
-		if err != nil {
-			return "", err
-		}
-
-		metadata, err := metadataService.GetMetadata(0)
-		if err != nil {
-			return "", err
-		}
-
-		return metadata.Compute.SubscriptionID, nil
-	}
-	return subscriptionID, nil
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_config_test.go b/cluster-autoscaler/cloudprovider/azure/azure_config_test.go
deleted file mode 100644
index 7a04465ff..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_config_test.go
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
-Copyright 2020 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"fmt"
-	"github.com/stretchr/testify/assert"
-	azclients "k8s.io/legacy-cloud-providers/azure/clients"
-	"os"
-	"testing"
-)
-
-func TestInitializeCloudProviderRateLimitConfigWithNoConfigReturnsNoError(t *testing.T) {
-	err := initializeCloudProviderRateLimitConfig(nil)
-	assert.Nil(t, err, "err should be nil")
-}
-
-func TestInitializeCloudProviderRateLimitConfigWithNoRateLimitSettingsReturnsDefaults(t *testing.T) {
-	emptyConfig := &CloudProviderRateLimitConfig{}
-	err := initializeCloudProviderRateLimitConfig(emptyConfig)
-
-	assert.NoError(t, err)
-	assert.Equal(t, emptyConfig.CloudProviderRateLimitQPS, rateLimitQPSDefault)
-	assert.Equal(t, emptyConfig.CloudProviderRateLimitBucket, rateLimitBucketDefault)
-	assert.Equal(t, emptyConfig.CloudProviderRateLimitQPSWrite, rateLimitQPSDefault)
-	assert.Equal(t, emptyConfig.CloudProviderRateLimitBucketWrite, rateLimitBucketDefault)
-}
-
-func TestInitializeCloudProviderRateLimitConfigWithReadRateLimitSettingsFromEnv(t *testing.T) {
-	emptyConfig := &CloudProviderRateLimitConfig{}
-	var rateLimitReadQPS float32 = 3.0
-	rateLimitReadBuckets := 10
-	os.Setenv(rateLimitReadQPSEnvVar, fmt.Sprintf("%.1f", rateLimitReadQPS))
-	os.Setenv(rateLimitReadBucketsEnvVar, fmt.Sprintf("%d", rateLimitReadBuckets))
-
-	err := initializeCloudProviderRateLimitConfig(emptyConfig)
-	assert.NoError(t, err)
-	assert.Equal(t, emptyConfig.CloudProviderRateLimitQPS, rateLimitReadQPS)
-	assert.Equal(t, emptyConfig.CloudProviderRateLimitBucket, rateLimitReadBuckets)
-	assert.Equal(t, emptyConfig.CloudProviderRateLimitQPSWrite, rateLimitReadQPS)
-	assert.Equal(t, emptyConfig.CloudProviderRateLimitBucketWrite, rateLimitReadBuckets)
-
-	os.Unsetenv(rateLimitReadBucketsEnvVar)
-	os.Unsetenv(rateLimitReadQPSEnvVar)
-}
-
-func TestInitializeCloudProviderRateLimitConfigWithReadAndWriteRateLimitSettingsFromEnv(t *testing.T) {
-	emptyConfig := &CloudProviderRateLimitConfig{}
-	var rateLimitReadQPS float32 = 3.0
-	rateLimitReadBuckets := 10
-	var rateLimitWriteQPS float32 = 6.0
-	rateLimitWriteBuckets := 20
-
-	os.Setenv(rateLimitReadQPSEnvVar, fmt.Sprintf("%.1f", rateLimitReadQPS))
-	os.Setenv(rateLimitReadBucketsEnvVar, fmt.Sprintf("%d", rateLimitReadBuckets))
-	os.Setenv(rateLimitWriteQPSEnvVar, fmt.Sprintf("%.1f", rateLimitWriteQPS))
-	os.Setenv(rateLimitWriteBucketsEnvVar, fmt.Sprintf("%d", rateLimitWriteBuckets))
-
-	err := initializeCloudProviderRateLimitConfig(emptyConfig)
-
-	assert.NoError(t, err)
-	assert.Equal(t, emptyConfig.CloudProviderRateLimitQPS, rateLimitReadQPS)
-	assert.Equal(t, emptyConfig.CloudProviderRateLimitBucket, rateLimitReadBuckets)
-	assert.Equal(t, emptyConfig.CloudProviderRateLimitQPSWrite, rateLimitWriteQPS)
-	assert.Equal(t, emptyConfig.CloudProviderRateLimitBucketWrite, rateLimitWriteBuckets)
-
-	os.Unsetenv(rateLimitReadQPSEnvVar)
-	os.Unsetenv(rateLimitReadBucketsEnvVar)
-	os.Unsetenv(rateLimitWriteQPSEnvVar)
-	os.Unsetenv(rateLimitWriteBucketsEnvVar)
-}
-
-func TestInitializeCloudProviderRateLimitConfigWithReadAndWriteRateLimitAlreadySetInConfig(t *testing.T) {
-	var rateLimitReadQPS float32 = 3.0
-	rateLimitReadBuckets := 10
-	var rateLimitWriteQPS float32 = 6.0
-	rateLimitWriteBuckets := 20
-
-	configWithRateLimits := &CloudProviderRateLimitConfig{
-		RateLimitConfig: azclients.RateLimitConfig{
-			CloudProviderRateLimitBucket:      rateLimitReadBuckets,
-			CloudProviderRateLimitBucketWrite: rateLimitWriteBuckets,
-			CloudProviderRateLimitQPS:         rateLimitReadQPS,
-			CloudProviderRateLimitQPSWrite:    rateLimitWriteQPS,
-		},
-	}
-
-	os.Setenv(rateLimitReadQPSEnvVar, "99")
-	os.Setenv(rateLimitReadBucketsEnvVar, "99")
-	os.Setenv(rateLimitWriteQPSEnvVar, "99")
-	os.Setenv(rateLimitWriteBucketsEnvVar, "99")
-
-	err := initializeCloudProviderRateLimitConfig(configWithRateLimits)
-
-	assert.NoError(t, err)
-	assert.Equal(t, configWithRateLimits.CloudProviderRateLimitQPS, rateLimitReadQPS)
-	assert.Equal(t, configWithRateLimits.CloudProviderRateLimitBucket, rateLimitReadBuckets)
-	assert.Equal(t, configWithRateLimits.CloudProviderRateLimitQPSWrite, rateLimitWriteQPS)
-	assert.Equal(t, configWithRateLimits.CloudProviderRateLimitBucketWrite, rateLimitWriteBuckets)
-
-	os.Unsetenv(rateLimitReadQPSEnvVar)
-	os.Unsetenv(rateLimitReadBucketsEnvVar)
-	os.Unsetenv(rateLimitWriteQPSEnvVar)
-	os.Unsetenv(rateLimitWriteBucketsEnvVar)
-}
-
-func TestInitializeCloudProviderRateLimitConfigWithInvalidReadAndWriteRateLimitSettingsFromEnv(t *testing.T) {
-	emptyConfig := &CloudProviderRateLimitConfig{}
-	var rateLimitReadQPS float32 = 3.0
-	rateLimitReadBuckets := 10
-	var rateLimitWriteQPS float32 = 6.0
-	rateLimitWriteBuckets := 20
-
-	invalidSetting := "invalid"
-	testCases := []struct {
-		desc                                 string
-		isInvalidRateLimitReadQPSEnvVar      bool
-		isInvalidRateLimitReadBucketsEnvVar  bool
-		isInvalidRateLimitWriteQPSEnvVar     bool
-		isInvalidRateLimitWriteBucketsEnvVar bool
-		expectedErr                          bool
-		expectedErrMsg                       error
-	}{
-		{
-			desc:                            "an error shall be returned if invalid rateLimitReadQPSEnvVar",
-			isInvalidRateLimitReadQPSEnvVar: true,
-			expectedErr:                     true,
-			expectedErrMsg:                  fmt.Errorf("failed to parse %s: %q, strconv.ParseFloat: parsing \"invalid\": invalid syntax", rateLimitReadQPSEnvVar, invalidSetting),
-		},
-		{
-			desc:                                "an error shall be returned if invalid rateLimitReadBucketsEnvVar",
-			isInvalidRateLimitReadBucketsEnvVar: true,
-			expectedErr:                         true,
-			expectedErrMsg:                      fmt.Errorf("failed to parse %s: %q, strconv.ParseInt: parsing \"invalid\": invalid syntax", rateLimitReadBucketsEnvVar, invalidSetting),
-		},
-		{
-			desc:                             "an error shall be returned if invalid rateLimitWriteQPSEnvVar",
-			isInvalidRateLimitWriteQPSEnvVar: true,
-			expectedErr:                      true,
-			expectedErrMsg:                   fmt.Errorf("failed to parse %s: %q, strconv.ParseFloat: parsing \"invalid\": invalid syntax", rateLimitWriteQPSEnvVar, invalidSetting),
-		},
-		{
-			desc:                                 "an error shall be returned if invalid rateLimitWriteBucketsEnvVar",
-			isInvalidRateLimitWriteBucketsEnvVar: true,
-			expectedErr:                          true,
-			expectedErrMsg:                       fmt.Errorf("failed to parse %s: %q, strconv.ParseInt: parsing \"invalid\": invalid syntax", rateLimitWriteBucketsEnvVar, invalidSetting),
-		},
-	}
-
-	for i, test := range testCases {
-		if test.isInvalidRateLimitReadQPSEnvVar {
-			os.Setenv(rateLimitReadQPSEnvVar, invalidSetting)
-		} else {
-			os.Setenv(rateLimitReadQPSEnvVar, fmt.Sprintf("%.1f", rateLimitReadQPS))
-		}
-		if test.isInvalidRateLimitReadBucketsEnvVar {
-			os.Setenv(rateLimitReadBucketsEnvVar, invalidSetting)
-		} else {
-			os.Setenv(rateLimitReadBucketsEnvVar, fmt.Sprintf("%d", rateLimitReadBuckets))
-		}
-		if test.isInvalidRateLimitWriteQPSEnvVar {
-			os.Setenv(rateLimitWriteQPSEnvVar, invalidSetting)
-		} else {
-			os.Setenv(rateLimitWriteQPSEnvVar, fmt.Sprintf("%.1f", rateLimitWriteQPS))
-		}
-		if test.isInvalidRateLimitWriteBucketsEnvVar {
-			os.Setenv(rateLimitWriteBucketsEnvVar, invalidSetting)
-		} else {
-			os.Setenv(rateLimitWriteBucketsEnvVar, fmt.Sprintf("%d", rateLimitWriteBuckets))
-		}
-
-		err := initializeCloudProviderRateLimitConfig(emptyConfig)
-
-		assert.Equal(t, test.expectedErr, err != nil, "TestCase[%d]: %s, return error: %v", i, test.desc, err)
-		assert.Equal(t, test.expectedErrMsg, err, "TestCase[%d]: %s, expected: %v, return: %v", i, test.desc, test.expectedErrMsg, err)
-
-		os.Unsetenv(rateLimitReadQPSEnvVar)
-		os.Unsetenv(rateLimitReadBucketsEnvVar)
-		os.Unsetenv(rateLimitWriteQPSEnvVar)
-		os.Unsetenv(rateLimitWriteBucketsEnvVar)
-	}
-}
-
-func TestOverrideDefaultRateLimitConfig(t *testing.T) {
-	var rateLimitReadQPS float32 = 3.0
-	rateLimitReadBuckets := 10
-	var rateLimitWriteQPS float32 = 6.0
-	rateLimitWriteBuckets := 20
-
-	defaultConfigWithRateLimits := &CloudProviderRateLimitConfig{
-		RateLimitConfig: azclients.RateLimitConfig{
-			CloudProviderRateLimitBucket:      rateLimitReadBuckets,
-			CloudProviderRateLimitBucketWrite: rateLimitWriteBuckets,
-			CloudProviderRateLimitQPS:         rateLimitReadQPS,
-			CloudProviderRateLimitQPSWrite:    rateLimitWriteQPS,
-		},
-	}
-
-	configWithRateLimits := &CloudProviderRateLimitConfig{
-		RateLimitConfig: azclients.RateLimitConfig{
-			CloudProviderRateLimit:            true,
-			CloudProviderRateLimitBucket:      0,
-			CloudProviderRateLimitBucketWrite: 0,
-			CloudProviderRateLimitQPS:         0,
-			CloudProviderRateLimitQPSWrite:    0,
-		},
-	}
-
-	newconfig := overrideDefaultRateLimitConfig(&defaultConfigWithRateLimits.RateLimitConfig, &configWithRateLimits.RateLimitConfig)
-
-	assert.Equal(t, defaultConfigWithRateLimits.CloudProviderRateLimitQPS, newconfig.CloudProviderRateLimitQPS)
-	assert.Equal(t, defaultConfigWithRateLimits.CloudProviderRateLimitBucket, newconfig.CloudProviderRateLimitBucket)
-	assert.Equal(t, defaultConfigWithRateLimits.CloudProviderRateLimitQPSWrite, newconfig.CloudProviderRateLimitQPSWrite)
-	assert.Equal(t, defaultConfigWithRateLimits.CloudProviderRateLimitBucketWrite, newconfig.CloudProviderRateLimitBucketWrite)
-
-	falseCloudProviderRateLimit := &CloudProviderRateLimitConfig{
-		RateLimitConfig: azclients.RateLimitConfig{
-			CloudProviderRateLimit: false,
-		},
-	}
-	newconfig = overrideDefaultRateLimitConfig(&defaultConfigWithRateLimits.RateLimitConfig, &falseCloudProviderRateLimit.RateLimitConfig)
-	assert.Equal(t, &falseCloudProviderRateLimit.RateLimitConfig, newconfig)
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_fakes.go b/cluster-autoscaler/cloudprovider/azure/azure_fakes.go
deleted file mode 100644
index 23bb64563..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_fakes.go
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
-Copyright 2017 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"context"
-	"fmt"
-	"net/http"
-	"sync"
-
-	"github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2019-12-01/compute"
-	"github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2017-05-10/resources"
-	"github.com/stretchr/testify/mock"
-)
-
-const (
-	fakeVirtualMachineScaleSetVMID = "/subscriptions/test-subscription-id/resourceGroups/test-asg/providers/Microsoft.Compute/virtualMachineScaleSets/agents/virtualMachines/%d"
-)
-
-// DeploymentsClientMock mocks for DeploymentsClient.
-type DeploymentsClientMock struct {
-	mock.Mock
-
-	mutex     sync.Mutex
-	FakeStore map[string]resources.DeploymentExtended
-}
-
-// Get gets the DeploymentExtended by deploymentName.
-func (m *DeploymentsClientMock) Get(ctx context.Context, resourceGroupName string, deploymentName string) (result resources.DeploymentExtended, err error) {
-	m.mutex.Lock()
-	defer m.mutex.Unlock()
-
-	deploy, ok := m.FakeStore[deploymentName]
-	if !ok {
-		return result, fmt.Errorf("deployment not found")
-	}
-
-	return deploy, nil
-}
-
-// ExportTemplate exports the deployment's template.
-func (m *DeploymentsClientMock) ExportTemplate(ctx context.Context, resourceGroupName string, deploymentName string) (result resources.DeploymentExportResult, err error) {
-	m.mutex.Lock()
-	defer m.mutex.Unlock()
-
-	deploy, ok := m.FakeStore[deploymentName]
-	if !ok {
-		return result, fmt.Errorf("deployment not found")
-	}
-
-	return resources.DeploymentExportResult{
-		Template: deploy.Properties.Template,
-	}, nil
-}
-
-// CreateOrUpdate creates or updates the Deployment.
-func (m *DeploymentsClientMock) CreateOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters resources.Deployment) (resp *http.Response, err error) {
-	m.mutex.Lock()
-	defer m.mutex.Unlock()
-
-	deploy, ok := m.FakeStore[deploymentName]
-	if !ok {
-		deploy = resources.DeploymentExtended{
-			Properties: &resources.DeploymentPropertiesExtended{},
-		}
-		m.FakeStore[deploymentName] = deploy
-	}
-
-	deploy.Properties.Parameters = parameters.Properties.Parameters
-	deploy.Properties.Template = parameters.Properties.Template
-	return &http.Response{StatusCode: 200}, nil
-}
-
-// List gets all the deployments for a resource group.
-func (m *DeploymentsClientMock) List(ctx context.Context, resourceGroupName, filter string, top *int32) (result []resources.DeploymentExtended, err error) {
-	m.mutex.Lock()
-	defer m.mutex.Unlock()
-
-	result = make([]resources.DeploymentExtended, 0)
-	for i := range m.FakeStore {
-		result = append(result, m.FakeStore[i])
-	}
-
-	return result, nil
-}
-
-// Delete deletes the given deployment
-func (m *DeploymentsClientMock) Delete(ctx context.Context, resourceGroupName, deploymentName string) (resp *http.Response, err error) {
-	m.mutex.Lock()
-	defer m.mutex.Unlock()
-
-	if _, ok := m.FakeStore[deploymentName]; !ok {
-		return nil, fmt.Errorf("there is no such a deployment with name %s", deploymentName)
-	}
-
-	delete(m.FakeStore, deploymentName)
-
-	return
-}
-
-func fakeVMSSWithTags(vmssName string, tags map[string]*string) compute.VirtualMachineScaleSet {
-	skuName := "Standard_D4_v2"
-	var vmssCapacity int64 = 3
-
-	return compute.VirtualMachineScaleSet{
-		Name: &vmssName,
-		Sku: &compute.Sku{
-			Capacity: &vmssCapacity,
-			Name:     &skuName,
-		},
-		Tags: tags,
-	}
-
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_instance_types.go b/cluster-autoscaler/cloudprovider/azure/azure_instance_types.go
deleted file mode 100644
index 8a97fbdd6..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_instance_types.go
+++ /dev/null
@@ -1,3835 +0,0 @@
-/*
-Copyright The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-// This file was generated by go generate; DO NOT EDIT
-
-package azure
-
-// InstanceType is the sepc of Azure instance
-type InstanceType struct {
-	InstanceType string
-	VCPU         int64
-	MemoryMb     int64
-	GPU          int64
-}
-
-// InstanceTypes is a map of azure resources
-var InstanceTypes = map[string]*InstanceType{
-	"Basic_A0": {
-		InstanceType: "Basic_A0",
-		VCPU:         1,
-		MemoryMb:     0,
-		GPU:          0,
-	},
-	"Basic_A1": {
-		InstanceType: "Basic_A1",
-		VCPU:         1,
-		MemoryMb:     1024,
-		GPU:          0,
-	},
-	"Basic_A2": {
-		InstanceType: "Basic_A2",
-		VCPU:         2,
-		MemoryMb:     3072,
-		GPU:          0,
-	},
-	"Basic_A3": {
-		InstanceType: "Basic_A3",
-		VCPU:         4,
-		MemoryMb:     7168,
-		GPU:          0,
-	},
-	"Basic_A4": {
-		InstanceType: "Basic_A4",
-		VCPU:         8,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_A0": {
-		InstanceType: "Standard_A0",
-		VCPU:         1,
-		MemoryMb:     0,
-		GPU:          0,
-	},
-	"Standard_A1": {
-		InstanceType: "Standard_A1",
-		VCPU:         1,
-		MemoryMb:     1024,
-		GPU:          0,
-	},
-	"Standard_A10": {
-		InstanceType: "Standard_A10",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_A11": {
-		InstanceType: "Standard_A11",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_A1_v2": {
-		InstanceType: "Standard_A1_v2",
-		VCPU:         1,
-		MemoryMb:     2048,
-		GPU:          0,
-	},
-	"Standard_A2": {
-		InstanceType: "Standard_A2",
-		VCPU:         2,
-		MemoryMb:     3072,
-		GPU:          0,
-	},
-	"Standard_A2_v2": {
-		InstanceType: "Standard_A2_v2",
-		VCPU:         2,
-		MemoryMb:     4096,
-		GPU:          0,
-	},
-	"Standard_A2m_v2": {
-		InstanceType: "Standard_A2m_v2",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_A3": {
-		InstanceType: "Standard_A3",
-		VCPU:         4,
-		MemoryMb:     7168,
-		GPU:          0,
-	},
-	"Standard_A4": {
-		InstanceType: "Standard_A4",
-		VCPU:         8,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_A4_v2": {
-		InstanceType: "Standard_A4_v2",
-		VCPU:         4,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_A4m_v2": {
-		InstanceType: "Standard_A4m_v2",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_A5": {
-		InstanceType: "Standard_A5",
-		VCPU:         2,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_A6": {
-		InstanceType: "Standard_A6",
-		VCPU:         4,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_A7": {
-		InstanceType: "Standard_A7",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_A8": {
-		InstanceType: "Standard_A8",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_A8_v2": {
-		InstanceType: "Standard_A8_v2",
-		VCPU:         8,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_A8m_v2": {
-		InstanceType: "Standard_A8m_v2",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_A9": {
-		InstanceType: "Standard_A9",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_B12ms": {
-		InstanceType: "Standard_B12ms",
-		VCPU:         12,
-		MemoryMb:     49152,
-		GPU:          0,
-	},
-	"Standard_B16ms": {
-		InstanceType: "Standard_B16ms",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_B1ls": {
-		InstanceType: "Standard_B1ls",
-		VCPU:         1,
-		MemoryMb:     0,
-		GPU:          0,
-	},
-	"Standard_B1ms": {
-		InstanceType: "Standard_B1ms",
-		VCPU:         1,
-		MemoryMb:     2048,
-		GPU:          0,
-	},
-	"Standard_B1s": {
-		InstanceType: "Standard_B1s",
-		VCPU:         1,
-		MemoryMb:     1024,
-		GPU:          0,
-	},
-	"Standard_B20ms": {
-		InstanceType: "Standard_B20ms",
-		VCPU:         20,
-		MemoryMb:     81920,
-		GPU:          0,
-	},
-	"Standard_B2ms": {
-		InstanceType: "Standard_B2ms",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_B2s": {
-		InstanceType: "Standard_B2s",
-		VCPU:         2,
-		MemoryMb:     4096,
-		GPU:          0,
-	},
-	"Standard_B4ms": {
-		InstanceType: "Standard_B4ms",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_B8ms": {
-		InstanceType: "Standard_B8ms",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D1": {
-		InstanceType: "Standard_D1",
-		VCPU:         1,
-		MemoryMb:     3072,
-		GPU:          0,
-	},
-	"Standard_D11": {
-		InstanceType: "Standard_D11",
-		VCPU:         2,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_D11_v2": {
-		InstanceType: "Standard_D11_v2",
-		VCPU:         2,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_D11_v2_Promo": {
-		InstanceType: "Standard_D11_v2_Promo",
-		VCPU:         2,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_D12": {
-		InstanceType: "Standard_D12",
-		VCPU:         4,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_D12_v2": {
-		InstanceType: "Standard_D12_v2",
-		VCPU:         4,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_D12_v2_Promo": {
-		InstanceType: "Standard_D12_v2_Promo",
-		VCPU:         4,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_D13": {
-		InstanceType: "Standard_D13",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_D13_v2": {
-		InstanceType: "Standard_D13_v2",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_D13_v2_Promo": {
-		InstanceType: "Standard_D13_v2_Promo",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_D14": {
-		InstanceType: "Standard_D14",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_D14_v2": {
-		InstanceType: "Standard_D14_v2",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_D14_v2_Promo": {
-		InstanceType: "Standard_D14_v2_Promo",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_D15_v2": {
-		InstanceType: "Standard_D15_v2",
-		VCPU:         20,
-		MemoryMb:     143360,
-		GPU:          0,
-	},
-	"Standard_D16_v3": {
-		InstanceType: "Standard_D16_v3",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16_v4": {
-		InstanceType: "Standard_D16_v4",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16_v5": {
-		InstanceType: "Standard_D16_v5",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16a_v3": {
-		InstanceType: "Standard_D16a_v3",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16a_v4": {
-		InstanceType: "Standard_D16a_v4",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16ads_v5": {
-		InstanceType: "Standard_D16ads_v5",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16as_v3": {
-		InstanceType: "Standard_D16as_v3",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16as_v4": {
-		InstanceType: "Standard_D16as_v4",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16as_v5": {
-		InstanceType: "Standard_D16as_v5",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16d_v4": {
-		InstanceType: "Standard_D16d_v4",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16d_v5": {
-		InstanceType: "Standard_D16d_v5",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16ds_v4": {
-		InstanceType: "Standard_D16ds_v4",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16ds_v5": {
-		InstanceType: "Standard_D16ds_v5",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16s_v3": {
-		InstanceType: "Standard_D16s_v3",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16s_v4": {
-		InstanceType: "Standard_D16s_v4",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D16s_v5": {
-		InstanceType: "Standard_D16s_v5",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_D1_v2": {
-		InstanceType: "Standard_D1_v2",
-		VCPU:         1,
-		MemoryMb:     3072,
-		GPU:          0,
-	},
-	"Standard_D2": {
-		InstanceType: "Standard_D2",
-		VCPU:         2,
-		MemoryMb:     7168,
-		GPU:          0,
-	},
-	"Standard_D2_v2": {
-		InstanceType: "Standard_D2_v2",
-		VCPU:         2,
-		MemoryMb:     7168,
-		GPU:          0,
-	},
-	"Standard_D2_v2_Promo": {
-		InstanceType: "Standard_D2_v2_Promo",
-		VCPU:         2,
-		MemoryMb:     7168,
-		GPU:          0,
-	},
-	"Standard_D2_v3": {
-		InstanceType: "Standard_D2_v3",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2_v4": {
-		InstanceType: "Standard_D2_v4",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2_v5": {
-		InstanceType: "Standard_D2_v5",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2a_v3": {
-		InstanceType: "Standard_D2a_v3",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2a_v4": {
-		InstanceType: "Standard_D2a_v4",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2ads_v5": {
-		InstanceType: "Standard_D2ads_v5",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2as_v3": {
-		InstanceType: "Standard_D2as_v3",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2as_v4": {
-		InstanceType: "Standard_D2as_v4",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2as_v5": {
-		InstanceType: "Standard_D2as_v5",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2d_v4": {
-		InstanceType: "Standard_D2d_v4",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2d_v5": {
-		InstanceType: "Standard_D2d_v5",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2ds_v4": {
-		InstanceType: "Standard_D2ds_v4",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2ds_v5": {
-		InstanceType: "Standard_D2ds_v5",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2s_v3": {
-		InstanceType: "Standard_D2s_v3",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2s_v4": {
-		InstanceType: "Standard_D2s_v4",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D2s_v5": {
-		InstanceType: "Standard_D2s_v5",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_D3": {
-		InstanceType: "Standard_D3",
-		VCPU:         4,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_D32_v3": {
-		InstanceType: "Standard_D32_v3",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32_v4": {
-		InstanceType: "Standard_D32_v4",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32_v5": {
-		InstanceType: "Standard_D32_v5",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32a_v3": {
-		InstanceType: "Standard_D32a_v3",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32a_v4": {
-		InstanceType: "Standard_D32a_v4",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32ads_v5": {
-		InstanceType: "Standard_D32ads_v5",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32as_v3": {
-		InstanceType: "Standard_D32as_v3",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32as_v4": {
-		InstanceType: "Standard_D32as_v4",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32as_v5": {
-		InstanceType: "Standard_D32as_v5",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32d_v4": {
-		InstanceType: "Standard_D32d_v4",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32d_v5": {
-		InstanceType: "Standard_D32d_v5",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32ds_v4": {
-		InstanceType: "Standard_D32ds_v4",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32ds_v5": {
-		InstanceType: "Standard_D32ds_v5",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32s_v3": {
-		InstanceType: "Standard_D32s_v3",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32s_v4": {
-		InstanceType: "Standard_D32s_v4",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D32s_v5": {
-		InstanceType: "Standard_D32s_v5",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_D3_v2": {
-		InstanceType: "Standard_D3_v2",
-		VCPU:         4,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_D3_v2_Promo": {
-		InstanceType: "Standard_D3_v2_Promo",
-		VCPU:         4,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_D4": {
-		InstanceType: "Standard_D4",
-		VCPU:         8,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_D48_v3": {
-		InstanceType: "Standard_D48_v3",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48_v4": {
-		InstanceType: "Standard_D48_v4",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48_v5": {
-		InstanceType: "Standard_D48_v5",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48a_v3": {
-		InstanceType: "Standard_D48a_v3",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48a_v4": {
-		InstanceType: "Standard_D48a_v4",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48ads_v5": {
-		InstanceType: "Standard_D48ads_v5",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48as_v3": {
-		InstanceType: "Standard_D48as_v3",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48as_v4": {
-		InstanceType: "Standard_D48as_v4",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48as_v5": {
-		InstanceType: "Standard_D48as_v5",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48d_v4": {
-		InstanceType: "Standard_D48d_v4",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48d_v5": {
-		InstanceType: "Standard_D48d_v5",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48ds_v4": {
-		InstanceType: "Standard_D48ds_v4",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48ds_v5": {
-		InstanceType: "Standard_D48ds_v5",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48s_v3": {
-		InstanceType: "Standard_D48s_v3",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48s_v4": {
-		InstanceType: "Standard_D48s_v4",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D48s_v5": {
-		InstanceType: "Standard_D48s_v5",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_D4_v2": {
-		InstanceType: "Standard_D4_v2",
-		VCPU:         8,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_D4_v2_Promo": {
-		InstanceType: "Standard_D4_v2_Promo",
-		VCPU:         8,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_D4_v3": {
-		InstanceType: "Standard_D4_v3",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4_v4": {
-		InstanceType: "Standard_D4_v4",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4_v5": {
-		InstanceType: "Standard_D4_v5",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4a_v3": {
-		InstanceType: "Standard_D4a_v3",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4a_v4": {
-		InstanceType: "Standard_D4a_v4",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4ads_v5": {
-		InstanceType: "Standard_D4ads_v5",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4as_v3": {
-		InstanceType: "Standard_D4as_v3",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4as_v4": {
-		InstanceType: "Standard_D4as_v4",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4as_v5": {
-		InstanceType: "Standard_D4as_v5",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4d_v4": {
-		InstanceType: "Standard_D4d_v4",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4d_v5": {
-		InstanceType: "Standard_D4d_v5",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4ds_v4": {
-		InstanceType: "Standard_D4ds_v4",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4ds_v5": {
-		InstanceType: "Standard_D4ds_v5",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4s_v3": {
-		InstanceType: "Standard_D4s_v3",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4s_v4": {
-		InstanceType: "Standard_D4s_v4",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D4s_v5": {
-		InstanceType: "Standard_D4s_v5",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_D5_v2": {
-		InstanceType: "Standard_D5_v2",
-		VCPU:         16,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_D5_v2_Promo": {
-		InstanceType: "Standard_D5_v2_Promo",
-		VCPU:         16,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_D64_v3": {
-		InstanceType: "Standard_D64_v3",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64_v4": {
-		InstanceType: "Standard_D64_v4",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64_v5": {
-		InstanceType: "Standard_D64_v5",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64a_v3": {
-		InstanceType: "Standard_D64a_v3",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64a_v4": {
-		InstanceType: "Standard_D64a_v4",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64ads_v5": {
-		InstanceType: "Standard_D64ads_v5",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64as_v3": {
-		InstanceType: "Standard_D64as_v3",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64as_v4": {
-		InstanceType: "Standard_D64as_v4",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64as_v5": {
-		InstanceType: "Standard_D64as_v5",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64d_v4": {
-		InstanceType: "Standard_D64d_v4",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64d_v5": {
-		InstanceType: "Standard_D64d_v5",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64ds_v4": {
-		InstanceType: "Standard_D64ds_v4",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64ds_v5": {
-		InstanceType: "Standard_D64ds_v5",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64s_v3": {
-		InstanceType: "Standard_D64s_v3",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64s_v4": {
-		InstanceType: "Standard_D64s_v4",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D64s_v5": {
-		InstanceType: "Standard_D64s_v5",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_D8_v3": {
-		InstanceType: "Standard_D8_v3",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8_v4": {
-		InstanceType: "Standard_D8_v4",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8_v5": {
-		InstanceType: "Standard_D8_v5",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8a_v3": {
-		InstanceType: "Standard_D8a_v3",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8a_v4": {
-		InstanceType: "Standard_D8a_v4",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8ads_v5": {
-		InstanceType: "Standard_D8ads_v5",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8as_v3": {
-		InstanceType: "Standard_D8as_v3",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8as_v4": {
-		InstanceType: "Standard_D8as_v4",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8as_v5": {
-		InstanceType: "Standard_D8as_v5",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8d_v4": {
-		InstanceType: "Standard_D8d_v4",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8d_v5": {
-		InstanceType: "Standard_D8d_v5",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8ds_v4": {
-		InstanceType: "Standard_D8ds_v4",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8ds_v5": {
-		InstanceType: "Standard_D8ds_v5",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8s_v3": {
-		InstanceType: "Standard_D8s_v3",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8s_v4": {
-		InstanceType: "Standard_D8s_v4",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D8s_v5": {
-		InstanceType: "Standard_D8s_v5",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_D96_v5": {
-		InstanceType: "Standard_D96_v5",
-		VCPU:         96,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_D96a_v4": {
-		InstanceType: "Standard_D96a_v4",
-		VCPU:         96,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_D96ads_v5": {
-		InstanceType: "Standard_D96ads_v5",
-		VCPU:         96,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_D96as_v4": {
-		InstanceType: "Standard_D96as_v4",
-		VCPU:         96,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_D96as_v5": {
-		InstanceType: "Standard_D96as_v5",
-		VCPU:         96,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_D96d_v5": {
-		InstanceType: "Standard_D96d_v5",
-		VCPU:         96,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_D96ds_v5": {
-		InstanceType: "Standard_D96ds_v5",
-		VCPU:         96,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_D96s_v5": {
-		InstanceType: "Standard_D96s_v5",
-		VCPU:         96,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_DC16ads_v5": {
-		InstanceType: "Standard_DC16ads_v5",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_DC16as_v5": {
-		InstanceType: "Standard_DC16as_v5",
-		VCPU:         16,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_DC16ds_v3": {
-		InstanceType: "Standard_DC16ds_v3",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_DC16s_v3": {
-		InstanceType: "Standard_DC16s_v3",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_DC1ds_v3": {
-		InstanceType: "Standard_DC1ds_v3",
-		VCPU:         1,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_DC1s_v2": {
-		InstanceType: "Standard_DC1s_v2",
-		VCPU:         1,
-		MemoryMb:     4096,
-		GPU:          0,
-	},
-	"Standard_DC1s_v3": {
-		InstanceType: "Standard_DC1s_v3",
-		VCPU:         1,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_DC24ds_v3": {
-		InstanceType: "Standard_DC24ds_v3",
-		VCPU:         24,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_DC24s_v3": {
-		InstanceType: "Standard_DC24s_v3",
-		VCPU:         24,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_DC2ads_v5": {
-		InstanceType: "Standard_DC2ads_v5",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_DC2as_v5": {
-		InstanceType: "Standard_DC2as_v5",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_DC2ds_v3": {
-		InstanceType: "Standard_DC2ds_v3",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_DC2s": {
-		InstanceType: "Standard_DC2s",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_DC2s_v2": {
-		InstanceType: "Standard_DC2s_v2",
-		VCPU:         2,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_DC2s_v3": {
-		InstanceType: "Standard_DC2s_v3",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_DC32ads_v5": {
-		InstanceType: "Standard_DC32ads_v5",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_DC32as_v5": {
-		InstanceType: "Standard_DC32as_v5",
-		VCPU:         32,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_DC32ds_v3": {
-		InstanceType: "Standard_DC32ds_v3",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_DC32s_v3": {
-		InstanceType: "Standard_DC32s_v3",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_DC48ads_v5": {
-		InstanceType: "Standard_DC48ads_v5",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_DC48as_v5": {
-		InstanceType: "Standard_DC48as_v5",
-		VCPU:         48,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_DC48ds_v3": {
-		InstanceType: "Standard_DC48ds_v3",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_DC48s_v3": {
-		InstanceType: "Standard_DC48s_v3",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_DC4ads_v5": {
-		InstanceType: "Standard_DC4ads_v5",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_DC4as_v5": {
-		InstanceType: "Standard_DC4as_v5",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_DC4ds_v3": {
-		InstanceType: "Standard_DC4ds_v3",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_DC4s": {
-		InstanceType: "Standard_DC4s",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_DC4s_v2": {
-		InstanceType: "Standard_DC4s_v2",
-		VCPU:         4,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_DC4s_v3": {
-		InstanceType: "Standard_DC4s_v3",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_DC64ads_v5": {
-		InstanceType: "Standard_DC64ads_v5",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_DC64as_v5": {
-		InstanceType: "Standard_DC64as_v5",
-		VCPU:         64,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_DC8_v2": {
-		InstanceType: "Standard_DC8_v2",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_DC8ads_v5": {
-		InstanceType: "Standard_DC8ads_v5",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_DC8as_v5": {
-		InstanceType: "Standard_DC8as_v5",
-		VCPU:         8,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_DC8ds_v3": {
-		InstanceType: "Standard_DC8ds_v3",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_DC8s_v3": {
-		InstanceType: "Standard_DC8s_v3",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_DC96ads_v5": {
-		InstanceType: "Standard_DC96ads_v5",
-		VCPU:         96,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_DC96as_v5": {
-		InstanceType: "Standard_DC96as_v5",
-		VCPU:         96,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_DS1": {
-		InstanceType: "Standard_DS1",
-		VCPU:         1,
-		MemoryMb:     3072,
-		GPU:          0,
-	},
-	"Standard_DS11": {
-		InstanceType: "Standard_DS11",
-		VCPU:         2,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_DS11-1_v2": {
-		InstanceType: "Standard_DS11-1_v2",
-		VCPU:         2,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_DS11_v2": {
-		InstanceType: "Standard_DS11_v2",
-		VCPU:         2,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_DS11_v2_Promo": {
-		InstanceType: "Standard_DS11_v2_Promo",
-		VCPU:         2,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_DS12": {
-		InstanceType: "Standard_DS12",
-		VCPU:         4,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_DS12-1_v2": {
-		InstanceType: "Standard_DS12-1_v2",
-		VCPU:         4,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_DS12-2_v2": {
-		InstanceType: "Standard_DS12-2_v2",
-		VCPU:         4,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_DS12_v2": {
-		InstanceType: "Standard_DS12_v2",
-		VCPU:         4,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_DS12_v2_Promo": {
-		InstanceType: "Standard_DS12_v2_Promo",
-		VCPU:         4,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_DS13": {
-		InstanceType: "Standard_DS13",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_DS13-2_v2": {
-		InstanceType: "Standard_DS13-2_v2",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_DS13-4_v2": {
-		InstanceType: "Standard_DS13-4_v2",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_DS13_v2": {
-		InstanceType: "Standard_DS13_v2",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_DS13_v2_Promo": {
-		InstanceType: "Standard_DS13_v2_Promo",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_DS14": {
-		InstanceType: "Standard_DS14",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_DS14-4_v2": {
-		InstanceType: "Standard_DS14-4_v2",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_DS14-8_v2": {
-		InstanceType: "Standard_DS14-8_v2",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_DS14_v2": {
-		InstanceType: "Standard_DS14_v2",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_DS14_v2_Promo": {
-		InstanceType: "Standard_DS14_v2_Promo",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_DS15_v2": {
-		InstanceType: "Standard_DS15_v2",
-		VCPU:         20,
-		MemoryMb:     143360,
-		GPU:          0,
-	},
-	"Standard_DS1_v2": {
-		InstanceType: "Standard_DS1_v2",
-		VCPU:         1,
-		MemoryMb:     3072,
-		GPU:          0,
-	},
-	"Standard_DS2": {
-		InstanceType: "Standard_DS2",
-		VCPU:         2,
-		MemoryMb:     7168,
-		GPU:          0,
-	},
-	"Standard_DS2_v2": {
-		InstanceType: "Standard_DS2_v2",
-		VCPU:         2,
-		MemoryMb:     7168,
-		GPU:          0,
-	},
-	"Standard_DS2_v2_Promo": {
-		InstanceType: "Standard_DS2_v2_Promo",
-		VCPU:         2,
-		MemoryMb:     7168,
-		GPU:          0,
-	},
-	"Standard_DS3": {
-		InstanceType: "Standard_DS3",
-		VCPU:         4,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_DS3_v2": {
-		InstanceType: "Standard_DS3_v2",
-		VCPU:         4,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_DS3_v2_Promo": {
-		InstanceType: "Standard_DS3_v2_Promo",
-		VCPU:         4,
-		MemoryMb:     14336,
-		GPU:          0,
-	},
-	"Standard_DS4": {
-		InstanceType: "Standard_DS4",
-		VCPU:         8,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_DS4_v2": {
-		InstanceType: "Standard_DS4_v2",
-		VCPU:         8,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_DS4_v2_Promo": {
-		InstanceType: "Standard_DS4_v2_Promo",
-		VCPU:         8,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_DS5_v2": {
-		InstanceType: "Standard_DS5_v2",
-		VCPU:         16,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_DS5_v2_Promo": {
-		InstanceType: "Standard_DS5_v2_Promo",
-		VCPU:         16,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_E104i_v5": {
-		InstanceType: "Standard_E104i_v5",
-		VCPU:         104,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E104id_v5": {
-		InstanceType: "Standard_E104id_v5",
-		VCPU:         104,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E104ids_v5": {
-		InstanceType: "Standard_E104ids_v5",
-		VCPU:         104,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E104is_v5": {
-		InstanceType: "Standard_E104is_v5",
-		VCPU:         104,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E16-4ads_v5": {
-		InstanceType: "Standard_E16-4ads_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-4as_v4": {
-		InstanceType: "Standard_E16-4as_v4",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-4as_v5": {
-		InstanceType: "Standard_E16-4as_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-4ds_v4": {
-		InstanceType: "Standard_E16-4ds_v4",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-4ds_v5": {
-		InstanceType: "Standard_E16-4ds_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-4s_v3": {
-		InstanceType: "Standard_E16-4s_v3",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-4s_v4": {
-		InstanceType: "Standard_E16-4s_v4",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-4s_v5": {
-		InstanceType: "Standard_E16-4s_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-8ads_v5": {
-		InstanceType: "Standard_E16-8ads_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-8as_v4": {
-		InstanceType: "Standard_E16-8as_v4",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-8as_v5": {
-		InstanceType: "Standard_E16-8as_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-8ds_v4": {
-		InstanceType: "Standard_E16-8ds_v4",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-8ds_v5": {
-		InstanceType: "Standard_E16-8ds_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-8s_v3": {
-		InstanceType: "Standard_E16-8s_v3",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-8s_v4": {
-		InstanceType: "Standard_E16-8s_v4",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16-8s_v5": {
-		InstanceType: "Standard_E16-8s_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16_v3": {
-		InstanceType: "Standard_E16_v3",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16_v4": {
-		InstanceType: "Standard_E16_v4",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16_v5": {
-		InstanceType: "Standard_E16_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16a_v4": {
-		InstanceType: "Standard_E16a_v4",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16ads_v5": {
-		InstanceType: "Standard_E16ads_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16as_v4": {
-		InstanceType: "Standard_E16as_v4",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16as_v5": {
-		InstanceType: "Standard_E16as_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16d_v4": {
-		InstanceType: "Standard_E16d_v4",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16d_v5": {
-		InstanceType: "Standard_E16d_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16ds_v4": {
-		InstanceType: "Standard_E16ds_v4",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16ds_v5": {
-		InstanceType: "Standard_E16ds_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16s_v3": {
-		InstanceType: "Standard_E16s_v3",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16s_v4": {
-		InstanceType: "Standard_E16s_v4",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E16s_v5": {
-		InstanceType: "Standard_E16s_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_E20_v3": {
-		InstanceType: "Standard_E20_v3",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E20_v4": {
-		InstanceType: "Standard_E20_v4",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E20_v5": {
-		InstanceType: "Standard_E20_v5",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E20a_v4": {
-		InstanceType: "Standard_E20a_v4",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E20ads_v5": {
-		InstanceType: "Standard_E20ads_v5",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E20as_v4": {
-		InstanceType: "Standard_E20as_v4",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E20as_v5": {
-		InstanceType: "Standard_E20as_v5",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E20d_v4": {
-		InstanceType: "Standard_E20d_v4",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E20d_v5": {
-		InstanceType: "Standard_E20d_v5",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E20ds_v4": {
-		InstanceType: "Standard_E20ds_v4",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E20ds_v5": {
-		InstanceType: "Standard_E20ds_v5",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E20s_v3": {
-		InstanceType: "Standard_E20s_v3",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E20s_v4": {
-		InstanceType: "Standard_E20s_v4",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E20s_v5": {
-		InstanceType: "Standard_E20s_v5",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_E2_v3": {
-		InstanceType: "Standard_E2_v3",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E2_v4": {
-		InstanceType: "Standard_E2_v4",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E2_v5": {
-		InstanceType: "Standard_E2_v5",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E2a_v4": {
-		InstanceType: "Standard_E2a_v4",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E2ads_v5": {
-		InstanceType: "Standard_E2ads_v5",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E2as_v4": {
-		InstanceType: "Standard_E2as_v4",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E2as_v5": {
-		InstanceType: "Standard_E2as_v5",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E2d_v4": {
-		InstanceType: "Standard_E2d_v4",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E2d_v5": {
-		InstanceType: "Standard_E2d_v5",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E2ds_v4": {
-		InstanceType: "Standard_E2ds_v4",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E2ds_v5": {
-		InstanceType: "Standard_E2ds_v5",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E2s_v3": {
-		InstanceType: "Standard_E2s_v3",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E2s_v4": {
-		InstanceType: "Standard_E2s_v4",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E2s_v5": {
-		InstanceType: "Standard_E2s_v5",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_E32-16ads_v5": {
-		InstanceType: "Standard_E32-16ads_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-16as_v4": {
-		InstanceType: "Standard_E32-16as_v4",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-16as_v5": {
-		InstanceType: "Standard_E32-16as_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-16ds_v4": {
-		InstanceType: "Standard_E32-16ds_v4",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-16ds_v5": {
-		InstanceType: "Standard_E32-16ds_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-16s_v3": {
-		InstanceType: "Standard_E32-16s_v3",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-16s_v4": {
-		InstanceType: "Standard_E32-16s_v4",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-16s_v5": {
-		InstanceType: "Standard_E32-16s_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-8ads_v5": {
-		InstanceType: "Standard_E32-8ads_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-8as_v4": {
-		InstanceType: "Standard_E32-8as_v4",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-8as_v5": {
-		InstanceType: "Standard_E32-8as_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-8ds_v4": {
-		InstanceType: "Standard_E32-8ds_v4",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-8ds_v5": {
-		InstanceType: "Standard_E32-8ds_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-8s_v3": {
-		InstanceType: "Standard_E32-8s_v3",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-8s_v4": {
-		InstanceType: "Standard_E32-8s_v4",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32-8s_v5": {
-		InstanceType: "Standard_E32-8s_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32_v3": {
-		InstanceType: "Standard_E32_v3",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32_v4": {
-		InstanceType: "Standard_E32_v4",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32_v5": {
-		InstanceType: "Standard_E32_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32a_v4": {
-		InstanceType: "Standard_E32a_v4",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32ads_v5": {
-		InstanceType: "Standard_E32ads_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32as_v4": {
-		InstanceType: "Standard_E32as_v4",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32as_v5": {
-		InstanceType: "Standard_E32as_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32d_v4": {
-		InstanceType: "Standard_E32d_v4",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32d_v5": {
-		InstanceType: "Standard_E32d_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32ds_v4": {
-		InstanceType: "Standard_E32ds_v4",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32ds_v5": {
-		InstanceType: "Standard_E32ds_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32s_v3": {
-		InstanceType: "Standard_E32s_v3",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32s_v4": {
-		InstanceType: "Standard_E32s_v4",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E32s_v5": {
-		InstanceType: "Standard_E32s_v5",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_E4-2ads_v5": {
-		InstanceType: "Standard_E4-2ads_v5",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4-2as_v4": {
-		InstanceType: "Standard_E4-2as_v4",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4-2as_v5": {
-		InstanceType: "Standard_E4-2as_v5",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4-2ds_v4": {
-		InstanceType: "Standard_E4-2ds_v4",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4-2ds_v5": {
-		InstanceType: "Standard_E4-2ds_v5",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4-2s_v3": {
-		InstanceType: "Standard_E4-2s_v3",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4-2s_v4": {
-		InstanceType: "Standard_E4-2s_v4",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4-2s_v5": {
-		InstanceType: "Standard_E4-2s_v5",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E48_v3": {
-		InstanceType: "Standard_E48_v3",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E48_v4": {
-		InstanceType: "Standard_E48_v4",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E48_v5": {
-		InstanceType: "Standard_E48_v5",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E48a_v4": {
-		InstanceType: "Standard_E48a_v4",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E48ads_v5": {
-		InstanceType: "Standard_E48ads_v5",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E48as_v4": {
-		InstanceType: "Standard_E48as_v4",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E48as_v5": {
-		InstanceType: "Standard_E48as_v5",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E48d_v4": {
-		InstanceType: "Standard_E48d_v4",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E48d_v5": {
-		InstanceType: "Standard_E48d_v5",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E48ds_v4": {
-		InstanceType: "Standard_E48ds_v4",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E48ds_v5": {
-		InstanceType: "Standard_E48ds_v5",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E48s_v3": {
-		InstanceType: "Standard_E48s_v3",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E48s_v4": {
-		InstanceType: "Standard_E48s_v4",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E48s_v5": {
-		InstanceType: "Standard_E48s_v5",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_E4_v3": {
-		InstanceType: "Standard_E4_v3",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4_v4": {
-		InstanceType: "Standard_E4_v4",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4_v5": {
-		InstanceType: "Standard_E4_v5",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4a_v4": {
-		InstanceType: "Standard_E4a_v4",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4ads_v5": {
-		InstanceType: "Standard_E4ads_v5",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4as_v4": {
-		InstanceType: "Standard_E4as_v4",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4as_v5": {
-		InstanceType: "Standard_E4as_v5",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4d_v4": {
-		InstanceType: "Standard_E4d_v4",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4d_v5": {
-		InstanceType: "Standard_E4d_v5",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4ds_v4": {
-		InstanceType: "Standard_E4ds_v4",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4ds_v5": {
-		InstanceType: "Standard_E4ds_v5",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4s_v3": {
-		InstanceType: "Standard_E4s_v3",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4s_v4": {
-		InstanceType: "Standard_E4s_v4",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E4s_v5": {
-		InstanceType: "Standard_E4s_v5",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_E64-16ads_v5": {
-		InstanceType: "Standard_E64-16ads_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64-16as_v4": {
-		InstanceType: "Standard_E64-16as_v4",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64-16as_v5": {
-		InstanceType: "Standard_E64-16as_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64-16ds_v4": {
-		InstanceType: "Standard_E64-16ds_v4",
-		VCPU:         64,
-		MemoryMb:     516096,
-		GPU:          0,
-	},
-	"Standard_E64-16ds_v5": {
-		InstanceType: "Standard_E64-16ds_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64-16s_v3": {
-		InstanceType: "Standard_E64-16s_v3",
-		VCPU:         64,
-		MemoryMb:     442368,
-		GPU:          0,
-	},
-	"Standard_E64-16s_v4": {
-		InstanceType: "Standard_E64-16s_v4",
-		VCPU:         64,
-		MemoryMb:     516096,
-		GPU:          0,
-	},
-	"Standard_E64-16s_v5": {
-		InstanceType: "Standard_E64-16s_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64-32ads_v5": {
-		InstanceType: "Standard_E64-32ads_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64-32as_v4": {
-		InstanceType: "Standard_E64-32as_v4",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64-32as_v5": {
-		InstanceType: "Standard_E64-32as_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64-32ds_v4": {
-		InstanceType: "Standard_E64-32ds_v4",
-		VCPU:         64,
-		MemoryMb:     516096,
-		GPU:          0,
-	},
-	"Standard_E64-32ds_v5": {
-		InstanceType: "Standard_E64-32ds_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64-32s_v3": {
-		InstanceType: "Standard_E64-32s_v3",
-		VCPU:         64,
-		MemoryMb:     442368,
-		GPU:          0,
-	},
-	"Standard_E64-32s_v4": {
-		InstanceType: "Standard_E64-32s_v4",
-		VCPU:         64,
-		MemoryMb:     516096,
-		GPU:          0,
-	},
-	"Standard_E64-32s_v5": {
-		InstanceType: "Standard_E64-32s_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64_v3": {
-		InstanceType: "Standard_E64_v3",
-		VCPU:         64,
-		MemoryMb:     442368,
-		GPU:          0,
-	},
-	"Standard_E64_v4": {
-		InstanceType: "Standard_E64_v4",
-		VCPU:         64,
-		MemoryMb:     516096,
-		GPU:          0,
-	},
-	"Standard_E64_v5": {
-		InstanceType: "Standard_E64_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64a_v4": {
-		InstanceType: "Standard_E64a_v4",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64ads_v5": {
-		InstanceType: "Standard_E64ads_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64as_v4": {
-		InstanceType: "Standard_E64as_v4",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64as_v5": {
-		InstanceType: "Standard_E64as_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64d_v4": {
-		InstanceType: "Standard_E64d_v4",
-		VCPU:         64,
-		MemoryMb:     516096,
-		GPU:          0,
-	},
-	"Standard_E64d_v5": {
-		InstanceType: "Standard_E64d_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64ds_v4": {
-		InstanceType: "Standard_E64ds_v4",
-		VCPU:         64,
-		MemoryMb:     516096,
-		GPU:          0,
-	},
-	"Standard_E64ds_v5": {
-		InstanceType: "Standard_E64ds_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E64i_v3": {
-		InstanceType: "Standard_E64i_v3",
-		VCPU:         64,
-		MemoryMb:     442368,
-		GPU:          0,
-	},
-	"Standard_E64is_v3": {
-		InstanceType: "Standard_E64is_v3",
-		VCPU:         64,
-		MemoryMb:     442368,
-		GPU:          0,
-	},
-	"Standard_E64s_v3": {
-		InstanceType: "Standard_E64s_v3",
-		VCPU:         64,
-		MemoryMb:     442368,
-		GPU:          0,
-	},
-	"Standard_E64s_v4": {
-		InstanceType: "Standard_E64s_v4",
-		VCPU:         64,
-		MemoryMb:     516096,
-		GPU:          0,
-	},
-	"Standard_E64s_v5": {
-		InstanceType: "Standard_E64s_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_E8-2ads_v5": {
-		InstanceType: "Standard_E8-2ads_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-2as_v4": {
-		InstanceType: "Standard_E8-2as_v4",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-2as_v5": {
-		InstanceType: "Standard_E8-2as_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-2ds_v4": {
-		InstanceType: "Standard_E8-2ds_v4",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-2ds_v5": {
-		InstanceType: "Standard_E8-2ds_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-2s_v3": {
-		InstanceType: "Standard_E8-2s_v3",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-2s_v4": {
-		InstanceType: "Standard_E8-2s_v4",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-2s_v5": {
-		InstanceType: "Standard_E8-2s_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-4ads_v5": {
-		InstanceType: "Standard_E8-4ads_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-4as_v4": {
-		InstanceType: "Standard_E8-4as_v4",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-4as_v5": {
-		InstanceType: "Standard_E8-4as_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-4ds_v4": {
-		InstanceType: "Standard_E8-4ds_v4",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-4ds_v5": {
-		InstanceType: "Standard_E8-4ds_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-4s_v3": {
-		InstanceType: "Standard_E8-4s_v3",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-4s_v4": {
-		InstanceType: "Standard_E8-4s_v4",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8-4s_v5": {
-		InstanceType: "Standard_E8-4s_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E80ids_v4": {
-		InstanceType: "Standard_E80ids_v4",
-		VCPU:         80,
-		MemoryMb:     516096,
-		GPU:          0,
-	},
-	"Standard_E80is_v4": {
-		InstanceType: "Standard_E80is_v4",
-		VCPU:         80,
-		MemoryMb:     516096,
-		GPU:          0,
-	},
-	"Standard_E8_v3": {
-		InstanceType: "Standard_E8_v3",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8_v4": {
-		InstanceType: "Standard_E8_v4",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8_v5": {
-		InstanceType: "Standard_E8_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8a_v4": {
-		InstanceType: "Standard_E8a_v4",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8ads_v5": {
-		InstanceType: "Standard_E8ads_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8as_v4": {
-		InstanceType: "Standard_E8as_v4",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8as_v5": {
-		InstanceType: "Standard_E8as_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8d_v4": {
-		InstanceType: "Standard_E8d_v4",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8d_v5": {
-		InstanceType: "Standard_E8d_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8ds_v4": {
-		InstanceType: "Standard_E8ds_v4",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8ds_v5": {
-		InstanceType: "Standard_E8ds_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8s_v3": {
-		InstanceType: "Standard_E8s_v3",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8s_v4": {
-		InstanceType: "Standard_E8s_v4",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E8s_v5": {
-		InstanceType: "Standard_E8s_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_E96-24ads_v5": {
-		InstanceType: "Standard_E96-24ads_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96-24as_v4": {
-		InstanceType: "Standard_E96-24as_v4",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96-24as_v5": {
-		InstanceType: "Standard_E96-24as_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96-24ds_v5": {
-		InstanceType: "Standard_E96-24ds_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96-24s_v5": {
-		InstanceType: "Standard_E96-24s_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96-48ads_v5": {
-		InstanceType: "Standard_E96-48ads_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96-48as_v4": {
-		InstanceType: "Standard_E96-48as_v4",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96-48as_v5": {
-		InstanceType: "Standard_E96-48as_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96-48ds_v5": {
-		InstanceType: "Standard_E96-48ds_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96-48s_v5": {
-		InstanceType: "Standard_E96-48s_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96_v5": {
-		InstanceType: "Standard_E96_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96a_v4": {
-		InstanceType: "Standard_E96a_v4",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96ads_v5": {
-		InstanceType: "Standard_E96ads_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96as_v4": {
-		InstanceType: "Standard_E96as_v4",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96as_v5": {
-		InstanceType: "Standard_E96as_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96d_v5": {
-		InstanceType: "Standard_E96d_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96ds_v5": {
-		InstanceType: "Standard_E96ds_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_E96s_v5": {
-		InstanceType: "Standard_E96s_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_EC16ads_v5": {
-		InstanceType: "Standard_EC16ads_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_EC16as_v5": {
-		InstanceType: "Standard_EC16as_v5",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_EC20ads_v5": {
-		InstanceType: "Standard_EC20ads_v5",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_EC20as_v5": {
-		InstanceType: "Standard_EC20as_v5",
-		VCPU:         20,
-		MemoryMb:     163840,
-		GPU:          0,
-	},
-	"Standard_EC2ads_v5": {
-		InstanceType: "Standard_EC2ads_v5",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_EC2as_v5": {
-		InstanceType: "Standard_EC2as_v5",
-		VCPU:         2,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_EC32ads_v5": {
-		InstanceType: "Standard_EC32ads_v5",
-		VCPU:         32,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_EC32as_v5": {
-		InstanceType: "Standard_EC32as_v5",
-		VCPU:         32,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_EC48ads_v5": {
-		InstanceType: "Standard_EC48ads_v5",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_EC48as_v5": {
-		InstanceType: "Standard_EC48as_v5",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_EC4ads_v5": {
-		InstanceType: "Standard_EC4ads_v5",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_EC4as_v5": {
-		InstanceType: "Standard_EC4as_v5",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_EC64ads_v5": {
-		InstanceType: "Standard_EC64ads_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_EC64as_v5": {
-		InstanceType: "Standard_EC64as_v5",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_EC8ads_v5": {
-		InstanceType: "Standard_EC8ads_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_EC8as_v5": {
-		InstanceType: "Standard_EC8as_v5",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_EC96ads_v5": {
-		InstanceType: "Standard_EC96ads_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_EC96as_v5": {
-		InstanceType: "Standard_EC96as_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_EC96iads_v5": {
-		InstanceType: "Standard_EC96iads_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_EC96ias_v5": {
-		InstanceType: "Standard_EC96ias_v5",
-		VCPU:         96,
-		MemoryMb:     688128,
-		GPU:          0,
-	},
-	"Standard_F1": {
-		InstanceType: "Standard_F1",
-		VCPU:         1,
-		MemoryMb:     2048,
-		GPU:          0,
-	},
-	"Standard_F16": {
-		InstanceType: "Standard_F16",
-		VCPU:         16,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_F16s": {
-		InstanceType: "Standard_F16s",
-		VCPU:         16,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_F16s_v2": {
-		InstanceType: "Standard_F16s_v2",
-		VCPU:         16,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_F1s": {
-		InstanceType: "Standard_F1s",
-		VCPU:         1,
-		MemoryMb:     2048,
-		GPU:          0,
-	},
-	"Standard_F2": {
-		InstanceType: "Standard_F2",
-		VCPU:         2,
-		MemoryMb:     4096,
-		GPU:          0,
-	},
-	"Standard_F2s": {
-		InstanceType: "Standard_F2s",
-		VCPU:         2,
-		MemoryMb:     4096,
-		GPU:          0,
-	},
-	"Standard_F2s_v2": {
-		InstanceType: "Standard_F2s_v2",
-		VCPU:         2,
-		MemoryMb:     4096,
-		GPU:          0,
-	},
-	"Standard_F32s_v2": {
-		InstanceType: "Standard_F32s_v2",
-		VCPU:         32,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_F4": {
-		InstanceType: "Standard_F4",
-		VCPU:         4,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_F48s_v2": {
-		InstanceType: "Standard_F48s_v2",
-		VCPU:         48,
-		MemoryMb:     98304,
-		GPU:          0,
-	},
-	"Standard_F4s": {
-		InstanceType: "Standard_F4s",
-		VCPU:         4,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_F4s_v2": {
-		InstanceType: "Standard_F4s_v2",
-		VCPU:         4,
-		MemoryMb:     8192,
-		GPU:          0,
-	},
-	"Standard_F64s_v2": {
-		InstanceType: "Standard_F64s_v2",
-		VCPU:         64,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_F72s_v2": {
-		InstanceType: "Standard_F72s_v2",
-		VCPU:         72,
-		MemoryMb:     147456,
-		GPU:          0,
-	},
-	"Standard_F8": {
-		InstanceType: "Standard_F8",
-		VCPU:         8,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_F8s": {
-		InstanceType: "Standard_F8s",
-		VCPU:         8,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_F8s_v2": {
-		InstanceType: "Standard_F8s_v2",
-		VCPU:         8,
-		MemoryMb:     16384,
-		GPU:          0,
-	},
-	"Standard_FX12mds": {
-		InstanceType: "Standard_FX12mds",
-		VCPU:         12,
-		MemoryMb:     258048,
-		GPU:          0,
-	},
-	"Standard_FX24mds": {
-		InstanceType: "Standard_FX24mds",
-		VCPU:         24,
-		MemoryMb:     516096,
-		GPU:          0,
-	},
-	"Standard_FX36mds": {
-		InstanceType: "Standard_FX36mds",
-		VCPU:         36,
-		MemoryMb:     774144,
-		GPU:          0,
-	},
-	"Standard_FX48mds": {
-		InstanceType: "Standard_FX48mds",
-		VCPU:         48,
-		MemoryMb:     1032192,
-		GPU:          0,
-	},
-	"Standard_FX4mds": {
-		InstanceType: "Standard_FX4mds",
-		VCPU:         4,
-		MemoryMb:     86016,
-		GPU:          0,
-	},
-	"Standard_G1": {
-		InstanceType: "Standard_G1",
-		VCPU:         2,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_G2": {
-		InstanceType: "Standard_G2",
-		VCPU:         4,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_G3": {
-		InstanceType: "Standard_G3",
-		VCPU:         8,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_G4": {
-		InstanceType: "Standard_G4",
-		VCPU:         16,
-		MemoryMb:     229376,
-		GPU:          0,
-	},
-	"Standard_G5": {
-		InstanceType: "Standard_G5",
-		VCPU:         32,
-		MemoryMb:     458752,
-		GPU:          0,
-	},
-	"Standard_GS1": {
-		InstanceType: "Standard_GS1",
-		VCPU:         2,
-		MemoryMb:     28672,
-		GPU:          0,
-	},
-	"Standard_GS2": {
-		InstanceType: "Standard_GS2",
-		VCPU:         4,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_GS3": {
-		InstanceType: "Standard_GS3",
-		VCPU:         8,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_GS4": {
-		InstanceType: "Standard_GS4",
-		VCPU:         16,
-		MemoryMb:     229376,
-		GPU:          0,
-	},
-	"Standard_GS4-4": {
-		InstanceType: "Standard_GS4-4",
-		VCPU:         16,
-		MemoryMb:     229376,
-		GPU:          0,
-	},
-	"Standard_GS4-8": {
-		InstanceType: "Standard_GS4-8",
-		VCPU:         16,
-		MemoryMb:     229376,
-		GPU:          0,
-	},
-	"Standard_GS5": {
-		InstanceType: "Standard_GS5",
-		VCPU:         32,
-		MemoryMb:     458752,
-		GPU:          0,
-	},
-	"Standard_GS5-16": {
-		InstanceType: "Standard_GS5-16",
-		VCPU:         32,
-		MemoryMb:     458752,
-		GPU:          0,
-	},
-	"Standard_GS5-8": {
-		InstanceType: "Standard_GS5-8",
-		VCPU:         32,
-		MemoryMb:     458752,
-		GPU:          0,
-	},
-	"Standard_H16": {
-		InstanceType: "Standard_H16",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_H16_Promo": {
-		InstanceType: "Standard_H16_Promo",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_H16m": {
-		InstanceType: "Standard_H16m",
-		VCPU:         16,
-		MemoryMb:     229376,
-		GPU:          0,
-	},
-	"Standard_H16m_Promo": {
-		InstanceType: "Standard_H16m_Promo",
-		VCPU:         16,
-		MemoryMb:     229376,
-		GPU:          0,
-	},
-	"Standard_H16mr": {
-		InstanceType: "Standard_H16mr",
-		VCPU:         16,
-		MemoryMb:     229376,
-		GPU:          0,
-	},
-	"Standard_H16mr_Promo": {
-		InstanceType: "Standard_H16mr_Promo",
-		VCPU:         16,
-		MemoryMb:     229376,
-		GPU:          0,
-	},
-	"Standard_H16r": {
-		InstanceType: "Standard_H16r",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_H16r_Promo": {
-		InstanceType: "Standard_H16r_Promo",
-		VCPU:         16,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_H8": {
-		InstanceType: "Standard_H8",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_H8_Promo": {
-		InstanceType: "Standard_H8_Promo",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          0,
-	},
-	"Standard_H8m": {
-		InstanceType: "Standard_H8m",
-		VCPU:         8,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_H8m_Promo": {
-		InstanceType: "Standard_H8m_Promo",
-		VCPU:         8,
-		MemoryMb:     114688,
-		GPU:          0,
-	},
-	"Standard_HB120-16rs_v3": {
-		InstanceType: "Standard_HB120-16rs_v3",
-		VCPU:         120,
-		MemoryMb:     458752,
-		GPU:          0,
-	},
-	"Standard_HB120-32rs_v3": {
-		InstanceType: "Standard_HB120-32rs_v3",
-		VCPU:         120,
-		MemoryMb:     458752,
-		GPU:          0,
-	},
-	"Standard_HB120-64rs_v3": {
-		InstanceType: "Standard_HB120-64rs_v3",
-		VCPU:         120,
-		MemoryMb:     458752,
-		GPU:          0,
-	},
-	"Standard_HB120-96rs_v3": {
-		InstanceType: "Standard_HB120-96rs_v3",
-		VCPU:         120,
-		MemoryMb:     458752,
-		GPU:          0,
-	},
-	"Standard_HB120rs_v2": {
-		InstanceType: "Standard_HB120rs_v2",
-		VCPU:         120,
-		MemoryMb:     466944,
-		GPU:          0,
-	},
-	"Standard_HB120rs_v3": {
-		InstanceType: "Standard_HB120rs_v3",
-		VCPU:         120,
-		MemoryMb:     458752,
-		GPU:          0,
-	},
-	"Standard_HB60rs": {
-		InstanceType: "Standard_HB60rs",
-		VCPU:         60,
-		MemoryMb:     233472,
-		GPU:          0,
-	},
-	"Standard_HC44rs": {
-		InstanceType: "Standard_HC44rs",
-		VCPU:         44,
-		MemoryMb:     360448,
-		GPU:          0,
-	},
-	"Standard_L16s": {
-		InstanceType: "Standard_L16s",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_L16s_v2": {
-		InstanceType: "Standard_L16s_v2",
-		VCPU:         16,
-		MemoryMb:     131072,
-		GPU:          0,
-	},
-	"Standard_L32s": {
-		InstanceType: "Standard_L32s",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_L32s_v2": {
-		InstanceType: "Standard_L32s_v2",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_L48s_v2": {
-		InstanceType: "Standard_L48s_v2",
-		VCPU:         48,
-		MemoryMb:     393216,
-		GPU:          0,
-	},
-	"Standard_L4s": {
-		InstanceType: "Standard_L4s",
-		VCPU:         4,
-		MemoryMb:     32768,
-		GPU:          0,
-	},
-	"Standard_L64s_v2": {
-		InstanceType: "Standard_L64s_v2",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_L80s_v2": {
-		InstanceType: "Standard_L80s_v2",
-		VCPU:         80,
-		MemoryMb:     655360,
-		GPU:          0,
-	},
-	"Standard_L8s": {
-		InstanceType: "Standard_L8s",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_L8s_v2": {
-		InstanceType: "Standard_L8s_v2",
-		VCPU:         8,
-		MemoryMb:     65536,
-		GPU:          0,
-	},
-	"Standard_M128": {
-		InstanceType: "Standard_M128",
-		VCPU:         128,
-		MemoryMb:     2048000,
-		GPU:          0,
-	},
-	"Standard_M128-32ms": {
-		InstanceType: "Standard_M128-32ms",
-		VCPU:         128,
-		MemoryMb:     3891200,
-		GPU:          0,
-	},
-	"Standard_M128-64ms": {
-		InstanceType: "Standard_M128-64ms",
-		VCPU:         128,
-		MemoryMb:     3891200,
-		GPU:          0,
-	},
-	"Standard_M128dms_v2": {
-		InstanceType: "Standard_M128dms_v2",
-		VCPU:         128,
-		MemoryMb:     3985408,
-		GPU:          0,
-	},
-	"Standard_M128ds_v2": {
-		InstanceType: "Standard_M128ds_v2",
-		VCPU:         128,
-		MemoryMb:     2097152,
-		GPU:          0,
-	},
-	"Standard_M128m": {
-		InstanceType: "Standard_M128m",
-		VCPU:         128,
-		MemoryMb:     3891200,
-		GPU:          0,
-	},
-	"Standard_M128ms": {
-		InstanceType: "Standard_M128ms",
-		VCPU:         128,
-		MemoryMb:     3891200,
-		GPU:          0,
-	},
-	"Standard_M128ms_v2": {
-		InstanceType: "Standard_M128ms_v2",
-		VCPU:         128,
-		MemoryMb:     3985408,
-		GPU:          0,
-	},
-	"Standard_M128s": {
-		InstanceType: "Standard_M128s",
-		VCPU:         128,
-		MemoryMb:     2048000,
-		GPU:          0,
-	},
-	"Standard_M128s_v2": {
-		InstanceType: "Standard_M128s_v2",
-		VCPU:         128,
-		MemoryMb:     2097152,
-		GPU:          0,
-	},
-	"Standard_M16-4ms": {
-		InstanceType: "Standard_M16-4ms",
-		VCPU:         16,
-		MemoryMb:     447488,
-		GPU:          0,
-	},
-	"Standard_M16-8ms": {
-		InstanceType: "Standard_M16-8ms",
-		VCPU:         16,
-		MemoryMb:     447488,
-		GPU:          0,
-	},
-	"Standard_M16ms": {
-		InstanceType: "Standard_M16ms",
-		VCPU:         16,
-		MemoryMb:     447488,
-		GPU:          0,
-	},
-	"Standard_M192idms_v2": {
-		InstanceType: "Standard_M192idms_v2",
-		VCPU:         192,
-		MemoryMb:     4194304,
-		GPU:          0,
-	},
-	"Standard_M192ids_v2": {
-		InstanceType: "Standard_M192ids_v2",
-		VCPU:         192,
-		MemoryMb:     2097152,
-		GPU:          0,
-	},
-	"Standard_M192ims_v2": {
-		InstanceType: "Standard_M192ims_v2",
-		VCPU:         192,
-		MemoryMb:     4194304,
-		GPU:          0,
-	},
-	"Standard_M192is_v2": {
-		InstanceType: "Standard_M192is_v2",
-		VCPU:         192,
-		MemoryMb:     2097152,
-		GPU:          0,
-	},
-	"Standard_M208ms_v2": {
-		InstanceType: "Standard_M208ms_v2",
-		VCPU:         208,
-		MemoryMb:     5836800,
-		GPU:          0,
-	},
-	"Standard_M208s_v2": {
-		InstanceType: "Standard_M208s_v2",
-		VCPU:         208,
-		MemoryMb:     2918400,
-		GPU:          0,
-	},
-	"Standard_M32-16ms": {
-		InstanceType: "Standard_M32-16ms",
-		VCPU:         32,
-		MemoryMb:     896000,
-		GPU:          0,
-	},
-	"Standard_M32-8ms": {
-		InstanceType: "Standard_M32-8ms",
-		VCPU:         32,
-		MemoryMb:     896000,
-		GPU:          0,
-	},
-	"Standard_M32dms_v2": {
-		InstanceType: "Standard_M32dms_v2",
-		VCPU:         32,
-		MemoryMb:     896000,
-		GPU:          0,
-	},
-	"Standard_M32ls": {
-		InstanceType: "Standard_M32ls",
-		VCPU:         32,
-		MemoryMb:     262144,
-		GPU:          0,
-	},
-	"Standard_M32ms": {
-		InstanceType: "Standard_M32ms",
-		VCPU:         32,
-		MemoryMb:     896000,
-		GPU:          0,
-	},
-	"Standard_M32ms_v2": {
-		InstanceType: "Standard_M32ms_v2",
-		VCPU:         32,
-		MemoryMb:     896000,
-		GPU:          0,
-	},
-	"Standard_M32ts": {
-		InstanceType: "Standard_M32ts",
-		VCPU:         32,
-		MemoryMb:     196608,
-		GPU:          0,
-	},
-	"Standard_M416-208ms_v2": {
-		InstanceType: "Standard_M416-208ms_v2",
-		VCPU:         416,
-		MemoryMb:     11673600,
-		GPU:          0,
-	},
-	"Standard_M416-208s_v2": {
-		InstanceType: "Standard_M416-208s_v2",
-		VCPU:         416,
-		MemoryMb:     5836800,
-		GPU:          0,
-	},
-	"Standard_M416ms_v2": {
-		InstanceType: "Standard_M416ms_v2",
-		VCPU:         416,
-		MemoryMb:     11673600,
-		GPU:          0,
-	},
-	"Standard_M416s_v2": {
-		InstanceType: "Standard_M416s_v2",
-		VCPU:         416,
-		MemoryMb:     5836800,
-		GPU:          0,
-	},
-	"Standard_M64": {
-		InstanceType: "Standard_M64",
-		VCPU:         64,
-		MemoryMb:     1024000,
-		GPU:          0,
-	},
-	"Standard_M64-16ms": {
-		InstanceType: "Standard_M64-16ms",
-		VCPU:         64,
-		MemoryMb:     1792000,
-		GPU:          0,
-	},
-	"Standard_M64-32ms": {
-		InstanceType: "Standard_M64-32ms",
-		VCPU:         64,
-		MemoryMb:     1792000,
-		GPU:          0,
-	},
-	"Standard_M64dms_v2": {
-		InstanceType: "Standard_M64dms_v2",
-		VCPU:         64,
-		MemoryMb:     1835008,
-		GPU:          0,
-	},
-	"Standard_M64ds_v2": {
-		InstanceType: "Standard_M64ds_v2",
-		VCPU:         64,
-		MemoryMb:     1048576,
-		GPU:          0,
-	},
-	"Standard_M64ls": {
-		InstanceType: "Standard_M64ls",
-		VCPU:         64,
-		MemoryMb:     524288,
-		GPU:          0,
-	},
-	"Standard_M64m": {
-		InstanceType: "Standard_M64m",
-		VCPU:         64,
-		MemoryMb:     1792000,
-		GPU:          0,
-	},
-	"Standard_M64ms": {
-		InstanceType: "Standard_M64ms",
-		VCPU:         64,
-		MemoryMb:     1792000,
-		GPU:          0,
-	},
-	"Standard_M64ms_v2": {
-		InstanceType: "Standard_M64ms_v2",
-		VCPU:         64,
-		MemoryMb:     1835008,
-		GPU:          0,
-	},
-	"Standard_M64s": {
-		InstanceType: "Standard_M64s",
-		VCPU:         64,
-		MemoryMb:     1024000,
-		GPU:          0,
-	},
-	"Standard_M64s_v2": {
-		InstanceType: "Standard_M64s_v2",
-		VCPU:         64,
-		MemoryMb:     1048576,
-		GPU:          0,
-	},
-	"Standard_M8-2ms": {
-		InstanceType: "Standard_M8-2ms",
-		VCPU:         8,
-		MemoryMb:     223232,
-		GPU:          0,
-	},
-	"Standard_M8-4ms": {
-		InstanceType: "Standard_M8-4ms",
-		VCPU:         8,
-		MemoryMb:     223232,
-		GPU:          0,
-	},
-	"Standard_M8ms": {
-		InstanceType: "Standard_M8ms",
-		VCPU:         8,
-		MemoryMb:     223232,
-		GPU:          0,
-	},
-	"Standard_NC12": {
-		InstanceType: "Standard_NC12",
-		VCPU:         12,
-		MemoryMb:     114688,
-		GPU:          2,
-	},
-	"Standard_NC12_Promo": {
-		InstanceType: "Standard_NC12_Promo",
-		VCPU:         12,
-		MemoryMb:     114688,
-		GPU:          2,
-	},
-	"Standard_NC12s_v2": {
-		InstanceType: "Standard_NC12s_v2",
-		VCPU:         12,
-		MemoryMb:     229376,
-		GPU:          2,
-	},
-	"Standard_NC12s_v3": {
-		InstanceType: "Standard_NC12s_v3",
-		VCPU:         12,
-		MemoryMb:     229376,
-		GPU:          2,
-	},
-	"Standard_NC16as_T4_v3": {
-		InstanceType: "Standard_NC16as_T4_v3",
-		VCPU:         16,
-		MemoryMb:     112640,
-		GPU:          1,
-	},
-	"Standard_NC24": {
-		InstanceType: "Standard_NC24",
-		VCPU:         24,
-		MemoryMb:     229376,
-		GPU:          4,
-	},
-	"Standard_NC24_Promo": {
-		InstanceType: "Standard_NC24_Promo",
-		VCPU:         24,
-		MemoryMb:     229376,
-		GPU:          4,
-	},
-	"Standard_NC24r": {
-		InstanceType: "Standard_NC24r",
-		VCPU:         24,
-		MemoryMb:     229376,
-		GPU:          4,
-	},
-	"Standard_NC24r_Promo": {
-		InstanceType: "Standard_NC24r_Promo",
-		VCPU:         24,
-		MemoryMb:     229376,
-		GPU:          4,
-	},
-	"Standard_NC24rs_v2": {
-		InstanceType: "Standard_NC24rs_v2",
-		VCPU:         24,
-		MemoryMb:     458752,
-		GPU:          4,
-	},
-	"Standard_NC24rs_v3": {
-		InstanceType: "Standard_NC24rs_v3",
-		VCPU:         24,
-		MemoryMb:     458752,
-		GPU:          4,
-	},
-	"Standard_NC24s_v2": {
-		InstanceType: "Standard_NC24s_v2",
-		VCPU:         24,
-		MemoryMb:     458752,
-		GPU:          4,
-	},
-	"Standard_NC24s_v3": {
-		InstanceType: "Standard_NC24s_v3",
-		VCPU:         24,
-		MemoryMb:     458752,
-		GPU:          4,
-	},
-	"Standard_NC4as_T4_v3": {
-		InstanceType: "Standard_NC4as_T4_v3",
-		VCPU:         4,
-		MemoryMb:     28672,
-		GPU:          1,
-	},
-	"Standard_NC6": {
-		InstanceType: "Standard_NC6",
-		VCPU:         6,
-		MemoryMb:     57344,
-		GPU:          1,
-	},
-	"Standard_NC64as_T4_v3": {
-		InstanceType: "Standard_NC64as_T4_v3",
-		VCPU:         64,
-		MemoryMb:     450560,
-		GPU:          4,
-	},
-	"Standard_NC6_Promo": {
-		InstanceType: "Standard_NC6_Promo",
-		VCPU:         6,
-		MemoryMb:     57344,
-		GPU:          1,
-	},
-	"Standard_NC6s_v2": {
-		InstanceType: "Standard_NC6s_v2",
-		VCPU:         6,
-		MemoryMb:     114688,
-		GPU:          1,
-	},
-	"Standard_NC6s_v3": {
-		InstanceType: "Standard_NC6s_v3",
-		VCPU:         6,
-		MemoryMb:     114688,
-		GPU:          1,
-	},
-	"Standard_NC8as_T4_v3": {
-		InstanceType: "Standard_NC8as_T4_v3",
-		VCPU:         8,
-		MemoryMb:     57344,
-		GPU:          1,
-	},
-	"Standard_ND12s": {
-		InstanceType: "Standard_ND12s",
-		VCPU:         12,
-		MemoryMb:     229376,
-		GPU:          2,
-	},
-	"Standard_ND24rs": {
-		InstanceType: "Standard_ND24rs",
-		VCPU:         24,
-		MemoryMb:     458752,
-		GPU:          4,
-	},
-	"Standard_ND24s": {
-		InstanceType: "Standard_ND24s",
-		VCPU:         24,
-		MemoryMb:     458752,
-		GPU:          4,
-	},
-	"Standard_ND40rs_v2": {
-		InstanceType: "Standard_ND40rs_v2",
-		VCPU:         40,
-		MemoryMb:     688128,
-		GPU:          8,
-	},
-	"Standard_ND6s": {
-		InstanceType: "Standard_ND6s",
-		VCPU:         6,
-		MemoryMb:     114688,
-		GPU:          1,
-	},
-	"Standard_ND96amsr_A100_v4": {
-		InstanceType: "Standard_ND96amsr_A100_v4",
-		VCPU:         96,
-		MemoryMb:     1970176,
-		GPU:          8,
-	},
-	"Standard_NV12": {
-		InstanceType: "Standard_NV12",
-		VCPU:         12,
-		MemoryMb:     114688,
-		GPU:          2,
-	},
-	"Standard_NV12_Promo": {
-		InstanceType: "Standard_NV12_Promo",
-		VCPU:         12,
-		MemoryMb:     114688,
-		GPU:          2,
-	},
-	"Standard_NV12s_v2": {
-		InstanceType: "Standard_NV12s_v2",
-		VCPU:         12,
-		MemoryMb:     229376,
-		GPU:          2,
-	},
-	"Standard_NV12s_v3": {
-		InstanceType: "Standard_NV12s_v3",
-		VCPU:         12,
-		MemoryMb:     114688,
-		GPU:          1,
-	},
-	"Standard_NV16as_v4": {
-		InstanceType: "Standard_NV16as_v4",
-		VCPU:         16,
-		MemoryMb:     57344,
-		GPU:          1,
-	},
-	"Standard_NV24": {
-		InstanceType: "Standard_NV24",
-		VCPU:         24,
-		MemoryMb:     229376,
-		GPU:          4,
-	},
-	"Standard_NV24_Promo": {
-		InstanceType: "Standard_NV24_Promo",
-		VCPU:         24,
-		MemoryMb:     229376,
-		GPU:          4,
-	},
-	"Standard_NV24s_v2": {
-		InstanceType: "Standard_NV24s_v2",
-		VCPU:         24,
-		MemoryMb:     458752,
-		GPU:          4,
-	},
-	"Standard_NV24s_v3": {
-		InstanceType: "Standard_NV24s_v3",
-		VCPU:         24,
-		MemoryMb:     229376,
-		GPU:          2,
-	},
-	"Standard_NV32as_v4": {
-		InstanceType: "Standard_NV32as_v4",
-		VCPU:         32,
-		MemoryMb:     114688,
-		GPU:          1,
-	},
-	"Standard_NV48s_v3": {
-		InstanceType: "Standard_NV48s_v3",
-		VCPU:         48,
-		MemoryMb:     458752,
-		GPU:          4,
-	},
-	"Standard_NV4as_v4": {
-		InstanceType: "Standard_NV4as_v4",
-		VCPU:         4,
-		MemoryMb:     14336,
-		GPU:          1,
-	},
-	"Standard_NV6": {
-		InstanceType: "Standard_NV6",
-		VCPU:         6,
-		MemoryMb:     57344,
-		GPU:          1,
-	},
-	"Standard_NV6_Promo": {
-		InstanceType: "Standard_NV6_Promo",
-		VCPU:         6,
-		MemoryMb:     57344,
-		GPU:          1,
-	},
-	"Standard_NV6s_v2": {
-		InstanceType: "Standard_NV6s_v2",
-		VCPU:         6,
-		MemoryMb:     114688,
-		GPU:          1,
-	},
-	"Standard_NV8as_v4": {
-		InstanceType: "Standard_NV8as_v4",
-		VCPU:         8,
-		MemoryMb:     28672,
-		GPU:          1,
-	},
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_instance_types/gen.go b/cluster-autoscaler/cloudprovider/azure/azure_instance_types/gen.go
deleted file mode 100644
index 55308a505..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_instance_types/gen.go
+++ /dev/null
@@ -1,164 +0,0 @@
-// +build ignore
-
-/*
-Copyright 2019 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package main
-
-import (
-	"encoding/json"
-	"html/template"
-	"io/ioutil"
-	"os"
-	"os/exec"
-	"strconv"
-	"strings"
-
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/azure"
-	klog "k8s.io/klog/v2"
-)
-
-var packageTemplate = template.Must(template.New("").Parse(`/*
-Copyright The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-// This file was generated by go generate; DO NOT EDIT
-
-package azure
-
-// InstanceType is the sepc of Azure instance
-type InstanceType struct {
-	InstanceType string
-	VCPU         int64
-	MemoryMb     int64
-	GPU          int64
-}
-
-// InstanceTypes is a map of azure resources
-var InstanceTypes = map[string]*InstanceType{
-{{- range .InstanceTypes }}
-	"{{ .InstanceType }}": {
-		InstanceType: "{{ .InstanceType }}",
-		VCPU:         {{ .VCPU }},
-		MemoryMb:     {{ .MemoryMb }},
-		GPU:          {{ .GPU }},
-	},
-{{- end }}
-}
-`))
-
-type InstanceCapabilities struct {
-	Name  string
-	Value string
-}
-
-type RawInstanceType struct {
-	Name         string
-	ResourceType string
-	Capabilities []InstanceCapabilities
-}
-
-func getAllAzureVirtualMachineTypes() (result map[string]*azure.InstanceType, err error) {
-	cmd := exec.Command("az", "vm", "list-skus", "-o", "json")
-	stdout, err := cmd.StdoutPipe()
-	if err != nil {
-		return nil, err
-	}
-	if err = cmd.Start(); err != nil {
-		return nil, err
-	}
-	bytes, err := ioutil.ReadAll(stdout)
-	if err != nil {
-		return nil, err
-	}
-
-	if err := cmd.Wait(); err != nil {
-		return nil, err
-	}
-
-	allInstances := make([]RawInstanceType, 0)
-	err = json.Unmarshal(bytes, &allInstances)
-	if err != nil {
-		return nil, err
-	}
-
-	virtualMachines := make(map[string]*azure.InstanceType)
-	for _, instance := range allInstances {
-		if strings.EqualFold(instance.ResourceType, "virtualMachines") {
-			var virtualMachine azure.InstanceType
-			virtualMachine.InstanceType = instance.Name
-			for _, capability := range instance.Capabilities {
-				switch capability.Name {
-				case "vCPUs":
-					virtualMachine.VCPU, err = strconv.ParseInt(capability.Value, 10, 64)
-					if err != nil {
-						return nil, err
-					}
-				case "MemoryGB":
-					memoryMb, err := strconv.ParseFloat(capability.Value, 10)
-					if err != nil {
-						return nil, err
-					}
-					virtualMachine.MemoryMb = int64(memoryMb) * 1024
-				case "GPUs":
-					virtualMachine.GPU, err = strconv.ParseInt(capability.Value, 10, 64)
-					if err != nil {
-						return nil, err
-					}
-				}
-			}
-			virtualMachines[virtualMachine.InstanceType] = &virtualMachine
-		}
-	}
-
-	return virtualMachines, err
-}
-
-func main() {
-	instanceTypes, err := getAllAzureVirtualMachineTypes()
-	if err != nil {
-		klog.Fatal(err)
-	}
-
-	f, err := os.Create("azure_instance_types.go")
-	if err != nil {
-		klog.Fatal(err)
-	}
-
-	defer f.Close()
-
-	err = packageTemplate.Execute(f, struct {
-		InstanceTypes map[string]*azure.InstanceType
-	}{
-		InstanceTypes: instanceTypes,
-	})
-
-	if err != nil {
-		klog.Fatal(err)
-	}
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_kubernetes_sercice_pool_test.go b/cluster-autoscaler/cloudprovider/azure/azure_kubernetes_sercice_pool_test.go
deleted file mode 100644
index 1fbcb8aaa..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_kubernetes_sercice_pool_test.go
+++ /dev/null
@@ -1,419 +0,0 @@
-/*
-Copyright 2020 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"fmt"
-	"net/http"
-	"testing"
-	"time"
-
-	"github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2019-12-01/compute"
-	"github.com/Azure/azure-sdk-for-go/services/containerservice/mgmt/2020-04-01/containerservice"
-	"github.com/Azure/go-autorest/autorest/to"
-	"github.com/golang/mock/gomock"
-	"github.com/stretchr/testify/assert"
-
-	apiv1 "k8s.io/api/core/v1"
-	"k8s.io/legacy-cloud-providers/azure/clients/containerserviceclient/mockcontainerserviceclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/interfaceclient/mockinterfaceclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/vmclient/mockvmclient"
-	"k8s.io/legacy-cloud-providers/azure/retry"
-)
-
-const (
-	testAKSPoolName = "aks"
-)
-
-var (
-	errInternal    = &retry.Error{HTTPStatusCode: http.StatusInternalServerError}
-	errInternalRaw = fmt.Errorf("Retriable: false, RetryAfter: 0s, HTTPStatusCode: 500, RawError: <nil>")
-)
-
-func getTestAKSPool(manager *AzureManager, name string) *AKSAgentPool {
-	return &AKSAgentPool{
-		azureRef: azureRef{
-			Name: name,
-		},
-		manager:           manager,
-		minSize:           1,
-		maxSize:           10,
-		resourceGroup:     "rg",
-		nodeResourceGroup: "rg",
-		clusterName:       "cluster",
-		curSize:           5,
-		util: &AzUtil{
-			manager: manager,
-		},
-	}
-}
-
-func getExpectedManagedCluster() containerservice.ManagedCluster {
-	return containerservice.ManagedCluster{
-		Name: to.StringPtr("cluster"),
-		ManagedClusterProperties: &containerservice.ManagedClusterProperties{
-			AgentPoolProfiles: &[]containerservice.ManagedClusterAgentPoolProfile{
-				{
-					Name:  to.StringPtr(testAKSPoolName),
-					Count: to.Int32Ptr(1),
-				},
-			},
-		},
-	}
-}
-
-func TestSetNodeCount(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	aksPool := getTestAKSPool(newTestAzureManager(t), testAKSPoolName)
-	mockAKSClient := mockcontainerserviceclient.NewMockInterface(ctrl)
-	mockAKSClient.EXPECT().Get(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName).Return(getExpectedManagedCluster(), nil)
-	mockAKSClient.EXPECT().CreateOrUpdate(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName,
-		gomock.Any(),
-		gomock.Any()).Return(nil)
-	aksPool.manager.azClient.managedKubernetesServicesClient = mockAKSClient
-
-	err := aksPool.SetNodeCount(3)
-	assert.NoError(t, err)
-
-	mockAKSClient.EXPECT().Get(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName).Return(getExpectedManagedCluster(), errInternal)
-	err = aksPool.SetNodeCount(3)
-	expectedErr := errInternalRaw
-	assert.Equal(t, expectedErr, err)
-
-	mockAKSClient.EXPECT().Get(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName).Return(containerservice.ManagedCluster{
-		ManagedClusterProperties: &containerservice.ManagedClusterProperties{
-			AgentPoolProfiles: &[]containerservice.ManagedClusterAgentPoolProfile{},
-		},
-	}, nil)
-	err = aksPool.SetNodeCount(3)
-	expectedErr = fmt.Errorf("could not find pool with name: {aks}")
-	assert.Equal(t, expectedErr, err)
-
-	mockAKSClient.EXPECT().Get(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName).Return(getExpectedManagedCluster(), nil)
-	mockAKSClient.EXPECT().CreateOrUpdate(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName,
-		gomock.Any(),
-		gomock.Any()).Return(errInternal)
-	err = aksPool.SetNodeCount(3)
-	expectedErr = errInternalRaw
-	assert.Equal(t, expectedErr, err)
-}
-
-func TestGetNodeCount(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	aksPool := getTestAKSPool(newTestAzureManager(t), testAKSPoolName)
-	mockAKSClient := mockcontainerserviceclient.NewMockInterface(ctrl)
-	mockAKSClient.EXPECT().Get(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName).Return(getExpectedManagedCluster(), nil)
-	aksPool.manager.azClient.managedKubernetesServicesClient = mockAKSClient
-
-	count, err := aksPool.GetNodeCount()
-	assert.Equal(t, 1, count)
-	assert.NoError(t, err)
-
-	mockAKSClient.EXPECT().Get(gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName).Return(getExpectedManagedCluster(), errInternal)
-	count, err = aksPool.GetNodeCount()
-	expectedErr := errInternalRaw
-	assert.Equal(t, -1, count)
-	assert.Equal(t, expectedErr, err)
-
-	mockAKSClient.EXPECT().Get(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName).Return(containerservice.ManagedCluster{
-		ManagedClusterProperties: &containerservice.ManagedClusterProperties{
-			AgentPoolProfiles: &[]containerservice.ManagedClusterAgentPoolProfile{},
-		},
-	}, nil)
-	count, err = aksPool.GetNodeCount()
-	expectedErr = fmt.Errorf("could not find pool with name: {aks}")
-	assert.Equal(t, -1, count)
-	assert.Equal(t, expectedErr, err)
-
-	mockAKSClient.EXPECT().Get(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName).Return(containerservice.ManagedCluster{}, errInternal)
-	count, err = aksPool.GetNodeCount()
-	assert.Equal(t, -1, count)
-	assert.Equal(t, err, errInternalRaw)
-}
-
-func TestAKSTargetSize(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	aksPool := getTestAKSPool(newTestAzureManager(t), testAKSPoolName)
-	mockAKSClient := mockcontainerserviceclient.NewMockInterface(ctrl)
-	mockAKSClient.EXPECT().Get(gomock.Any(), aksPool.resourceGroup, aksPool.clusterName).Return(getExpectedManagedCluster(), nil)
-	aksPool.manager.azClient.managedKubernetesServicesClient = mockAKSClient
-
-	aksPool.lastRefresh = time.Now()
-	size, err := aksPool.TargetSize()
-	assert.Equal(t, 5, size)
-	assert.NoError(t, err)
-
-	aksPool.lastRefresh = time.Now().Add(-1 * 20 * time.Second)
-	size, err = aksPool.TargetSize()
-	assert.Equal(t, 1, size)
-	assert.NoError(t, err)
-}
-
-func TestAKSSetSize(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	tests := []struct {
-		targetSize    int
-		isScalingDown bool
-		expectedSize  int
-		expectedErr   error
-	}{
-		{
-			targetSize:    0,
-			isScalingDown: true,
-			expectedSize:  5,
-			expectedErr:   fmt.Errorf("size-decreasing request of 0 is smaller than min size 1"),
-		},
-		{
-			targetSize:   3,
-			expectedSize: 3,
-		},
-	}
-
-	for _, test := range tests {
-		aksPool := getTestAKSPool(newTestAzureManager(t), testAKSPoolName)
-		mockAKSClient := mockcontainerserviceclient.NewMockInterface(ctrl)
-		mockAKSClient.EXPECT().Get(
-			gomock.Any(),
-			aksPool.resourceGroup,
-			aksPool.clusterName).Return(getExpectedManagedCluster(), nil).MaxTimes(1)
-		mockAKSClient.EXPECT().CreateOrUpdate(
-			gomock.Any(),
-			aksPool.resourceGroup,
-			aksPool.clusterName,
-			gomock.Any(),
-			gomock.Any()).Return(nil).MaxTimes(1)
-		aksPool.manager.azClient.managedKubernetesServicesClient = mockAKSClient
-
-		err := aksPool.SetSize(test.targetSize, test.isScalingDown)
-		assert.Equal(t, test.expectedErr, err)
-		assert.Equal(t, test.expectedSize, aksPool.curSize)
-	}
-}
-
-func TestAKSIncreaseSize(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	aksPool := getTestAKSPool(newTestAzureManager(t), testAKSPoolName)
-	aksPool.lastRefresh = time.Now()
-
-	err := aksPool.IncreaseSize(-1)
-	assert.Equal(t, fmt.Errorf("size increase must be +ve"), err)
-
-	err = aksPool.IncreaseSize(6)
-	assert.Equal(t, fmt.Errorf("size-increasing request of 11 is bigger than max size 10"), err)
-
-	mockAKSClient := mockcontainerserviceclient.NewMockInterface(ctrl)
-	mockAKSClient.EXPECT().Get(gomock.Any(), aksPool.resourceGroup, aksPool.clusterName).Return(getExpectedManagedCluster(), nil)
-	mockAKSClient.EXPECT().CreateOrUpdate(gomock.Any(), aksPool.resourceGroup, aksPool.clusterName, gomock.Any(), gomock.Any()).Return(nil)
-	aksPool.manager.azClient.managedKubernetesServicesClient = mockAKSClient
-
-	err = aksPool.IncreaseSize(3)
-	assert.NoError(t, err)
-}
-
-func TestIsAKSNode(t *testing.T) {
-	aksPool := getTestAKSPool(newTestAzureManager(t), testAKSPoolName)
-	tags := map[string]*string{"poolName": to.StringPtr(testAKSPoolName)}
-	isAKSNode := aksPool.IsAKSNode(tags)
-	assert.True(t, isAKSNode)
-
-	tags = map[string]*string{"poolName": to.StringPtr("fake")}
-	isAKSNode = aksPool.IsAKSNode(tags)
-	assert.False(t, isAKSNode)
-}
-
-func TestDeleteNodesAKS(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	expectedVMs := []compute.VirtualMachine{
-		{
-			ID:   to.StringPtr("id1"),
-			Name: to.StringPtr("vm1"),
-			VirtualMachineProperties: &compute.VirtualMachineProperties{
-				NetworkProfile: &compute.NetworkProfile{
-					NetworkInterfaces: &[]compute.NetworkInterfaceReference{
-						{ID: to.StringPtr("id")},
-					},
-				},
-				StorageProfile: &compute.StorageProfile{
-					OsDisk: &compute.OSDisk{
-						ManagedDisk: &compute.ManagedDiskParameters{},
-					},
-				},
-			},
-		},
-	}
-
-	aksPool := getTestAKSPool(newTestAzureManager(t), testAKSPoolName)
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	mockVMClient.EXPECT().List(gomock.Any(), aksPool.nodeResourceGroup).Return(expectedVMs, nil)
-	mockVMClient.EXPECT().Get(
-		gomock.Any(),
-		aksPool.nodeResourceGroup,
-		*expectedVMs[0].Name,
-		gomock.Any()).Return(expectedVMs[0], nil)
-	mockVMClient.EXPECT().Delete(gomock.Any(), aksPool.nodeResourceGroup, *expectedVMs[0].Name)
-	aksPool.manager.azClient.virtualMachinesClient = mockVMClient
-	mockAKSClient := mockcontainerserviceclient.NewMockInterface(ctrl)
-	mockAKSClient.EXPECT().Get(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName).Return(getExpectedManagedCluster(), nil)
-	mockAKSClient.EXPECT().CreateOrUpdate(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName,
-		gomock.Any(),
-		gomock.Any())
-	aksPool.manager.azClient.managedKubernetesServicesClient = mockAKSClient
-	mockNICClient := mockinterfaceclient.NewMockInterface(ctrl)
-	mockNICClient.EXPECT().Delete(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		"id").Return(nil)
-	aksPool.manager.azClient.interfacesClient = mockNICClient
-
-	nodes := []*apiv1.Node{
-		{
-			Spec: apiv1.NodeSpec{
-				ProviderID: "id1",
-			},
-		},
-	}
-	err := aksPool.DeleteNodes(nodes)
-	assert.Equal(t, 4, aksPool.curSize)
-	assert.NoError(t, err)
-}
-
-func TestAKSNodes(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	expectedVMs := []compute.VirtualMachine{
-		{
-			Name: to.StringPtr("name"),
-			ID:   to.StringPtr("/subscriptions/sub/resourceGroups/rg/providers/provider/vm1"),
-			Tags: map[string]*string{"poolName": to.StringPtr(testAKSPoolName)},
-		},
-	}
-
-	aksPool := getTestAKSPool(newTestAzureManager(t), testAKSPoolName)
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	mockVMClient.EXPECT().List(gomock.Any(), aksPool.nodeResourceGroup).Return(expectedVMs, nil)
-	aksPool.manager.azClient.virtualMachinesClient = mockVMClient
-
-	instances, err := aksPool.Nodes()
-	assert.Equal(t, 1, len(instances))
-	assert.NoError(t, err)
-
-	mockVMClient.EXPECT().List(gomock.Any(), aksPool.nodeResourceGroup).Return([]compute.VirtualMachine{}, errInternal)
-	instances, err = aksPool.Nodes()
-	expectedErr := errInternalRaw
-	assert.Nil(t, instances)
-	assert.Equal(t, expectedErr, err)
-
-	expectedVMs[0].ID = to.StringPtr("fakeID")
-	mockVMClient.EXPECT().List(gomock.Any(), aksPool.nodeResourceGroup).Return(expectedVMs, nil)
-	instances, err = aksPool.Nodes()
-	assert.Equal(t, 0, len(instances))
-	assert.NoError(t, err)
-}
-
-func TestAKSDecreaseTargetSize(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	aksPool := getTestAKSPool(newTestAzureManager(t), testAKSPoolName)
-
-	err := aksPool.DecreaseTargetSize(1)
-	expectedErr := fmt.Errorf("size decrease must be negative")
-	assert.Equal(t, expectedErr, err)
-
-	aksPool.lastRefresh = time.Now().Add(-1 * 20 * time.Second)
-
-	mockAKSClient := mockcontainerserviceclient.NewMockInterface(ctrl)
-	expectedMC := getExpectedManagedCluster()
-	(*expectedMC.AgentPoolProfiles)[0].Count = to.Int32Ptr(2)
-	mockAKSClient.EXPECT().Get(gomock.Any(), aksPool.resourceGroup, aksPool.clusterName).Return(expectedMC, nil)
-	aksPool.manager.azClient.managedKubernetesServicesClient = mockAKSClient
-
-	expectedVMs := []compute.VirtualMachine{
-		{
-			Name: to.StringPtr("name"),
-			ID:   to.StringPtr("/subscriptions/sub/resourceGroups/rg/providers/provider/vm1"),
-			Tags: map[string]*string{"poolName": to.StringPtr(testAKSPoolName)},
-		},
-	}
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	mockVMClient.EXPECT().List(gomock.Any(), aksPool.nodeResourceGroup).Return(expectedVMs, nil)
-	aksPool.manager.azClient.virtualMachinesClient = mockVMClient
-
-	mockAKSClient.EXPECT().Get(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName).Return(getExpectedManagedCluster(), nil)
-	mockAKSClient.EXPECT().CreateOrUpdate(
-		gomock.Any(),
-		aksPool.resourceGroup,
-		aksPool.clusterName,
-		gomock.Any(),
-		gomock.Any()).Return(nil)
-	aksPool.manager.azClient.managedKubernetesServicesClient = mockAKSClient
-
-	err = aksPool.DecreaseTargetSize(-1)
-	assert.Equal(t, 1, aksPool.curSize)
-	assert.NoError(t, err)
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_kubernetes_service_pool.go b/cluster-autoscaler/cloudprovider/azure/azure_kubernetes_service_pool.go
deleted file mode 100644
index acd98cf55..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_kubernetes_service_pool.go
+++ /dev/null
@@ -1,442 +0,0 @@
-/*
-Copyright 2018 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"fmt"
-	"strings"
-	"sync"
-	"time"
-
-	"github.com/Azure/azure-sdk-for-go/services/containerservice/mgmt/2020-04-01/containerservice"
-	klog "k8s.io/klog/v2"
-
-	apiv1 "k8s.io/api/core/v1"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-	"k8s.io/autoscaler/cluster-autoscaler/config"
-	"k8s.io/autoscaler/cluster-autoscaler/config/dynamic"
-	schedulerframework "k8s.io/kubernetes/pkg/scheduler/framework"
-)
-
-//AKSAgentPool implements NodeGroup interface for agent pool deployed in AKS
-type AKSAgentPool struct {
-	azureRef
-	manager *AzureManager
-	util    *AzUtil
-
-	minSize           int
-	maxSize           int
-	clusterName       string
-	resourceGroup     string
-	nodeResourceGroup string
-
-	curSize     int
-	lastRefresh time.Time
-	mutex       sync.Mutex
-}
-
-//NewAKSAgentPool constructs AKSAgentPool from the --node param
-//and azure manager
-func NewAKSAgentPool(spec *dynamic.NodeGroupSpec, am *AzureManager) (*AKSAgentPool, error) {
-	asg := &AKSAgentPool{
-		azureRef: azureRef{
-			Name: spec.Name,
-		},
-		minSize: spec.MinSize,
-		maxSize: spec.MaxSize,
-		manager: am,
-		curSize: -1,
-	}
-
-	asg.util = &AzUtil{
-		manager: am,
-	}
-	asg.clusterName = am.config.ClusterName
-	asg.resourceGroup = am.config.ResourceGroup
-	asg.nodeResourceGroup = am.config.NodeResourceGroup
-
-	return asg, nil
-}
-
-//GetAKSAgentPool is an internal function which figures out ManagedClusterAgentPoolProfile from the list based on the pool name provided in the --node parameter passed
-//to the autoscaler main
-func (agentPool *AKSAgentPool) GetAKSAgentPool(agentProfiles *[]containerservice.ManagedClusterAgentPoolProfile) (ret *containerservice.ManagedClusterAgentPoolProfile) {
-	for _, value := range *agentProfiles {
-		profileName := *value.Name
-		klog.V(5).Infof("AKS AgentPool profile name: %s", profileName)
-		if strings.EqualFold(profileName, agentPool.azureRef.Name) {
-			return &value
-		}
-	}
-
-	return nil
-}
-
-// getAKSNodeCount gets node count for AKS agent pool.
-func (agentPool *AKSAgentPool) getAKSNodeCount() (count int, err error) {
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-
-	managedCluster, rerr := agentPool.manager.azClient.managedKubernetesServicesClient.Get(ctx,
-		agentPool.resourceGroup,
-		agentPool.clusterName)
-	if rerr != nil {
-		klog.Errorf("Failed to get AKS cluster (name:%q): %v", agentPool.clusterName, rerr.Error())
-		return -1, rerr.Error()
-	}
-
-	pool := agentPool.GetAKSAgentPool(managedCluster.AgentPoolProfiles)
-	if pool == nil {
-		return -1, fmt.Errorf("could not find pool with name: %s", agentPool.azureRef)
-	}
-
-	if pool.Count != nil {
-		return int(*pool.Count), nil
-	}
-
-	return 0, nil
-}
-
-// setAKSNodeCount sets node count for AKS agent pool.
-func (agentPool *AKSAgentPool) setAKSNodeCount(count int) error {
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-
-	managedCluster, rerr := agentPool.manager.azClient.managedKubernetesServicesClient.Get(ctx,
-		agentPool.resourceGroup,
-		agentPool.clusterName)
-	if rerr != nil {
-		klog.Errorf("Failed to get AKS cluster (name:%q): %v", agentPool.clusterName, rerr.Error())
-		return rerr.Error()
-	}
-
-	pool := agentPool.GetAKSAgentPool(managedCluster.AgentPoolProfiles)
-	if pool == nil {
-		return fmt.Errorf("could not find pool with name: %s", agentPool.azureRef)
-	}
-
-	klog.Infof("Current size: %d, Target size requested: %d", *pool.Count, count)
-
-	updateCtx, updateCancel := getContextWithCancel()
-	defer updateCancel()
-	*pool.Count = int32(count)
-	aksClient := agentPool.manager.azClient.managedKubernetesServicesClient
-	rerr = aksClient.CreateOrUpdate(updateCtx, agentPool.resourceGroup,
-		agentPool.clusterName, managedCluster, "")
-	if rerr != nil {
-		klog.Errorf("Failed to update AKS cluster (%q): %v", agentPool.clusterName, rerr.Error())
-		return rerr.Error()
-	}
-
-	klog.Infof("aksClient.CreateOrUpdate for aks cluster %q succeeded", agentPool.clusterName)
-	return nil
-}
-
-//GetNodeCount returns the count of nodes from the managed agent pool profile
-func (agentPool *AKSAgentPool) GetNodeCount() (count int, err error) {
-	return agentPool.getAKSNodeCount()
-}
-
-//SetNodeCount sets the count of nodes in the in memory pool profile
-func (agentPool *AKSAgentPool) SetNodeCount(count int) (err error) {
-	return agentPool.setAKSNodeCount(count)
-}
-
-//GetProviderID converts the name of a node into the form that kubernetes cloud
-//provider id is presented in.
-func (agentPool *AKSAgentPool) GetProviderID(name string) string {
-	//TODO: come with a generic way to make it work with provider id formats
-	// in different version of k8s.
-	return "azure://" + name
-}
-
-//GetName extracts the name of the node (a format which underlying cloud service understands)
-//from the cloud providerID (format which kubernetes understands)
-func (agentPool *AKSAgentPool) GetName(providerID string) (string, error) {
-	// Remove the "azure://" string from it
-	providerID = strings.TrimPrefix(providerID, "azure://")
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-	vms, rerr := agentPool.manager.azClient.virtualMachinesClient.List(ctx, agentPool.nodeResourceGroup)
-	if rerr != nil {
-		return "", rerr.Error()
-	}
-	for _, vm := range vms {
-		if strings.EqualFold(*vm.ID, providerID) {
-			return *vm.Name, nil
-		}
-	}
-	return "", fmt.Errorf("VM list empty")
-}
-
-//MaxSize returns the maximum size scale limit provided by --node
-//parameter to the autoscaler main
-func (agentPool *AKSAgentPool) MaxSize() int {
-	return agentPool.maxSize
-}
-
-//MinSize returns the minimum size the cluster is allowed to scaled down
-//to as provided by the node spec in --node parameter.
-func (agentPool *AKSAgentPool) MinSize() int {
-	return agentPool.minSize
-}
-
-//TargetSize gathers the target node count set for the cluster by
-//querying the underlying service.
-func (agentPool *AKSAgentPool) TargetSize() (int, error) {
-	agentPool.mutex.Lock()
-	defer agentPool.mutex.Unlock()
-
-	if agentPool.lastRefresh.Add(15 * time.Second).After(time.Now()) {
-		return agentPool.curSize, nil
-	}
-
-	count, err := agentPool.GetNodeCount()
-	if err != nil {
-		return -1, err
-	}
-	klog.V(5).Infof("Got new size %d for agent pool (%q)", count, agentPool.Name)
-
-	agentPool.curSize = count
-	agentPool.lastRefresh = time.Now()
-	return agentPool.curSize, nil
-}
-
-//SetSize contacts the underlying service and sets the size of the pool.
-//This will be called when a scale up occurs and will be called just after
-//a delete is performed from a scale down.
-func (agentPool *AKSAgentPool) SetSize(targetSize int, isScalingDown bool) (err error) {
-	agentPool.mutex.Lock()
-	defer agentPool.mutex.Unlock()
-
-	return agentPool.setSizeInternal(targetSize, isScalingDown)
-}
-
-// setSizeInternal contacts the underlying service and sets the size of the pool.
-// It should be called under lock protected.
-func (agentPool *AKSAgentPool) setSizeInternal(targetSize int, isScalingDown bool) (err error) {
-	if isScalingDown && targetSize < agentPool.MinSize() {
-		klog.Errorf("size-decreasing request of %d is smaller than min size %d", targetSize, agentPool.MinSize())
-		return fmt.Errorf("size-decreasing request of %d is smaller than min size %d", targetSize, agentPool.MinSize())
-	}
-
-	klog.V(2).Infof("Setting size for cluster (%q) with new count (%d)", agentPool.clusterName, targetSize)
-
-	err = agentPool.setAKSNodeCount(targetSize)
-	if err != nil {
-		return err
-	}
-
-	agentPool.curSize = targetSize
-	agentPool.lastRefresh = time.Now()
-	return nil
-}
-
-//IncreaseSize calls in the underlying SetSize to increase the size in response
-//to a scale up. It calculates the expected size based on a delta provided as
-//parameter
-func (agentPool *AKSAgentPool) IncreaseSize(delta int) error {
-	if delta <= 0 {
-		return fmt.Errorf("size increase must be +ve")
-	}
-	currentSize, err := agentPool.TargetSize()
-	if err != nil {
-		return err
-	}
-	targetSize := currentSize + delta
-	if targetSize > agentPool.MaxSize() {
-		return fmt.Errorf("size-increasing request of %d is bigger than max size %d", targetSize, agentPool.MaxSize())
-	}
-	return agentPool.SetSize(targetSize, false)
-}
-
-// deleteNodesInternal calls the underlying vm service to delete the node.
-// It should be called within lock protected.
-func (agentPool *AKSAgentPool) deleteNodesInternal(providerIDs []string) (deleted int, err error) {
-	for _, providerID := range providerIDs {
-		klog.Infof("ProviderID got to delete: %s", providerID)
-		nodeName, err := agentPool.GetName(providerID)
-		if err != nil {
-			return deleted, err
-		}
-		klog.Infof("VM name got to delete: %s", nodeName)
-
-		err = agentPool.util.DeleteVirtualMachine(agentPool.nodeResourceGroup, nodeName)
-		if err != nil {
-			klog.Errorf("Failed to delete virtual machine %q with error: %v", nodeName, err)
-			return deleted, err
-		}
-
-		// increase the deleted count after delete VM succeed.
-		deleted++
-	}
-
-	return deleted, nil
-}
-
-//DeleteNodes extracts the providerIDs from the node spec and calls into the internal
-//delete method.
-func (agentPool *AKSAgentPool) DeleteNodes(nodes []*apiv1.Node) error {
-	agentPool.mutex.Lock()
-	defer agentPool.mutex.Unlock()
-
-	var providerIDs []string
-	for _, node := range nodes {
-		providerIDs = append(providerIDs, node.Spec.ProviderID)
-	}
-
-	deleted, deleteError := agentPool.deleteNodesInternal(providerIDs)
-	// Update node count if there're some virtual machines got deleted.
-	if deleted != 0 {
-		targetSize := agentPool.curSize - deleted
-		err := agentPool.setSizeInternal(targetSize, true)
-		if err != nil {
-			klog.Errorf("Failed to set size for agent pool %q with error: %v", agentPool.Name, err)
-		} else {
-			klog.V(3).Infof("Size for agent pool %q has been updated to %d", agentPool.Name, targetSize)
-		}
-	}
-	return deleteError
-}
-
-//IsAKSNode checks if the tag from the vm matches the agentPool name
-func (agentPool *AKSAgentPool) IsAKSNode(tags map[string]*string) bool {
-	poolName := tags["poolName"]
-	if poolName != nil {
-		klog.V(5).Infof("Matching agentPool name: %s with tag name: %s", agentPool.azureRef.Name, *poolName)
-		if strings.EqualFold(*poolName, agentPool.azureRef.Name) {
-			return true
-		}
-	}
-	return false
-}
-
-//GetNodes extracts the node list from the underlying vm service and returns back
-//equivalent providerIDs  as list.
-func (agentPool *AKSAgentPool) GetNodes() ([]string, error) {
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-	klog.V(6).Infof("GetNodes: starting list aks node pools in %s", agentPool.nodeResourceGroup)
-	vmList, rerr := agentPool.manager.azClient.virtualMachinesClient.List(ctx, agentPool.nodeResourceGroup)
-	klog.V(6).Infof("GetNodes: list finished, len(vmlist) = %d, err = %s", len(vmList), rerr.Error())
-	if rerr != nil {
-		klog.Errorf("Azure client list vm error : %v", rerr.Error())
-		return nil, rerr.Error()
-	}
-	var nodeArray []string
-	for _, node := range vmList {
-		klog.V(5).Infof("Node Name: %s, ID: %s", *node.Name, *node.ID)
-		if agentPool.IsAKSNode(node.Tags) {
-			providerID, err := convertResourceGroupNameToLower(agentPool.GetProviderID(*node.ID))
-			if err != nil {
-				// This shouldn't happen. Log a waring message for tracking.
-				klog.Warningf("GetNodes.convertResourceGroupNameToLower failed with error: %v", err)
-				continue
-			}
-
-			klog.V(5).Infof("Returning back the providerID: %s", providerID)
-			nodeArray = append(nodeArray, providerID)
-		}
-	}
-	return nodeArray, nil
-}
-
-//DecreaseTargetSize requests the underlying service to decrease the node count.
-func (agentPool *AKSAgentPool) DecreaseTargetSize(delta int) error {
-	if delta >= 0 {
-		klog.Errorf("Size decrease error: %d", delta)
-		return fmt.Errorf("size decrease must be negative")
-	}
-	currentSize, err := agentPool.TargetSize()
-	if err != nil {
-		klog.Error(err)
-		return err
-	}
-	klog.V(5).Infof("DecreaseTargetSize get current size %d for agent pool %q", currentSize, agentPool.Name)
-
-	// Get the current nodes in the list
-	nodes, err := agentPool.GetNodes()
-	if err != nil {
-		klog.Error(err)
-		return err
-	}
-
-	targetSize := currentSize + delta
-	klog.V(5).Infof("DecreaseTargetSize get target size %d for agent pool %q", targetSize, agentPool.Name)
-	if targetSize < len(nodes) {
-		return fmt.Errorf("attempt to delete existing nodes targetSize:%d delta:%d existingNodes: %d",
-			currentSize, delta, len(nodes))
-	}
-	return agentPool.SetSize(targetSize, true)
-}
-
-//Id returns the name of the agentPool
-func (agentPool *AKSAgentPool) Id() string {
-	return agentPool.azureRef.Name
-}
-
-//Debug returns a string with basic details of the agentPool
-func (agentPool *AKSAgentPool) Debug() string {
-	return fmt.Sprintf("%s (%d:%d)", agentPool.Id(), agentPool.MinSize(), agentPool.MaxSize())
-}
-
-//Nodes returns the list of nodes in the agentPool.
-func (agentPool *AKSAgentPool) Nodes() ([]cloudprovider.Instance, error) {
-	instanceNames, err := agentPool.GetNodes()
-	if err != nil {
-		return nil, err
-	}
-	instances := make([]cloudprovider.Instance, 0, len(instanceNames))
-	for _, instanceName := range instanceNames {
-		instances = append(instances, cloudprovider.Instance{Id: instanceName})
-	}
-	return instances, nil
-}
-
-//TemplateNodeInfo is not implemented.
-func (agentPool *AKSAgentPool) TemplateNodeInfo() (*schedulerframework.NodeInfo, error) {
-	return nil, cloudprovider.ErrNotImplemented
-}
-
-//Exist is always true since we are initialized with an existing agentpool
-func (agentPool *AKSAgentPool) Exist() bool {
-	return true
-}
-
-//Create is returns already exists since we don't support the
-//agent pool creation.
-func (agentPool *AKSAgentPool) Create() (cloudprovider.NodeGroup, error) {
-	return nil, cloudprovider.ErrAlreadyExist
-}
-
-//Delete is not implemented since we don't support agent pool
-//deletion.
-func (agentPool *AKSAgentPool) Delete() error {
-	return cloudprovider.ErrNotImplemented
-}
-
-//Autoprovisioned is set to false to indicate that this code
-//does not create agentPools by itself.
-func (agentPool *AKSAgentPool) Autoprovisioned() bool {
-	return false
-}
-
-// GetOptions returns NodeGroupAutoscalingOptions that should be used for this particular
-// NodeGroup. Returning a nil will result in using default options.
-func (agentPool *AKSAgentPool) GetOptions(defaults config.NodeGroupAutoscalingOptions) (*config.NodeGroupAutoscalingOptions, error) {
-	return nil, cloudprovider.ErrNotImplemented
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_manager.go b/cluster-autoscaler/cloudprovider/azure/azure_manager.go
deleted file mode 100644
index 85481f562..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_manager.go
+++ /dev/null
@@ -1,333 +0,0 @@
-/*
-Copyright 2017 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-//go:generate go run azure_instance_types/gen.go
-
-package azure
-
-import (
-	"fmt"
-	"io"
-	"strconv"
-	"strings"
-	"time"
-
-	"github.com/Azure/go-autorest/autorest/azure"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-	"k8s.io/autoscaler/cluster-autoscaler/config/dynamic"
-	klog "k8s.io/klog/v2"
-)
-
-const (
-	vmTypeVMSS     = "vmss"
-	vmTypeStandard = "standard"
-	vmTypeAKS      = "aks"
-
-	scaleToZeroSupportedStandard = false
-	scaleToZeroSupportedVMSS     = true
-	refreshInterval              = 1 * time.Minute
-)
-
-// AzureManager handles Azure communication and data caching.
-type AzureManager struct {
-	config   *Config
-	azClient *azClient
-	env      azure.Environment
-
-	azureCache           *azureCache
-	lastRefresh          time.Time
-	autoDiscoverySpecs   []labelAutoDiscoveryConfig
-	explicitlyConfigured map[string]bool
-}
-
-// createAzureManagerInternal allows for a custom azClient to be passed in by tests.
-func createAzureManagerInternal(configReader io.Reader, discoveryOpts cloudprovider.NodeGroupDiscoveryOptions, azClient *azClient) (*AzureManager, error) {
-	cfg, err := BuildAzureConfig(configReader)
-	if err != nil {
-		return nil, err
-	}
-
-	// Defaulting env to Azure Public Cloud.
-	env := azure.PublicCloud
-	if cfg.Cloud != "" {
-		env, err = azure.EnvironmentFromName(cfg.Cloud)
-		if err != nil {
-			return nil, err
-		}
-	}
-
-	klog.Infof("Starting azure manager with subscription ID %q", cfg.SubscriptionID)
-
-	if azClient == nil {
-		azClient, err = newAzClient(cfg, &env)
-		if err != nil {
-			return nil, err
-		}
-	}
-
-	// Create azure manager.
-	manager := &AzureManager{
-		config:               cfg,
-		env:                  env,
-		azClient:             azClient,
-		explicitlyConfigured: make(map[string]bool),
-	}
-
-	cacheTTL := refreshInterval
-	if cfg.VmssCacheTTL != 0 {
-		cacheTTL = time.Duration(cfg.VmssCacheTTL) * time.Second
-	}
-	cache, err := newAzureCache(azClient, cacheTTL, cfg.ResourceGroup, cfg.VMType)
-	if err != nil {
-		return nil, err
-	}
-	manager.azureCache = cache
-
-	specs, err := ParseLabelAutoDiscoverySpecs(discoveryOpts)
-	if err != nil {
-		return nil, err
-	}
-	manager.autoDiscoverySpecs = specs
-
-	if err := manager.fetchExplicitNodeGroups(discoveryOpts.NodeGroupSpecs); err != nil {
-		return nil, err
-	}
-
-	if err := manager.forceRefresh(); err != nil {
-		return nil, err
-	}
-
-	return manager, nil
-}
-
-// CreateAzureManager creates Azure Manager object to work with Azure.
-func CreateAzureManager(configReader io.Reader, discoveryOpts cloudprovider.NodeGroupDiscoveryOptions) (*AzureManager, error) {
-	return createAzureManagerInternal(configReader, discoveryOpts, nil)
-}
-
-func (m *AzureManager) fetchExplicitNodeGroups(specs []string) error {
-	changed := false
-	for _, spec := range specs {
-		nodeGroup, err := m.buildNodeGroupFromSpec(spec)
-		if err != nil {
-			return fmt.Errorf("failed to parse node group spec: %v", err)
-		}
-		if m.RegisterNodeGroup(nodeGroup) {
-			changed = true
-		}
-		m.explicitlyConfigured[nodeGroup.Id()] = true
-	}
-
-	if changed {
-		m.invalidateCache()
-	}
-	return nil
-}
-
-func (m *AzureManager) buildNodeGroupFromSpec(spec string) (cloudprovider.NodeGroup, error) {
-	scaleToZeroSupported := scaleToZeroSupportedStandard
-	if strings.EqualFold(m.config.VMType, vmTypeVMSS) {
-		scaleToZeroSupported = scaleToZeroSupportedVMSS
-	}
-	s, err := dynamic.SpecFromString(spec, scaleToZeroSupported)
-	if err != nil {
-		return nil, fmt.Errorf("failed to parse node group spec: %v", err)
-	}
-
-	switch m.config.VMType {
-	case vmTypeStandard:
-		return NewAgentPool(s, m)
-	case vmTypeVMSS:
-		return NewScaleSet(s, m, -1)
-	case vmTypeAKS:
-		return NewAKSAgentPool(s, m)
-	default:
-		return nil, fmt.Errorf("vmtype %s not supported", m.config.VMType)
-	}
-}
-
-// Refresh is called before every main loop and can be used to dynamically update cloud provider state.
-// In particular the list of node groups returned by NodeGroups can change as a result of CloudProvider.Refresh().
-func (m *AzureManager) Refresh() error {
-	if m.lastRefresh.Add(m.azureCache.refreshInterval).After(time.Now()) {
-		return nil
-	}
-	return m.forceRefresh()
-}
-
-func (m *AzureManager) forceRefresh() error {
-	if err := m.fetchAutoNodeGroups(); err != nil {
-		klog.Errorf("Failed to fetch autodiscovered nodegroups: %v", err)
-	}
-	if err := m.azureCache.regenerate(); err != nil {
-		klog.Errorf("Failed to regenerate Azure cache: %v", err)
-		return err
-	}
-	m.lastRefresh = time.Now()
-	klog.V(2).Infof("Refreshed Azure VM and VMSS list, next refresh after %v", m.lastRefresh.Add(m.azureCache.refreshInterval))
-	return nil
-}
-
-func (m *AzureManager) invalidateCache() {
-	m.lastRefresh = time.Now().Add(-1 * m.azureCache.refreshInterval)
-	klog.V(2).Infof("Invalidated Azure cache")
-}
-
-// Fetch automatically discovered NodeGroups. These NodeGroups should be unregistered if
-// they no longer exist in Azure.
-func (m *AzureManager) fetchAutoNodeGroups() error {
-	groups, err := m.getFilteredNodeGroups(m.autoDiscoverySpecs)
-	if err != nil {
-		return fmt.Errorf("cannot autodiscover NodeGroups: %s", err)
-	}
-
-	changed := false
-	exists := make(map[string]bool)
-	for _, group := range groups {
-		id := group.Id()
-		exists[id] = true
-		if m.explicitlyConfigured[id] {
-			// This NodeGroup was explicitly configured, but would also be
-			// autodiscovered. We want the explicitly configured min and max
-			// nodes to take precedence.
-			klog.V(3).Infof("Ignoring explicitly configured NodeGroup %s for autodiscovery.", group.Id())
-			continue
-		}
-		if m.RegisterNodeGroup(group) {
-			klog.V(3).Infof("Autodiscovered NodeGroup %s using tags %v", group.Id(), m.autoDiscoverySpecs)
-			changed = true
-		}
-	}
-
-	for _, nodeGroup := range m.getNodeGroups() {
-		nodeGroupID := nodeGroup.Id()
-		if !exists[nodeGroupID] && !m.explicitlyConfigured[nodeGroupID] {
-			m.UnregisterNodeGroup(nodeGroup)
-			changed = true
-		}
-	}
-
-	if changed {
-		m.invalidateCache()
-	}
-
-	return nil
-}
-
-func (m *AzureManager) getNodeGroups() []cloudprovider.NodeGroup {
-	return m.azureCache.getRegisteredNodeGroups()
-}
-
-// RegisterNodeGroup registers an a NodeGroup.
-func (m *AzureManager) RegisterNodeGroup(nodeGroup cloudprovider.NodeGroup) bool {
-	return m.azureCache.Register(nodeGroup)
-}
-
-// UnregisterNodeGroup unregisters a NodeGroup.
-func (m *AzureManager) UnregisterNodeGroup(nodeGroup cloudprovider.NodeGroup) bool {
-	return m.azureCache.Unregister(nodeGroup)
-}
-
-// GetNodeGroupForInstance returns the NodeGroup of the given Instance
-func (m *AzureManager) GetNodeGroupForInstance(instance *azureRef) (cloudprovider.NodeGroup, error) {
-	return m.azureCache.FindForInstance(instance, m.config.VMType)
-}
-
-// Cleanup the cache.
-func (m *AzureManager) Cleanup() {
-	m.azureCache.Cleanup()
-}
-
-func (m *AzureManager) getFilteredNodeGroups(filter []labelAutoDiscoveryConfig) (nodeGroups []cloudprovider.NodeGroup, err error) {
-	if len(filter) == 0 {
-		return nil, nil
-	}
-
-	if m.config.VMType == vmTypeVMSS {
-		return m.getFilteredScaleSets(filter)
-	}
-
-	return nil, fmt.Errorf("vmType %q does not support autodiscovery", m.config.VMType)
-}
-
-// getFilteredScaleSets gets a list of scale sets and instanceIDs.
-func (m *AzureManager) getFilteredScaleSets(filter []labelAutoDiscoveryConfig) ([]cloudprovider.NodeGroup, error) {
-	vmssList := m.azureCache.getScaleSets()
-
-	var nodeGroups []cloudprovider.NodeGroup
-	for _, scaleSet := range vmssList {
-		if len(filter) > 0 {
-			if scaleSet.Tags == nil || len(scaleSet.Tags) == 0 {
-				continue
-			}
-
-			if !matchDiscoveryConfig(scaleSet.Tags, filter) {
-				continue
-			}
-		}
-		spec := &dynamic.NodeGroupSpec{
-			Name:               *scaleSet.Name,
-			MinSize:            1,
-			MaxSize:            -1,
-			SupportScaleToZero: scaleToZeroSupportedVMSS,
-		}
-
-		if val, ok := scaleSet.Tags["min"]; ok {
-			if minSize, err := strconv.Atoi(*val); err == nil {
-				spec.MinSize = minSize
-			} else {
-				klog.Warningf("ignoring vmss %q because of invalid minimum size specified for vmss: %s", *scaleSet.Name, err)
-				continue
-			}
-		} else {
-			klog.Warningf("ignoring vmss %q because of no minimum size specified for vmss", *scaleSet.Name)
-			continue
-		}
-		if spec.MinSize < 0 {
-			klog.Warningf("ignoring vmss %q because of minimum size must be a non-negative number of nodes", *scaleSet.Name)
-			continue
-		}
-		if val, ok := scaleSet.Tags["max"]; ok {
-			if maxSize, err := strconv.Atoi(*val); err == nil {
-				spec.MaxSize = maxSize
-			} else {
-				klog.Warningf("ignoring vmss %q because of invalid maximum size specified for vmss: %s", *scaleSet.Name, err)
-				continue
-			}
-		} else {
-			klog.Warningf("ignoring vmss %q because of no maximum size specified for vmss", *scaleSet.Name)
-			continue
-		}
-		if spec.MaxSize < spec.MinSize {
-			klog.Warningf("ignoring vmss %q because of maximum size must be greater than minimum size: max=%d < min=%d", *scaleSet.Name, spec.MaxSize, spec.MinSize)
-			continue
-		}
-
-		curSize := int64(-1)
-		if scaleSet.Sku != nil && scaleSet.Sku.Capacity != nil {
-			curSize = *scaleSet.Sku.Capacity
-		}
-
-		vmss, err := NewScaleSet(spec, m, curSize)
-		if err != nil {
-			klog.Warningf("ignoring vmss %q %s", *scaleSet.Name, err)
-			continue
-		}
-		nodeGroups = append(nodeGroups, vmss)
-	}
-
-	return nodeGroups, nil
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_manager_test.go b/cluster-autoscaler/cloudprovider/azure/azure_manager_test.go
deleted file mode 100644
index 2525521fb..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_manager_test.go
+++ /dev/null
@@ -1,793 +0,0 @@
-/*
-Copyright 2019 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"fmt"
-	"k8s.io/legacy-cloud-providers/azure/clients/vmclient/mockvmclient"
-	"os"
-	"reflect"
-	"strings"
-	"testing"
-	"time"
-
-	"github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2019-12-01/compute"
-	"github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2017-05-10/resources"
-	"github.com/Azure/go-autorest/autorest/date"
-	"github.com/Azure/go-autorest/autorest/to"
-	"github.com/golang/mock/gomock"
-	"github.com/stretchr/testify/assert"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-	azclients "k8s.io/legacy-cloud-providers/azure/clients"
-	"k8s.io/legacy-cloud-providers/azure/clients/vmssclient/mockvmssclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/vmssvmclient/mockvmssvmclient"
-)
-
-const validAzureCfg = `{
-	"cloud": "AzurePublicCloud",
-	"tenantId": "fakeId",
-	"subscriptionId": "fakeId",
-	"aadClientId": "fakeId",
-	"aadClientSecret": "fakeId",
-	"resourceGroup": "fakeId",
-	"location": "southeastasia",
-	"subnetName": "fakeName",
-	"securityGroupName": "fakeName",
-	"vnetName": "fakeName",
-	"routeTableName": "fakeName",
-	"primaryAvailabilitySetName": "fakeName",
-	"vmssCacheTTL": 60,
-	"vmssVmsCacheTTL": 240,
-	"vmssVmsCacheJitter": 120,
-	"maxDeploymentsCount": 8,
-	"cloudProviderRateLimit": false,
-	"routeRateLimit": {
-		"cloudProviderRateLimit": true,
-		"cloudProviderRateLimitQPS": 3
-	}
-}`
-
-const validAzureCfgForStandardVMType = `{
-	"cloud": "AzurePublicCloud",
-	"tenantId": "fakeId",
-	"subscriptionId": "fakeId",
-	"aadClientId": "fakeId",
-	"aadClientSecret": "fakeId",
-	"resourceGroup": "fakeId",
-	"vmType":"standard",
-	"location": "southeastasia",
-	"subnetName": "fakeName",
-	"securityGroupName": "fakeName",
-	"vnetName": "fakeName",
-	"routeTableName": "fakeName",
-	"primaryAvailabilitySetName": "fakeName",
-	"vmssCacheTTL": 60,
-	"vmssVmsCacheTTL": 240,
-	"vmssVmsCacheJitter": 120,
-	"maxDeploymentsCount": 8,
-	"cloudProviderRateLimit": false,
-	"routeRateLimit": {
-		"cloudProviderRateLimit": true,
-		"cloudProviderRateLimitQPS": 3
-	},
-	"deployment":"cluster-autoscaler-0001",
-	"deploymentParameters":{
-		"Name": "cluster-autoscaler-0001",
-		"Properties":{
-			"ProvisioningState": "Succeeded",
-			"Parameters": {
-				"PoolName01VMSize":"PoolName01"
-			},
-			"Template": {
-				"resources": [
-					{
-						"type":"Microsoft.Compute/virtualMachines/extensions",
-						"name":"cluster-autoscaler-0001-resourceName",
-						"properties": {
-							"hardwareProfile":{
-								"VMSize":"10G"
-							}
-						}
-					}
-				]
-			}
-		}
-	}
-}`
-
-const validAzureCfgForStandardVMTypeWithoutDeploymentParameters = `{
-        "cloud": "AzurePublicCloud",
-        "tenantId": "fakeId",
-        "subscriptionId": "fakeId",
-        "aadClientId": "fakeId",
-        "aadClientSecret": "fakeId",
-        "resourceGroup": "fakeId",
-        "vmType":"standard",
-        "location": "southeastasia",
-        "subnetName": "fakeName",
-        "securityGroupName": "fakeName",
-        "vnetName": "fakeName",
-        "routeTableName": "fakeName",
-        "primaryAvailabilitySetName": "fakeName",
-        "vmssCacheTTL": 60,
-	"vmssVmsCacheTTL": 240,
-	"vmssVmsCacheJitter": 120,
-        "maxDeploymentsCount": 8,
-        "cloudProviderRateLimit": false,
-        "routeRateLimit": {
-                "cloudProviderRateLimit": true,
-                "cloudProviderRateLimitQPS": 3
-        },
-        "deployment":"cluster-autoscaler-0001"
-}`
-
-const invalidAzureCfg = `{{}"cloud": "AzurePublicCloud",}`
-
-func TestCreateAzureManagerValidConfig(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), "fakeId").Return([]compute.VirtualMachineScaleSet{}, nil).Times(2)
-	mockAzClient := &azClient{
-		virtualMachinesClient:         mockVMClient,
-		virtualMachineScaleSetsClient: mockVMSSClient,
-	}
-	manager, err := createAzureManagerInternal(strings.NewReader(validAzureCfg), cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-
-	expectedConfig := &Config{
-		Cloud:               "AzurePublicCloud",
-		Location:            "southeastasia",
-		TenantID:            "fakeId",
-		SubscriptionID:      "fakeId",
-		ResourceGroup:       "fakeId",
-		VMType:              "vmss",
-		AADClientID:         "fakeId",
-		AADClientSecret:     "fakeId",
-		VmssCacheTTL:        60,
-		VmssVmsCacheTTL:     240,
-		VmssVmsCacheJitter:  120,
-		MaxDeploymentsCount: 8,
-		CloudProviderRateLimitConfig: CloudProviderRateLimitConfig{
-			RateLimitConfig: azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			InterfaceRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			VirtualMachineRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			StorageAccountRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			DiskRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			VirtualMachineScaleSetRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			KubernetesServiceRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-		},
-	}
-
-	assert.NoError(t, err)
-	assert.Equal(t, true, reflect.DeepEqual(*expectedConfig, *manager.config), "unexpected azure manager configuration")
-}
-
-func TestCreateAzureManagerValidConfigForStandardVMType(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	mockVMClient.EXPECT().List(gomock.Any(), "fakeId").Return([]compute.VirtualMachine{}, nil).Times(2)
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockAzClient := &azClient{
-		virtualMachinesClient:         mockVMClient,
-		virtualMachineScaleSetsClient: mockVMSSClient,
-	}
-	manager, err := createAzureManagerInternal(strings.NewReader(validAzureCfgForStandardVMType), cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-
-	expectedConfig := &Config{
-		Cloud:               "AzurePublicCloud",
-		Location:            "southeastasia",
-		TenantID:            "fakeId",
-		SubscriptionID:      "fakeId",
-		ResourceGroup:       "fakeId",
-		VMType:              "standard",
-		AADClientID:         "fakeId",
-		AADClientSecret:     "fakeId",
-		VmssCacheTTL:        60,
-		VmssVmsCacheTTL:     240,
-		VmssVmsCacheJitter:  120,
-		MaxDeploymentsCount: 8,
-		CloudProviderRateLimitConfig: CloudProviderRateLimitConfig{
-			RateLimitConfig: azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			InterfaceRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			VirtualMachineRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			StorageAccountRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			DiskRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			VirtualMachineScaleSetRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			KubernetesServiceRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            false,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-		},
-		Deployment: "cluster-autoscaler-0001",
-		DeploymentParameters: map[string]interface{}{
-			"Name": "cluster-autoscaler-0001",
-			"Properties": map[string]interface{}{
-				"ProvisioningState": "Succeeded",
-				"Parameters": map[string]interface{}{
-					"PoolName01VMSize": "PoolName01",
-				},
-				"Template": map[string]interface{}{
-					"resources": []interface{}{
-						map[string]interface{}{
-							"type": "Microsoft.Compute/virtualMachines/extensions",
-							"name": "cluster-autoscaler-0001-resourceName",
-							"properties": map[string]interface{}{
-								"hardwareProfile": map[string]interface{}{
-									"VMSize": "10G",
-								},
-							},
-						},
-					},
-				},
-			},
-		},
-	}
-
-	assert.NoError(t, err)
-	assert.Equal(t, *expectedConfig, *manager.config, "unexpected azure manager configuration, expected: %v, actual: %v", *expectedConfig, *manager.config)
-}
-
-func TestCreateAzureManagerValidConfigForStandardVMTypeWithoutDeploymentParameters(t *testing.T) {
-	manager, err := createAzureManagerInternal(strings.NewReader(validAzureCfgForStandardVMTypeWithoutDeploymentParameters), cloudprovider.NodeGroupDiscoveryOptions{}, &azClient{})
-	expectedErr := "open /var/lib/azure/azuredeploy.parameters.json: no such file or directory"
-	assert.Nil(t, manager)
-	assert.Equal(t, expectedErr, err.Error(), "return error does not match, expected: %v, actual: %v", expectedErr, err.Error())
-}
-
-func TestCreateAzureManagerWithNilConfig(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), "resourceGroup").Return([]compute.VirtualMachineScaleSet{}, nil).AnyTimes()
-	mockAzClient := &azClient{
-		virtualMachinesClient:         mockVMClient,
-		virtualMachineScaleSetsClient: mockVMSSClient,
-	}
-
-	expectedConfig := &Config{
-		Cloud:                        "AzurePublicCloud",
-		Location:                     "southeastasia",
-		TenantID:                     "tenantId",
-		SubscriptionID:               "subscriptionId",
-		ResourceGroup:                "resourceGroup",
-		VMType:                       "vmss",
-		AADClientID:                  "aadClientId",
-		AADClientSecret:              "aadClientSecret",
-		AADClientCertPath:            "aadClientCertPath",
-		AADClientCertPassword:        "aadClientCertPassword",
-		Deployment:                   "deployment",
-		ClusterName:                  "clusterName",
-		NodeResourceGroup:            "resourcegroup",
-		UseManagedIdentityExtension:  true,
-		UserAssignedIdentityID:       "UserAssignedIdentityID",
-		VmssCacheTTL:                 100,
-		VmssVmsCacheTTL:              110,
-		VmssVmsCacheJitter:           90,
-		MaxDeploymentsCount:          8,
-		CloudProviderBackoff:         true,
-		CloudProviderBackoffRetries:  1,
-		CloudProviderBackoffExponent: 1,
-		CloudProviderBackoffDuration: 1,
-		CloudProviderBackoffJitter:   1,
-		CloudProviderRateLimitConfig: CloudProviderRateLimitConfig{
-			RateLimitConfig: azclients.RateLimitConfig{
-				CloudProviderRateLimit:            true,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			InterfaceRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            true,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			VirtualMachineRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            true,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			StorageAccountRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            true,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			DiskRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            true,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			VirtualMachineScaleSetRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            true,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-			KubernetesServiceRateLimit: &azclients.RateLimitConfig{
-				CloudProviderRateLimit:            true,
-				CloudProviderRateLimitBucket:      5,
-				CloudProviderRateLimitBucketWrite: 5,
-				CloudProviderRateLimitQPS:         1,
-				CloudProviderRateLimitQPSWrite:    1,
-			},
-		},
-	}
-
-	os.Setenv("ARM_CLOUD", "AzurePublicCloud")
-	os.Setenv("LOCATION", "southeastasia")
-	os.Setenv("ARM_SUBSCRIPTION_ID", "subscriptionId")
-	os.Setenv("ARM_RESOURCE_GROUP", "resourceGroup")
-	os.Setenv("ARM_TENANT_ID", "tenantId")
-	os.Setenv("ARM_CLIENT_ID", "aadClientId")
-	os.Setenv("ARM_CLIENT_SECRET", "aadClientSecret")
-	os.Setenv("ARM_VM_TYPE", "vmss")
-	os.Setenv("ARM_CLIENT_CERT_PATH", "aadClientCertPath")
-	os.Setenv("ARM_CLIENT_CERT_PASSWORD", "aadClientCertPassword")
-	os.Setenv("ARM_DEPLOYMENT", "deployment")
-	os.Setenv("AZURE_CLUSTER_NAME", "clusterName")
-	os.Setenv("AZURE_NODE_RESOURCE_GROUP", "resourcegroup")
-	os.Setenv("ARM_USE_MANAGED_IDENTITY_EXTENSION", "true")
-	os.Setenv("ARM_USER_ASSIGNED_IDENTITY_ID", "UserAssignedIdentityID")
-	os.Setenv("AZURE_VMSS_CACHE_TTL", "100")
-	os.Setenv("AZURE_VMSS_VMS_CACHE_TTL", "110")
-	os.Setenv("AZURE_VMSS_VMS_CACHE_JITTER", "90")
-	os.Setenv("AZURE_MAX_DEPLOYMENT_COUNT", "8")
-	os.Setenv("ENABLE_BACKOFF", "true")
-	os.Setenv("BACKOFF_RETRIES", "1")
-	os.Setenv("BACKOFF_EXPONENT", "1")
-	os.Setenv("BACKOFF_DURATION", "1")
-	os.Setenv("BACKOFF_JITTER", "1")
-	os.Setenv("CLOUD_PROVIDER_RATE_LIMIT", "true")
-
-	manager, err := createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	assert.NoError(t, err)
-	assert.Equal(t, true, reflect.DeepEqual(*expectedConfig, *manager.config), "unexpected azure manager configuration")
-
-	// invalid bool for ARM_USE_MANAGED_IDENTITY_EXTENSION
-	os.Setenv("ARM_USE_MANAGED_IDENTITY_EXTENSION", "invalidbool")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	expectedErr0 := "strconv.ParseBool: parsing \"invalidbool\": invalid syntax"
-	assert.Nil(t, manager)
-	assert.Equal(t, expectedErr0, err.Error(), "Return err does not match, expected: %v, actual: %v", expectedErr0, err.Error())
-	// revert back to good ARM_USE_MANAGED_IDENTITY_EXTENSION
-	os.Setenv("ARM_USE_MANAGED_IDENTITY_EXTENSION", "true")
-
-	// invalid int for AZURE_VMSS_CACHE_TTL
-	os.Setenv("AZURE_VMSS_CACHE_TTL", "invalidint")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	expectedErr := fmt.Errorf("failed to parse AZURE_VMSS_CACHE_TTL \"invalidint\": strconv.ParseInt: parsing \"invalidint\": invalid syntax")
-	assert.Nil(t, manager)
-	assert.Equal(t, expectedErr, err, "Return err does not match, expected: %v, actual: %v", expectedErr, err)
-	// revert back to good AZURE_VMSS_CACHE_TTL
-	os.Setenv("AZURE_VMSS_CACHE_TTL", "100")
-
-	// invalid int for AZURE_MAX_DEPLOYMENT_COUNT
-	os.Setenv("AZURE_MAX_DEPLOYMENT_COUNT", "invalidint")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	expectedErr = fmt.Errorf("failed to parse AZURE_MAX_DEPLOYMENT_COUNT \"invalidint\": strconv.ParseInt: parsing \"invalidint\": invalid syntax")
-	assert.Nil(t, manager)
-	assert.Equal(t, expectedErr, err, "Return err does not match, expected: %v, actual: %v", expectedErr, err)
-	// revert back to good AZURE_MAX_DEPLOYMENT_COUNT
-	os.Setenv("AZURE_MAX_DEPLOYMENT_COUNT", "8")
-
-	// zero AZURE_MAX_DEPLOYMENT_COUNT will use default value
-	os.Setenv("AZURE_MAX_DEPLOYMENT_COUNT", "0")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	assert.NoError(t, err)
-	assert.Equal(t, int64(defaultMaxDeploymentsCount), (*manager.config).MaxDeploymentsCount, "MaxDeploymentsCount does not match.")
-	// revert back to good AZURE_MAX_DEPLOYMENT_COUNT
-	os.Setenv("AZURE_MAX_DEPLOYMENT_COUNT", "8")
-
-	// invalid bool for ENABLE_BACKOFF
-	os.Setenv("ENABLE_BACKOFF", "invalidbool")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	expectedErr = fmt.Errorf("failed to parse ENABLE_BACKOFF \"invalidbool\": strconv.ParseBool: parsing \"invalidbool\": invalid syntax")
-	assert.Nil(t, manager)
-	assert.Equal(t, expectedErr, err, "Return err does not match, expected: %v, actual: %v", expectedErr, err)
-	// revert back to good ENABLE_BACKOFF
-	os.Setenv("ENABLE_BACKOFF", "true")
-
-	// invalid int for BACKOFF_RETRIES
-	os.Setenv("BACKOFF_RETRIES", "invalidint")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	expectedErr = fmt.Errorf("failed to parse BACKOFF_RETRIES '\\x00': strconv.ParseInt: parsing \"invalidint\": invalid syntax")
-	assert.Nil(t, manager)
-	assert.Equal(t, expectedErr, err, "Return err does not match, expected: %v, actual: %v", expectedErr, err)
-	// revert back to good BACKOFF_RETRIES
-	os.Setenv("BACKOFF_RETRIES", "1")
-
-	// empty BACKOFF_RETRIES will use default value
-	os.Setenv("BACKOFF_RETRIES", "")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	assert.NoError(t, err)
-	assert.Equal(t, backoffRetriesDefault, (*manager.config).CloudProviderBackoffRetries, "CloudProviderBackoffRetries does not match.")
-	// revert back to good BACKOFF_RETRIES
-	os.Setenv("BACKOFF_RETRIES", "1")
-
-	// invalid float for BACKOFF_EXPONENT
-	os.Setenv("BACKOFF_EXPONENT", "invalidfloat")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	expectedErr = fmt.Errorf("failed to parse BACKOFF_EXPONENT \"invalidfloat\": strconv.ParseFloat: parsing \"invalidfloat\": invalid syntax")
-	assert.Nil(t, manager)
-	assert.Equal(t, expectedErr, err, "Return err does not match, expected: %v, actual: %v", expectedErr, err)
-	// revert back to good BACKOFF_EXPONENT
-	os.Setenv("BACKOFF_EXPONENT", "1")
-
-	// empty BACKOFF_EXPONENT will use default value
-	os.Setenv("BACKOFF_EXPONENT", "")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	assert.NoError(t, err)
-	assert.Equal(t, backoffExponentDefault, (*manager.config).CloudProviderBackoffExponent, "CloudProviderBackoffExponent does not match.")
-	// revert back to good BACKOFF_EXPONENT
-	os.Setenv("BACKOFF_EXPONENT", "1")
-
-	// invalid int for BACKOFF_DURATION
-	os.Setenv("BACKOFF_DURATION", "invalidint")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	expectedErr = fmt.Errorf("failed to parse BACKOFF_DURATION \"invalidint\": strconv.ParseInt: parsing \"invalidint\": invalid syntax")
-	assert.Nil(t, manager)
-	assert.Equal(t, expectedErr, err, "Return err does not match, expected: %v, actual: %v", expectedErr, err)
-	// revert back to good BACKOFF_DURATION
-	os.Setenv("BACKOFF_DURATION", "1")
-
-	// empty BACKOFF_DURATION will use default value
-	os.Setenv("BACKOFF_DURATION", "")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	assert.NoError(t, err)
-	assert.Equal(t, backoffDurationDefault, (*manager.config).CloudProviderBackoffDuration, "CloudProviderBackoffDuration does not match.")
-	// revert back to good BACKOFF_DURATION
-	os.Setenv("BACKOFF_DURATION", "1")
-
-	// invalid float for BACKOFF_JITTER
-	os.Setenv("BACKOFF_JITTER", "invalidfloat")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	expectedErr = fmt.Errorf("failed to parse BACKOFF_JITTER \"invalidfloat\": strconv.ParseFloat: parsing \"invalidfloat\": invalid syntax")
-	assert.Nil(t, manager)
-	assert.Equal(t, expectedErr, err, "Return err does not match, expected: %v, actual: %v", expectedErr, err)
-	// revert back to good BACKOFF_JITTER
-	os.Setenv("BACKOFF_JITTER", "1")
-
-	// empty BACKOFF_JITTER will use default value
-	os.Setenv("BACKOFF_JITTER", "")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	assert.NoError(t, err)
-	assert.Equal(t, backoffJitterDefault, (*manager.config).CloudProviderBackoffJitter, "CloudProviderBackoffJitter does not match.")
-	// revert back to good BACKOFF_JITTER
-	os.Setenv("BACKOFF_JITTER", "1")
-
-	// invalid bool for CLOUD_PROVIDER_RATE_LIMIT
-	os.Setenv("CLOUD_PROVIDER_RATE_LIMIT", "invalidbool")
-	manager, err = createAzureManagerInternal(nil, cloudprovider.NodeGroupDiscoveryOptions{}, mockAzClient)
-	expectedErr = fmt.Errorf("failed to parse CLOUD_PROVIDER_RATE_LIMIT: \"invalidbool\", strconv.ParseBool: parsing \"invalidbool\": invalid syntax")
-	assert.Nil(t, manager)
-	assert.Equal(t, expectedErr, err, "Return err does not match, expected: %v, actual: %v", expectedErr, err)
-	// revert back to good CLOUD_PROVIDER_RATE_LIMIT
-	os.Setenv("CLOUD_PROVIDER_RATE_LIMIT", "1")
-
-	os.Unsetenv("ARM_CLOUD")
-	os.Unsetenv("ARM_SUBSCRIPTION_ID")
-	os.Unsetenv("LOCATION")
-	os.Unsetenv("ARM_RESOURCE_GROUP")
-	os.Unsetenv("ARM_TENANT_ID")
-	os.Unsetenv("ARM_CLIENT_ID")
-	os.Unsetenv("ARM_CLIENT_SECRET")
-	os.Unsetenv("ARM_VM_TYPE")
-	os.Unsetenv("ARM_CLIENT_CERT_PATH")
-	os.Unsetenv("ARM_CLIENT_CERT_PASSWORD")
-	os.Unsetenv("ARM_DEPLOYMENT")
-	os.Unsetenv("AZURE_CLUSTER_NAME")
-	os.Unsetenv("AZURE_NODE_RESOURCE_GROUP")
-	os.Unsetenv("ARM_USE_MANAGED_IDENTITY_EXTENSION")
-	os.Unsetenv("ARM_USER_ASSIGNED_IDENTITY_ID")
-	os.Unsetenv("AZURE_VMSS_CACHE_TTL")
-	os.Unsetenv("AZURE_MAX_DEPLOYMENT_COUNT")
-	os.Unsetenv("ENABLE_BACKOFF")
-	os.Unsetenv("BACKOFF_RETRIES")
-	os.Unsetenv("BACKOFF_EXPONENT")
-	os.Unsetenv("BACKOFF_DURATION")
-	os.Unsetenv("BACKOFF_JITTER")
-	os.Unsetenv("CLOUD_PROVIDER_RATE_LIMIT")
-}
-
-func TestCreateAzureManagerInvalidConfig(t *testing.T) {
-	_, err := createAzureManagerInternal(strings.NewReader(invalidAzureCfg), cloudprovider.NodeGroupDiscoveryOptions{}, &azClient{})
-	assert.Error(t, err, "failed to unmarshal config body")
-}
-
-func TestFetchExplicitNodeGroups(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	min, max, name := 1, 15, "test-asg"
-	ngdo := cloudprovider.NodeGroupDiscoveryOptions{
-		NodeGroupSpecs: []string{
-			fmt.Sprintf("%d:%d:%s", min, max, name),
-		},
-	}
-
-	manager := newTestAzureManager(t)
-	expectedVMSSVMs := newTestVMSSVMList(3)
-	expectedScaleSets := newTestVMSSList(3, "test-asg", "eastus")
-
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup).Return(expectedScaleSets, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	mockVMSSVMClient := mockvmssvmclient.NewMockInterface(ctrl)
-	mockVMSSVMClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup, "test-asg", gomock.Any()).Return(expectedVMSSVMs, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetVMsClient = mockVMSSVMClient
-	manager.fetchExplicitNodeGroups(ngdo.NodeGroupSpecs)
-
-	asgs := manager.azureCache.getRegisteredNodeGroups()
-	assert.Equal(t, 1, len(asgs))
-	assert.Equal(t, name, asgs[0].Id())
-	assert.Equal(t, min, asgs[0].MinSize())
-	assert.Equal(t, max, asgs[0].MaxSize())
-
-	// test vmTypeStandard
-	testAS := newTestAgentPool(newTestAzureManager(t), "testAS")
-	timeLayout := "2006-01-02 15:04:05"
-	timeBenchMark, _ := time.Parse(timeLayout, "2000-01-01 00:00:00")
-	testAS.manager.azClient.deploymentsClient = &DeploymentsClientMock{
-		FakeStore: map[string]resources.DeploymentExtended{
-			"cluster-autoscaler-0001": {
-				Name: to.StringPtr("cluster-autoscaler-0001"),
-				Properties: &resources.DeploymentPropertiesExtended{
-					ProvisioningState: to.StringPtr("Succeeded"),
-					Timestamp:         &date.Time{Time: timeBenchMark.Add(2 * time.Minute)},
-				},
-			},
-		},
-	}
-	testAS.manager.config.VMType = vmTypeStandard
-	err := testAS.manager.fetchExplicitNodeGroups([]string{"1:5:testAS"})
-	expectedErr := fmt.Errorf("failed to parse node group spec: deployment not found")
-	assert.Equal(t, expectedErr, err, "testAS.manager.fetchExplicitNodeGroups return error does not match, expected: %v, actual: %v", expectedErr, err)
-	err = testAS.manager.fetchExplicitNodeGroups(nil)
-	assert.NoError(t, err)
-
-	// test invalidVMType
-	manager.config.VMType = "invalidVMType"
-	err = manager.fetchExplicitNodeGroups(ngdo.NodeGroupSpecs)
-	expectedErr = fmt.Errorf("failed to parse node group spec: vmtype invalidVMType not supported")
-	assert.Equal(t, expectedErr, err, "manager.fetchExplicitNodeGroups return error does not match, expected: %v, actual: %v", expectedErr, err)
-}
-
-func TestGetFilteredAutoscalingGroupsVmss(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	vmssName := "test-vmss"
-	vmssTag := "fake-tag"
-	vmssTagValue := "fake-value"
-	min := "1"
-	minVal := 1
-	max := "5"
-	maxVal := 5
-
-	ngdo := cloudprovider.NodeGroupDiscoveryOptions{
-		NodeGroupAutoDiscoverySpecs: []string{fmt.Sprintf("label:%s=%s", vmssTag, vmssTagValue)},
-	}
-
-	manager := newTestAzureManager(t)
-	expectedScaleSets := []compute.VirtualMachineScaleSet{fakeVMSSWithTags(vmssName, map[string]*string{vmssTag: &vmssTagValue, "min": &min, "max": &max})}
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup).Return(expectedScaleSets, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	err := manager.forceRefresh()
-	assert.NoError(t, err)
-
-	specs, err := ParseLabelAutoDiscoverySpecs(ngdo)
-	assert.NoError(t, err)
-
-	asgs, err := manager.getFilteredNodeGroups(specs)
-	assert.NoError(t, err)
-	expectedAsgs := []cloudprovider.NodeGroup{&ScaleSet{
-		azureRef: azureRef{
-			Name: vmssName,
-		},
-		minSize:                minVal,
-		maxSize:                maxVal,
-		manager:                manager,
-		curSize:                3,
-		instancesRefreshPeriod: defaultVmssInstancesRefreshPeriod,
-	}}
-	assert.True(t, assert.ObjectsAreEqualValues(expectedAsgs, asgs), "expected %#v, but found: %#v", expectedAsgs, asgs)
-}
-
-func TestGetFilteredAutoscalingGroupsWithInvalidVMType(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	ngdo := cloudprovider.NodeGroupDiscoveryOptions{
-		NodeGroupAutoDiscoverySpecs: []string{"label:fake-tag=fake-value"},
-	}
-
-	manager := newTestAzureManager(t)
-	expectedScaleSets := []compute.VirtualMachineScaleSet{}
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup).Return(expectedScaleSets, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	manager.config.VMType = vmTypeAKS
-
-	specs, err := ParseLabelAutoDiscoverySpecs(ngdo)
-	assert.NoError(t, err)
-
-	expectedErr := fmt.Errorf("vmType \"aks\" does not support autodiscovery")
-	asgs, err2 := manager.getFilteredNodeGroups(specs)
-	assert.Nil(t, asgs)
-	assert.Equal(t, expectedErr, err2, "Not match, expected: %v, actual: %v", expectedErr, err2)
-
-	manager.config.VMType = "invalidVMType"
-	expectedErr = fmt.Errorf("vmType \"invalidVMType\" does not support autodiscovery")
-	asgs, err2 = manager.getFilteredNodeGroups(specs)
-	assert.Nil(t, asgs)
-	assert.Equal(t, expectedErr, err2, "Not match, expected: %v, actual: %v", expectedErr, err2)
-}
-
-func TestFetchAutoAsgsVmss(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	vmssName := "test-vmss"
-	vmssTag := "fake-tag"
-	vmssTagValue := "fake-value"
-	minString := "1"
-	minVal := 1
-	maxString := "5"
-	maxVal := 5
-
-	ngdo := cloudprovider.NodeGroupDiscoveryOptions{
-		NodeGroupAutoDiscoverySpecs: []string{fmt.Sprintf("label:%s=%s", vmssTag, vmssTagValue)},
-	}
-
-	expectedScaleSets := []compute.VirtualMachineScaleSet{fakeVMSSWithTags(vmssName, map[string]*string{vmssTag: &vmssTagValue, "min": &minString, "max": &maxString})}
-	expectedVMSSVMs := newTestVMSSVMList(1)
-
-	manager := newTestAzureManager(t)
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup).Return(expectedScaleSets, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	mockVMSSVMClient := mockvmssvmclient.NewMockInterface(ctrl)
-	mockVMSSVMClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup, vmssName, gomock.Any()).Return(expectedVMSSVMs, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetVMsClient = mockVMSSVMClient
-	err := manager.forceRefresh()
-	assert.NoError(t, err)
-
-	specs, err := ParseLabelAutoDiscoverySpecs(ngdo)
-	assert.NoError(t, err)
-	manager.autoDiscoverySpecs = specs
-
-	// assert cache is empty before fetching auto asgs
-	asgs := manager.azureCache.getRegisteredNodeGroups()
-	assert.Equal(t, 0, len(asgs))
-
-	manager.fetchAutoNodeGroups()
-	asgs = manager.azureCache.getRegisteredNodeGroups()
-	assert.Equal(t, 1, len(asgs))
-	assert.Equal(t, vmssName, asgs[0].Id())
-	assert.Equal(t, minVal, asgs[0].MinSize())
-	assert.Equal(t, maxVal, asgs[0].MaxSize())
-
-	// test explicitlyConfigured
-	manager.explicitlyConfigured[vmssName] = true
-	manager.fetchAutoNodeGroups()
-	asgs = manager.azureCache.getRegisteredNodeGroups()
-	assert.Equal(t, 1, len(asgs))
-}
-
-func TestManagerRefreshAndCleanup(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	manager := newTestAzureManager(t)
-	err := manager.Refresh()
-	assert.NoError(t, err)
-	manager.Cleanup()
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_scale_set.go b/cluster-autoscaler/cloudprovider/azure/azure_scale_set.go
deleted file mode 100644
index e64f230e2..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_scale_set.go
+++ /dev/null
@@ -1,600 +0,0 @@
-/*
-Copyright 2017 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"fmt"
-	"math/rand"
-	"strings"
-	"sync"
-	"time"
-
-	apiv1 "k8s.io/api/core/v1"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-	"k8s.io/autoscaler/cluster-autoscaler/config"
-	"k8s.io/autoscaler/cluster-autoscaler/config/dynamic"
-	klog "k8s.io/klog/v2"
-	schedulerframework "k8s.io/kubernetes/pkg/scheduler/framework"
-	"k8s.io/legacy-cloud-providers/azure/retry"
-
-	"github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2019-12-01/compute"
-	"github.com/Azure/go-autorest/autorest/azure"
-	"github.com/Azure/go-autorest/autorest/to"
-)
-
-var (
-	defaultVmssInstancesRefreshPeriod = 5 * time.Minute
-	vmssContextTimeout                = 3 * time.Minute
-	vmssSizeMutex                     sync.Mutex
-)
-
-// ScaleSet implements NodeGroup interface.
-type ScaleSet struct {
-	azureRef
-	manager *AzureManager
-
-	minSize int
-	maxSize int
-
-	sizeMutex         sync.Mutex
-	curSize           int64
-	lastSizeRefresh   time.Time
-	sizeRefreshPeriod time.Duration
-
-	instancesRefreshPeriod time.Duration
-	instancesRefreshJitter int
-
-	instanceMutex       sync.Mutex
-	instanceCache       []cloudprovider.Instance
-	lastInstanceRefresh time.Time
-}
-
-// NewScaleSet creates a new NewScaleSet.
-func NewScaleSet(spec *dynamic.NodeGroupSpec, az *AzureManager, curSize int64) (*ScaleSet, error) {
-	scaleSet := &ScaleSet{
-		azureRef: azureRef{
-			Name: spec.Name,
-		},
-		minSize: spec.MinSize,
-		maxSize: spec.MaxSize,
-		manager: az,
-		curSize: curSize,
-
-		instancesRefreshJitter: az.config.VmssVmsCacheJitter,
-	}
-
-	if az.config.VmssVmsCacheTTL != 0 {
-		scaleSet.instancesRefreshPeriod = time.Duration(az.config.VmssVmsCacheTTL) * time.Second
-	} else {
-		scaleSet.instancesRefreshPeriod = defaultVmssInstancesRefreshPeriod
-	}
-
-	return scaleSet, nil
-}
-
-// MinSize returns minimum size of the node group.
-func (scaleSet *ScaleSet) MinSize() int {
-	return scaleSet.minSize
-}
-
-// Exist checks if the node group really exists on the cloud provider side. Allows to tell the
-// theoretical node group from the real one.
-func (scaleSet *ScaleSet) Exist() bool {
-	return true
-}
-
-// Create creates the node group on the cloud provider side.
-func (scaleSet *ScaleSet) Create() (cloudprovider.NodeGroup, error) {
-	return nil, cloudprovider.ErrAlreadyExist
-}
-
-// Delete deletes the node group on the cloud provider side.
-// This will be executed only for autoprovisioned node groups, once their size drops to 0.
-func (scaleSet *ScaleSet) Delete() error {
-	return cloudprovider.ErrNotImplemented
-}
-
-// Autoprovisioned returns true if the node group is autoprovisioned.
-func (scaleSet *ScaleSet) Autoprovisioned() bool {
-	return false
-}
-
-// GetOptions returns NodeGroupAutoscalingOptions that should be used for this particular
-// NodeGroup. Returning a nil will result in using default options.
-func (scaleSet *ScaleSet) GetOptions(defaults config.NodeGroupAutoscalingOptions) (*config.NodeGroupAutoscalingOptions, error) {
-	return nil, cloudprovider.ErrNotImplemented
-}
-
-// MaxSize returns maximum size of the node group.
-func (scaleSet *ScaleSet) MaxSize() int {
-	return scaleSet.maxSize
-}
-
-func (scaleSet *ScaleSet) getVMSSFromCache() (compute.VirtualMachineScaleSet, *retry.Error) {
-	allVMSS := scaleSet.manager.azureCache.getScaleSets()
-
-	if _, exists := allVMSS[scaleSet.Name]; !exists {
-		return compute.VirtualMachineScaleSet{}, &retry.Error{RawError: fmt.Errorf("could not find vmss: %s", scaleSet.Name)}
-	}
-
-	return allVMSS[scaleSet.Name], nil
-}
-
-func (scaleSet *ScaleSet) getCurSize() (int64, error) {
-	scaleSet.sizeMutex.Lock()
-	defer scaleSet.sizeMutex.Unlock()
-
-	if scaleSet.lastSizeRefresh.Add(scaleSet.sizeRefreshPeriod).After(time.Now()) {
-		return scaleSet.curSize, nil
-	}
-
-	klog.V(5).Infof("Get scale set size for %q", scaleSet.Name)
-	set, rerr := scaleSet.getVMSSFromCache()
-	if rerr != nil {
-		return -1, rerr.Error()
-	}
-
-	// If VMSS state is updating, return the currentSize which would've been proactively incremented or decremented by CA
-	if set.VirtualMachineScaleSetProperties != nil && strings.EqualFold(to.String(set.VirtualMachineScaleSetProperties.ProvisioningState), string(compute.ProvisioningStateUpdating)) {
-		klog.V(5).Infof("VMSS %q is in updating state, returning cached size: %d", scaleSet.Name, scaleSet.curSize)
-		return scaleSet.curSize, nil
-	}
-
-	vmssSizeMutex.Lock()
-	curSize := *set.Sku.Capacity
-	vmssSizeMutex.Unlock()
-
-	klog.V(5).Infof("Getting scale set (%q) capacity: %d\n", scaleSet.Name, curSize)
-
-	if scaleSet.curSize != curSize {
-		// Invalidate the instance cache if the capacity has changed.
-		scaleSet.invalidateInstanceCache()
-	}
-
-	scaleSet.curSize = curSize
-	scaleSet.lastSizeRefresh = time.Now()
-	return scaleSet.curSize, nil
-}
-
-// GetScaleSetSize gets Scale Set size.
-func (scaleSet *ScaleSet) GetScaleSetSize() (int64, error) {
-	return scaleSet.getCurSize()
-}
-
-func (scaleSet *ScaleSet) waitForDeleteInstances(future *azure.Future, requiredIds *compute.VirtualMachineScaleSetVMInstanceRequiredIDs) {
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-
-	klog.V(3).Infof("Calling virtualMachineScaleSetsClient.WaitForAsyncOperationResult - DeleteInstances(%v)", requiredIds.InstanceIds)
-	httpResponse, err := scaleSet.manager.azClient.virtualMachineScaleSetsClient.WaitForAsyncOperationResult(ctx, future)
-	isSuccess, err := isSuccessHTTPResponse(httpResponse, err)
-	if isSuccess {
-		klog.V(3).Infof("virtualMachineScaleSetsClient.WaitForAsyncOperationResult - DeleteInstances(%v) success", requiredIds.InstanceIds)
-		return
-	}
-	klog.Errorf("virtualMachineScaleSetsClient.WaitForAsyncOperationResult - DeleteInstances for instances %v failed with error: %v", requiredIds.InstanceIds, err)
-}
-
-// updateVMSSCapacity invokes virtualMachineScaleSetsClient to update the capacity for VMSS.
-func (scaleSet *ScaleSet) updateVMSSCapacity(future *azure.Future) {
-	var err error
-
-	defer func() {
-		if err != nil {
-			klog.Errorf("Failed to update the capacity for vmss %s with error %v, invalidate the cache so as to get the real size from API", scaleSet.Name, err)
-			// Invalidate the VMSS size cache in order to fetch the size from the API.
-			scaleSet.manager.invalidateCache()
-		}
-	}()
-
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-
-	klog.V(3).Infof("Calling virtualMachineScaleSetsClient.WaitForAsyncOperationResult - updateVMSSCapacity(%s)", scaleSet.Name)
-	httpResponse, err := scaleSet.manager.azClient.virtualMachineScaleSetsClient.WaitForAsyncOperationResult(ctx, future)
-
-	isSuccess, err := isSuccessHTTPResponse(httpResponse, err)
-	if isSuccess {
-		klog.V(3).Infof("virtualMachineScaleSetsClient.WaitForAsyncOperationResult - updateVMSSCapacity(%s) success", scaleSet.Name)
-		scaleSet.invalidateInstanceCache()
-		return
-	}
-
-	klog.Errorf("virtualMachineScaleSetsClient.WaitForAsyncOperationResult - updateVMSSCapacity for scale set %q failed: %v", scaleSet.Name, err)
-}
-
-// SetScaleSetSize sets ScaleSet size.
-func (scaleSet *ScaleSet) SetScaleSetSize(size int64) error {
-	scaleSet.sizeMutex.Lock()
-	defer scaleSet.sizeMutex.Unlock()
-
-	vmssInfo, rerr := scaleSet.getVMSSFromCache()
-	if rerr != nil {
-		klog.Errorf("Failed to get information for VMSS (%q): %v", scaleSet.Name, rerr)
-		return rerr.Error()
-	}
-
-	// Update the new capacity to cache.
-	vmssSizeMutex.Lock()
-	vmssInfo.Sku.Capacity = &size
-	vmssSizeMutex.Unlock()
-
-	// Compose a new VMSS for updating.
-	op := compute.VirtualMachineScaleSet{
-		Name:     vmssInfo.Name,
-		Sku:      vmssInfo.Sku,
-		Location: vmssInfo.Location,
-	}
-	ctx, cancel := getContextWithTimeout(vmssContextTimeout)
-	defer cancel()
-	klog.V(3).Infof("Waiting for virtualMachineScaleSetsClient.CreateOrUpdateAsync(%s)", scaleSet.Name)
-	future, rerr := scaleSet.manager.azClient.virtualMachineScaleSetsClient.CreateOrUpdateAsync(ctx, scaleSet.manager.config.ResourceGroup, scaleSet.Name, op)
-	if rerr != nil {
-		klog.Errorf("virtualMachineScaleSetsClient.CreateOrUpdate for scale set %q failed: %v", scaleSet.Name, rerr)
-		return rerr.Error()
-	}
-
-	// Proactively set the VMSS size so autoscaler makes better decisions.
-	scaleSet.curSize = size
-	scaleSet.lastSizeRefresh = time.Now()
-
-	go scaleSet.updateVMSSCapacity(future)
-	return nil
-}
-
-// TargetSize returns the current TARGET size of the node group. It is possible that the
-// number is different from the number of nodes registered in Kubernetes.
-func (scaleSet *ScaleSet) TargetSize() (int, error) {
-	size, err := scaleSet.GetScaleSetSize()
-	return int(size), err
-}
-
-// IncreaseSize increases Scale Set size
-func (scaleSet *ScaleSet) IncreaseSize(delta int) error {
-	if delta <= 0 {
-		return fmt.Errorf("size increase must be positive")
-	}
-
-	size, err := scaleSet.GetScaleSetSize()
-	if err != nil {
-		return err
-	}
-
-	if size == -1 {
-		return fmt.Errorf("the scale set %s is under initialization, skipping IncreaseSize", scaleSet.Name)
-	}
-
-	if int(size)+delta > scaleSet.MaxSize() {
-		return fmt.Errorf("size increase too large - desired:%d max:%d", int(size)+delta, scaleSet.MaxSize())
-	}
-
-	return scaleSet.SetScaleSetSize(size + int64(delta))
-}
-
-// GetScaleSetVms returns list of nodes for the given scale set.
-func (scaleSet *ScaleSet) GetScaleSetVms() ([]compute.VirtualMachineScaleSetVM, *retry.Error) {
-	klog.V(4).Infof("GetScaleSetVms: starts")
-	ctx, cancel := getContextWithTimeout(vmssContextTimeout)
-	defer cancel()
-
-	resourceGroup := scaleSet.manager.config.ResourceGroup
-	vmList, rerr := scaleSet.manager.azClient.virtualMachineScaleSetVMsClient.List(ctx, resourceGroup, scaleSet.Name, "")
-	klog.V(4).Infof("GetScaleSetVms: scaleSet.Name: %s, vmList: %v", scaleSet.Name, vmList)
-	if rerr != nil {
-		klog.Errorf("VirtualMachineScaleSetVMsClient.List failed for %s: %v", scaleSet.Name, rerr)
-		return nil, rerr
-	}
-
-	return vmList, nil
-}
-
-// DecreaseTargetSize decreases the target size of the node group. This function
-// doesn't permit to delete any existing node and can be used only to reduce the
-// request for new nodes that have not been yet fulfilled. Delta should be negative.
-// It is assumed that cloud provider will not delete the existing nodes if the size
-// when there is an option to just decrease the target.
-func (scaleSet *ScaleSet) DecreaseTargetSize(delta int) error {
-	// VMSS size should be changed automatically after the Node deletion, hence this operation is not required.
-	// To prevent some unreproducible bugs, an extra refresh of cache is needed.
-	scaleSet.invalidateInstanceCache()
-	_, err := scaleSet.GetScaleSetSize()
-	if err != nil {
-		klog.Warningf("DecreaseTargetSize: failed with error: %v", err)
-	}
-	return err
-}
-
-// Belongs returns true if the given node belongs to the NodeGroup.
-func (scaleSet *ScaleSet) Belongs(node *apiv1.Node) (bool, error) {
-	klog.V(6).Infof("Check if node belongs to this scale set: scaleset:%v, node:%v\n", scaleSet, node)
-
-	ref := &azureRef{
-		Name: node.Spec.ProviderID,
-	}
-
-	targetAsg, err := scaleSet.manager.GetNodeGroupForInstance(ref)
-	if err != nil {
-		return false, err
-	}
-	if targetAsg == nil {
-		return false, fmt.Errorf("%s doesn't belong to a known scale set", node.Name)
-	}
-	if !strings.EqualFold(targetAsg.Id(), scaleSet.Id()) {
-		return false, nil
-	}
-	return true, nil
-}
-
-// DeleteInstances deletes the given instances. All instances must be controlled by the same ASG.
-func (scaleSet *ScaleSet) DeleteInstances(instances []*azureRef, hasUnregisteredNodes bool) error {
-	if len(instances) == 0 {
-		return nil
-	}
-
-	klog.V(3).Infof("Deleting vmss instances %v", instances)
-
-	commonAsg, err := scaleSet.manager.GetNodeGroupForInstance(instances[0])
-	if err != nil {
-		return err
-	}
-
-	instancesToDelete := []*azureRef{}
-	for _, instance := range instances {
-		asg, err := scaleSet.manager.GetNodeGroupForInstance(instance)
-		if err != nil {
-			return err
-		}
-
-		if !strings.EqualFold(asg.Id(), commonAsg.Id()) {
-			return fmt.Errorf("cannot delete instance (%s) which don't belong to the same Scale Set (%q)", instance.Name, commonAsg)
-		}
-
-		if cpi, found := scaleSet.getInstanceByProviderID(instance.Name); found && cpi.Status != nil && cpi.Status.State == cloudprovider.InstanceDeleting {
-			klog.V(3).Infof("Skipping deleting instance %s as its current state is deleting", instance.Name)
-			continue
-		}
-		instancesToDelete = append(instancesToDelete, instance)
-	}
-
-	// nothing to delete
-	if len(instancesToDelete) == 0 {
-		klog.V(3).Infof("No new instances eligible for deletion, skipping")
-		return nil
-	}
-
-	instanceIDs := []string{}
-	for _, instance := range instancesToDelete {
-		instanceID, err := getLastSegment(instance.Name)
-		if err != nil {
-			klog.Errorf("getLastSegment failed with error: %v", err)
-			return err
-		}
-		instanceIDs = append(instanceIDs, instanceID)
-	}
-
-	requiredIds := &compute.VirtualMachineScaleSetVMInstanceRequiredIDs{
-		InstanceIds: &instanceIDs,
-	}
-
-	ctx, cancel := getContextWithTimeout(vmssContextTimeout)
-	defer cancel()
-	resourceGroup := scaleSet.manager.config.ResourceGroup
-
-	scaleSet.instanceMutex.Lock()
-	klog.V(3).Infof("Calling virtualMachineScaleSetsClient.DeleteInstancesAsync(%v)", requiredIds.InstanceIds)
-	future, rerr := scaleSet.manager.azClient.virtualMachineScaleSetsClient.DeleteInstancesAsync(ctx, resourceGroup, commonAsg.Id(), *requiredIds)
-	scaleSet.instanceMutex.Unlock()
-	if rerr != nil {
-		klog.Errorf("virtualMachineScaleSetsClient.DeleteInstancesAsync for instances %v failed: %v", requiredIds.InstanceIds, rerr)
-		return rerr.Error()
-	}
-
-	// Proactively decrement scale set size so that we don't
-	// go below minimum node count if cache data is stale
-	// only do it for non-unregistered nodes
-	if !hasUnregisteredNodes {
-		scaleSet.sizeMutex.Lock()
-		scaleSet.curSize -= int64(len(instanceIDs))
-		scaleSet.sizeMutex.Unlock()
-	}
-
-	// Proactively set the status of the instances to be deleted in cache
-	for _, instance := range instancesToDelete {
-		scaleSet.setInstanceStatusByProviderID(instance.Name, cloudprovider.InstanceStatus{State: cloudprovider.InstanceDeleting})
-	}
-
-	go scaleSet.waitForDeleteInstances(future, requiredIds)
-
-	return nil
-}
-
-// DeleteNodes deletes the nodes from the group.
-func (scaleSet *ScaleSet) DeleteNodes(nodes []*apiv1.Node) error {
-	klog.V(8).Infof("Delete nodes requested: %q\n", nodes)
-	size, err := scaleSet.GetScaleSetSize()
-	if err != nil {
-		return err
-	}
-
-	if int(size) <= scaleSet.MinSize() {
-		return fmt.Errorf("min size reached, nodes will not be deleted")
-	}
-
-	refs := make([]*azureRef, 0, len(nodes))
-	hasUnregisteredNodes := false
-	for _, node := range nodes {
-		belongs, err := scaleSet.Belongs(node)
-		if err != nil {
-			return err
-		}
-
-		if belongs != true {
-			return fmt.Errorf("%s belongs to a different asg than %s", node.Name, scaleSet.Id())
-		}
-
-		if node.Annotations[cloudprovider.FakeNodeReasonAnnotation] == cloudprovider.FakeNodeUnregistered {
-			hasUnregisteredNodes = true
-		}
-		ref := &azureRef{
-			Name: node.Spec.ProviderID,
-		}
-		refs = append(refs, ref)
-	}
-
-	return scaleSet.DeleteInstances(refs, hasUnregisteredNodes)
-}
-
-// Id returns ScaleSet id.
-func (scaleSet *ScaleSet) Id() string {
-	return scaleSet.Name
-}
-
-// Debug returns a debug string for the Scale Set.
-func (scaleSet *ScaleSet) Debug() string {
-	return fmt.Sprintf("%s (%d:%d)", scaleSet.Id(), scaleSet.MinSize(), scaleSet.MaxSize())
-}
-
-// TemplateNodeInfo returns a node template for this scale set.
-func (scaleSet *ScaleSet) TemplateNodeInfo() (*schedulerframework.NodeInfo, error) {
-	template, rerr := scaleSet.getVMSSFromCache()
-	if rerr != nil {
-		return nil, rerr.Error()
-	}
-
-	node, err := buildNodeFromTemplate(scaleSet.Name, template)
-	if err != nil {
-		return nil, err
-	}
-
-	nodeInfo := schedulerframework.NewNodeInfo(cloudprovider.BuildKubeProxy(scaleSet.Name))
-	nodeInfo.SetNode(node)
-	return nodeInfo, nil
-}
-
-// Nodes returns a list of all nodes that belong to this node group.
-func (scaleSet *ScaleSet) Nodes() ([]cloudprovider.Instance, error) {
-	klog.V(4).Infof("Nodes: starts, scaleSet.Name: %s", scaleSet.Name)
-	curSize, err := scaleSet.getCurSize()
-	if err != nil {
-		klog.Errorf("Failed to get current size for vmss %q: %v", scaleSet.Name, err)
-		return nil, err
-	}
-
-	scaleSet.instanceMutex.Lock()
-	defer scaleSet.instanceMutex.Unlock()
-
-	if int64(len(scaleSet.instanceCache)) == curSize &&
-		scaleSet.lastInstanceRefresh.Add(scaleSet.instancesRefreshPeriod).After(time.Now()) {
-		klog.V(4).Infof("Nodes: returns with curSize %d", curSize)
-		return scaleSet.instanceCache, nil
-	}
-
-	klog.V(4).Infof("Nodes: starts to get VMSS VMs")
-	splay := rand.New(rand.NewSource(time.Now().UnixNano())).Intn(scaleSet.instancesRefreshJitter + 1)
-	lastRefresh := time.Now().Add(-time.Second * time.Duration(splay))
-
-	vms, rerr := scaleSet.GetScaleSetVms()
-	if rerr != nil {
-		if isAzureRequestsThrottled(rerr) {
-			// Log a warning and update the instance refresh time so that it would retry after cache expiration
-			klog.Warningf("GetScaleSetVms() is throttled with message %v, would return the cached instances", rerr)
-			scaleSet.lastInstanceRefresh = lastRefresh
-			return scaleSet.instanceCache, nil
-		}
-		return nil, rerr.Error()
-	}
-
-	scaleSet.instanceCache = buildInstanceCache(vms)
-	scaleSet.lastInstanceRefresh = lastRefresh
-	klog.V(4).Infof("Nodes: returns")
-	return scaleSet.instanceCache, nil
-}
-
-// Note that the GetScaleSetVms() results is not used directly because for the List endpoint,
-// their resource ID format is not consistent with Get endpoint
-func buildInstanceCache(vms []compute.VirtualMachineScaleSetVM) []cloudprovider.Instance {
-	instances := []cloudprovider.Instance{}
-
-	for _, vm := range vms {
-		// The resource ID is empty string, which indicates the instance may be in deleting state.
-		if len(*vm.ID) == 0 {
-			continue
-		}
-
-		resourceID, err := convertResourceGroupNameToLower(*vm.ID)
-		if err != nil {
-			// This shouldn't happen. Log a warning message for tracking.
-			klog.Warningf("buildInstanceCache.convertResourceGroupNameToLower failed with error: %v", err)
-			continue
-		}
-
-		instances = append(instances, cloudprovider.Instance{
-			Id:     "azure://" + resourceID,
-			Status: instanceStatusFromVM(vm),
-		})
-	}
-
-	return instances
-}
-
-func (scaleSet *ScaleSet) getInstanceByProviderID(providerID string) (cloudprovider.Instance, bool) {
-	scaleSet.instanceMutex.Lock()
-	defer scaleSet.instanceMutex.Unlock()
-	for _, instance := range scaleSet.instanceCache {
-		if instance.Id == providerID {
-			return instance, true
-		}
-	}
-	return cloudprovider.Instance{}, false
-}
-
-func (scaleSet *ScaleSet) setInstanceStatusByProviderID(providerID string, status cloudprovider.InstanceStatus) {
-	scaleSet.instanceMutex.Lock()
-	defer scaleSet.instanceMutex.Unlock()
-	for k, instance := range scaleSet.instanceCache {
-		if instance.Id == providerID {
-			klog.V(5).Infof("Setting instance %s status to %v", instance.Id, status)
-			scaleSet.instanceCache[k].Status = &status
-		}
-	}
-}
-
-// instanceStatusFromVM converts the VM provisioning state to cloudprovider.InstanceStatus
-func instanceStatusFromVM(vm compute.VirtualMachineScaleSetVM) *cloudprovider.InstanceStatus {
-	if vm.ProvisioningState == nil {
-		return nil
-	}
-
-	status := &cloudprovider.InstanceStatus{}
-	switch *vm.ProvisioningState {
-	case string(compute.ProvisioningStateDeleting):
-		status.State = cloudprovider.InstanceDeleting
-	case string(compute.ProvisioningStateCreating):
-		status.State = cloudprovider.InstanceCreating
-	default:
-		status.State = cloudprovider.InstanceRunning
-	}
-
-	return status
-}
-
-func (scaleSet *ScaleSet) invalidateInstanceCache() {
-	scaleSet.instanceMutex.Lock()
-	// Set the instanceCache as outdated.
-	scaleSet.lastInstanceRefresh = time.Now().Add(-1 * scaleSet.instancesRefreshPeriod)
-	scaleSet.instanceMutex.Unlock()
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_scale_set_test.go b/cluster-autoscaler/cloudprovider/azure/azure_scale_set_test.go
deleted file mode 100644
index dcb6185a1..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_scale_set_test.go
+++ /dev/null
@@ -1,577 +0,0 @@
-/*
-Copyright 2017 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"fmt"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"net/http"
-	"testing"
-	"time"
-
-	apiv1 "k8s.io/api/core/v1"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-	"k8s.io/legacy-cloud-providers/azure/clients/vmssclient/mockvmssclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/vmssvmclient/mockvmssvmclient"
-
-	"github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2019-12-01/compute"
-	"github.com/Azure/go-autorest/autorest/to"
-	"github.com/golang/mock/gomock"
-	"github.com/stretchr/testify/assert"
-)
-
-func newTestScaleSet(manager *AzureManager, name string) *ScaleSet {
-	return &ScaleSet{
-		azureRef: azureRef{
-			Name: name,
-		},
-		manager: manager,
-		minSize: 1,
-		maxSize: 5,
-	}
-}
-
-func newTestVMSSList(cap int64, name, loc string) []compute.VirtualMachineScaleSet {
-	return []compute.VirtualMachineScaleSet{
-		{
-			Name: to.StringPtr(name),
-			Sku: &compute.Sku{
-				Capacity: to.Int64Ptr(cap),
-				Name:     to.StringPtr("Standard_D4_v2"),
-			},
-			VirtualMachineScaleSetProperties: &compute.VirtualMachineScaleSetProperties{},
-			Location:                         to.StringPtr(loc),
-		},
-	}
-}
-
-func newTestVMSSVMList(count int) []compute.VirtualMachineScaleSetVM {
-	var vmssVMList []compute.VirtualMachineScaleSetVM
-	for i := 0; i < count; i++ {
-		vmssVM := compute.VirtualMachineScaleSetVM{
-			ID:         to.StringPtr(fmt.Sprintf(fakeVirtualMachineScaleSetVMID, i)),
-			InstanceID: to.StringPtr(fmt.Sprintf("%d", i)),
-			VirtualMachineScaleSetVMProperties: &compute.VirtualMachineScaleSetVMProperties{
-				VMID: to.StringPtr(fmt.Sprintf("123E4567-E89B-12D3-A456-426655440000-%d", i)),
-			},
-		}
-		vmssVMList = append(vmssVMList, vmssVM)
-	}
-	return vmssVMList
-}
-
-func TestMaxSize(t *testing.T) {
-	provider := newTestProvider(t)
-	registered := provider.azureManager.RegisterNodeGroup(
-		newTestScaleSet(provider.azureManager, "test-asg"))
-	assert.True(t, registered)
-	assert.Equal(t, len(provider.NodeGroups()), 1)
-	assert.Equal(t, provider.NodeGroups()[0].MaxSize(), 5)
-}
-
-func TestMinSize(t *testing.T) {
-	provider := newTestProvider(t)
-	registered := provider.azureManager.RegisterNodeGroup(
-		newTestScaleSet(provider.azureManager, "test-asg"))
-	assert.True(t, registered)
-	assert.Equal(t, len(provider.NodeGroups()), 1)
-	assert.Equal(t, provider.NodeGroups()[0].MinSize(), 1)
-}
-
-func TestTargetSize(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	expectedScaleSets := newTestVMSSList(3, "test-asg", "eastus")
-	expectedVMSSVMs := newTestVMSSVMList(3)
-
-	provider := newTestProvider(t)
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), provider.azureManager.config.ResourceGroup).Return(expectedScaleSets, nil).AnyTimes()
-	provider.azureManager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	mockVMSSVMClient := mockvmssvmclient.NewMockInterface(ctrl)
-	mockVMSSVMClient.EXPECT().List(gomock.Any(), provider.azureManager.config.ResourceGroup, "test-asg", gomock.Any()).Return(expectedVMSSVMs, nil).AnyTimes()
-	provider.azureManager.azClient.virtualMachineScaleSetVMsClient = mockVMSSVMClient
-	err := provider.azureManager.forceRefresh()
-	assert.NoError(t, err)
-
-	registered := provider.azureManager.RegisterNodeGroup(
-		newTestScaleSet(provider.azureManager, "test-asg"))
-	assert.True(t, registered)
-	assert.Equal(t, len(provider.NodeGroups()), 1)
-
-	targetSize, err := provider.NodeGroups()[0].TargetSize()
-	assert.NoError(t, err)
-	assert.Equal(t, 3, targetSize)
-}
-
-func TestIncreaseSize(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	expectedScaleSets := newTestVMSSList(3, "test-asg", "eastus")
-	expectedVMSSVMs := newTestVMSSVMList(3)
-
-	provider := newTestProvider(t)
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), provider.azureManager.config.ResourceGroup).Return(expectedScaleSets, nil).AnyTimes()
-	mockVMSSClient.EXPECT().CreateOrUpdateAsync(gomock.Any(), provider.azureManager.config.ResourceGroup, "test-asg", gomock.Any()).Return(nil, nil)
-	mockVMSSClient.EXPECT().WaitForAsyncOperationResult(gomock.Any(), gomock.Any()).Return(&http.Response{StatusCode: http.StatusOK}, nil).AnyTimes()
-	provider.azureManager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	mockVMSSVMClient := mockvmssvmclient.NewMockInterface(ctrl)
-	mockVMSSVMClient.EXPECT().List(gomock.Any(), provider.azureManager.config.ResourceGroup, "test-asg", gomock.Any()).Return(expectedVMSSVMs, nil).AnyTimes()
-	provider.azureManager.azClient.virtualMachineScaleSetVMsClient = mockVMSSVMClient
-	err := provider.azureManager.forceRefresh()
-	assert.NoError(t, err)
-
-	ss := newTestScaleSet(provider.azureManager, "test-asg")
-	ss.lastSizeRefresh = time.Now()
-	ss.sizeRefreshPeriod = 1 * time.Minute
-	ss.curSize = -1
-	err = ss.IncreaseSize(100)
-	expectedErr := fmt.Errorf("the scale set test-asg is under initialization, skipping IncreaseSize")
-	assert.Equal(t, expectedErr, err)
-
-	registered := provider.azureManager.RegisterNodeGroup(
-		newTestScaleSet(provider.azureManager, "test-asg"))
-	assert.True(t, registered)
-	assert.Equal(t, len(provider.NodeGroups()), 1)
-
-	// current target size is 2.
-	targetSize, err := provider.NodeGroups()[0].TargetSize()
-	assert.NoError(t, err)
-	assert.Equal(t, 3, targetSize)
-
-	// increase 3 nodes.
-	err = provider.NodeGroups()[0].IncreaseSize(2)
-	assert.NoError(t, err)
-
-	// new target size should be 5.
-	targetSize, err = provider.NodeGroups()[0].TargetSize()
-	assert.NoError(t, err)
-	assert.Equal(t, 5, targetSize)
-}
-
-func TestIncreaseSizeOnVMSSUpdating(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	manager := newTestAzureManager(t)
-	vmssName := "vmss-updating"
-	var vmssCapacity int64 = 3
-
-	expectedScaleSets := []compute.VirtualMachineScaleSet{
-		{
-			Name: &vmssName,
-			Sku: &compute.Sku{
-				Capacity: &vmssCapacity,
-			},
-			VirtualMachineScaleSetProperties: &compute.VirtualMachineScaleSetProperties{
-				ProvisioningState: to.StringPtr(string(compute.ProvisioningStateUpdating)),
-			},
-		},
-	}
-	expectedVMSSVMs := newTestVMSSVMList(3)
-
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup).Return(expectedScaleSets, nil)
-	mockVMSSClient.EXPECT().CreateOrUpdateAsync(gomock.Any(), manager.config.ResourceGroup, vmssName, gomock.Any()).Return(nil, nil)
-	mockVMSSClient.EXPECT().WaitForAsyncOperationResult(gomock.Any(), gomock.Any()).Return(&http.Response{StatusCode: http.StatusOK}, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	mockVMSSVMClient := mockvmssvmclient.NewMockInterface(ctrl)
-	mockVMSSVMClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup, "vmss-updating", gomock.Any()).Return(expectedVMSSVMs, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetVMsClient = mockVMSSVMClient
-	manager.explicitlyConfigured["vmss-updating"] = true
-	registered := manager.RegisterNodeGroup(newTestScaleSet(manager, vmssName))
-	assert.True(t, registered)
-	manager.Refresh()
-
-	provider, err := BuildAzureCloudProvider(manager, nil)
-	assert.NoError(t, err)
-
-	// Scaling should continue even VMSS is under updating.
-	scaleSet, ok := provider.NodeGroups()[0].(*ScaleSet)
-	assert.True(t, ok)
-	err = scaleSet.IncreaseSize(1)
-	assert.NoError(t, err)
-}
-
-func TestBelongs(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	expectedScaleSets := newTestVMSSList(3, "test-asg", "eastus")
-	expectedVMSSVMs := newTestVMSSVMList(3)
-
-	provider := newTestProvider(t)
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), provider.azureManager.config.ResourceGroup).Return(expectedScaleSets, nil)
-	provider.azureManager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	mockVMSSVMClient := mockvmssvmclient.NewMockInterface(ctrl)
-	mockVMSSVMClient.EXPECT().List(gomock.Any(), provider.azureManager.config.ResourceGroup, "test-asg", gomock.Any()).Return(expectedVMSSVMs, nil).AnyTimes()
-	provider.azureManager.azClient.virtualMachineScaleSetVMsClient = mockVMSSVMClient
-
-	registered := provider.azureManager.RegisterNodeGroup(
-		newTestScaleSet(provider.azureManager, "test-asg"))
-	assert.True(t, registered)
-
-	scaleSet, ok := provider.NodeGroups()[0].(*ScaleSet)
-	assert.True(t, ok)
-	provider.azureManager.explicitlyConfigured["test-asg"] = true
-	provider.azureManager.Refresh()
-
-	invalidNode := &apiv1.Node{
-		Spec: apiv1.NodeSpec{
-			ProviderID: "azure:///subscriptions/test-subscrition-id/resourcegroups/invalid-asg/providers/microsoft.compute/virtualmachinescalesets/agents/virtualmachines/0",
-		},
-	}
-	_, err := scaleSet.Belongs(invalidNode)
-	assert.Error(t, err)
-
-	validNode := &apiv1.Node{
-		Spec: apiv1.NodeSpec{
-			ProviderID: "azure://" + fmt.Sprintf(fakeVirtualMachineScaleSetVMID, 0),
-		},
-	}
-	belongs, err := scaleSet.Belongs(validNode)
-	assert.Equal(t, true, belongs)
-	assert.NoError(t, err)
-}
-
-func TestDeleteNodes(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	manager := newTestAzureManager(t)
-	vmssName := "test-asg"
-	var vmssCapacity int64 = 3
-
-	expectedScaleSets := []compute.VirtualMachineScaleSet{
-		{
-			Name: &vmssName,
-			Sku: &compute.Sku{
-				Capacity: &vmssCapacity,
-			},
-		},
-	}
-	expectedVMSSVMs := newTestVMSSVMList(3)
-
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup).Return(expectedScaleSets, nil).Times(2)
-	mockVMSSClient.EXPECT().DeleteInstancesAsync(gomock.Any(), manager.config.ResourceGroup, gomock.Any(), gomock.Any()).Return(nil, nil)
-	mockVMSSClient.EXPECT().WaitForAsyncOperationResult(gomock.Any(), gomock.Any()).Return(&http.Response{StatusCode: http.StatusOK}, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	mockVMSSVMClient := mockvmssvmclient.NewMockInterface(ctrl)
-	mockVMSSVMClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup, "test-asg", gomock.Any()).Return(expectedVMSSVMs, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetVMsClient = mockVMSSVMClient
-	err := manager.forceRefresh()
-	assert.NoError(t, err)
-
-	resourceLimiter := cloudprovider.NewResourceLimiter(
-		map[string]int64{cloudprovider.ResourceNameCores: 1, cloudprovider.ResourceNameMemory: 10000000},
-		map[string]int64{cloudprovider.ResourceNameCores: 10, cloudprovider.ResourceNameMemory: 100000000})
-	provider, err := BuildAzureCloudProvider(manager, resourceLimiter)
-	assert.NoError(t, err)
-
-	registered := manager.RegisterNodeGroup(
-		newTestScaleSet(manager, "test-asg"))
-	manager.explicitlyConfigured["test-asg"] = true
-	assert.True(t, registered)
-	err = manager.forceRefresh()
-	assert.NoError(t, err)
-
-	scaleSet, ok := provider.NodeGroups()[0].(*ScaleSet)
-	assert.True(t, ok)
-
-	targetSize, err := scaleSet.TargetSize()
-	assert.NoError(t, err)
-	assert.Equal(t, 3, targetSize)
-
-	// Perform the delete operation
-	nodesToDelete := []*apiv1.Node{
-		{
-			Spec: apiv1.NodeSpec{
-				ProviderID: "azure://" + fmt.Sprintf(fakeVirtualMachineScaleSetVMID, 0),
-			},
-		},
-		{
-			Spec: apiv1.NodeSpec{
-				ProviderID: "azure://" + fmt.Sprintf(fakeVirtualMachineScaleSetVMID, 2),
-			},
-		},
-	}
-	err = scaleSet.DeleteNodes(nodesToDelete)
-	assert.NoError(t, err)
-	vmssCapacity = 1
-	expectedScaleSets = []compute.VirtualMachineScaleSet{
-		{
-			Name: &vmssName,
-			Sku: &compute.Sku{
-				Capacity: &vmssCapacity,
-			},
-		},
-	}
-	mockVMSSClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup).Return(expectedScaleSets, nil).AnyTimes()
-	expectedVMSSVMs[0].ProvisioningState = to.StringPtr(string(compute.ProvisioningStateDeleting))
-	expectedVMSSVMs[2].ProvisioningState = to.StringPtr(string(compute.ProvisioningStateDeleting))
-	mockVMSSVMClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup, "test-asg", gomock.Any()).Return(expectedVMSSVMs, nil).AnyTimes()
-	err = manager.forceRefresh()
-	assert.NoError(t, err)
-
-	// Ensure the the cached size has been proactively decremented by 2
-	targetSize, err = scaleSet.TargetSize()
-	assert.NoError(t, err)
-	assert.Equal(t, 1, targetSize)
-
-	// Ensure that the status for the instances is Deleting
-	instance0, found := scaleSet.getInstanceByProviderID("azure://" + fmt.Sprintf(fakeVirtualMachineScaleSetVMID, 0))
-	assert.True(t, found, true)
-	assert.Equal(t, instance0.Status.State, cloudprovider.InstanceDeleting)
-
-	instance2, found := scaleSet.getInstanceByProviderID("azure://" + fmt.Sprintf(fakeVirtualMachineScaleSetVMID, 2))
-	assert.True(t, found, true)
-	assert.Equal(t, instance2.Status.State, cloudprovider.InstanceDeleting)
-}
-
-func TestDeleteNodeUnregistered(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	manager := newTestAzureManager(t)
-	vmssName := "test-asg"
-	var vmssCapacity int64 = 2
-
-	expectedScaleSets := []compute.VirtualMachineScaleSet{
-		{
-			Name: &vmssName,
-			Sku: &compute.Sku{
-				Capacity: &vmssCapacity,
-			},
-		},
-	}
-	expectedVMSSVMs := newTestVMSSVMList(2)
-
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup).Return(expectedScaleSets, nil).Times(2)
-	mockVMSSClient.EXPECT().DeleteInstancesAsync(gomock.Any(), manager.config.ResourceGroup, gomock.Any(), gomock.Any()).Return(nil, nil)
-	mockVMSSClient.EXPECT().WaitForAsyncOperationResult(gomock.Any(), gomock.Any()).Return(&http.Response{StatusCode: http.StatusOK}, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	mockVMSSVMClient := mockvmssvmclient.NewMockInterface(ctrl)
-	mockVMSSVMClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup, "test-asg", gomock.Any()).Return(expectedVMSSVMs, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetVMsClient = mockVMSSVMClient
-	err := manager.forceRefresh()
-	assert.NoError(t, err)
-
-	resourceLimiter := cloudprovider.NewResourceLimiter(
-		map[string]int64{cloudprovider.ResourceNameCores: 1, cloudprovider.ResourceNameMemory: 10000000},
-		map[string]int64{cloudprovider.ResourceNameCores: 10, cloudprovider.ResourceNameMemory: 100000000})
-	provider, err := BuildAzureCloudProvider(manager, resourceLimiter)
-	assert.NoError(t, err)
-
-	registered := manager.RegisterNodeGroup(
-		newTestScaleSet(manager, "test-asg"))
-	manager.explicitlyConfigured["test-asg"] = true
-	assert.True(t, registered)
-	err = manager.forceRefresh()
-	assert.NoError(t, err)
-
-	scaleSet, ok := provider.NodeGroups()[0].(*ScaleSet)
-	assert.True(t, ok)
-
-	targetSize, err := scaleSet.TargetSize()
-	assert.NoError(t, err)
-	assert.Equal(t, 2, targetSize)
-
-	// annotate node with unregistered annotation
-	annotations := make(map[string]string)
-	annotations[cloudprovider.FakeNodeReasonAnnotation] = cloudprovider.FakeNodeUnregistered
-	nodesToDelete := []*apiv1.Node{
-		{
-			ObjectMeta: metav1.ObjectMeta{
-				Annotations: annotations,
-			},
-			Spec: apiv1.NodeSpec{
-				ProviderID: "azure://" + fmt.Sprintf(fakeVirtualMachineScaleSetVMID, 0),
-			},
-		},
-	}
-	err = scaleSet.DeleteNodes(nodesToDelete)
-	assert.NoError(t, err)
-
-	// Ensure the the cached size has NOT been proactively decremented
-	targetSize, err = scaleSet.TargetSize()
-	assert.NoError(t, err)
-	assert.Equal(t, 2, targetSize)
-
-	// Ensure that the status for the instances is Deleting
-	instance0, found := scaleSet.getInstanceByProviderID("azure://" + fmt.Sprintf(fakeVirtualMachineScaleSetVMID, 0))
-	assert.True(t, found, true)
-	assert.Equal(t, instance0.Status.State, cloudprovider.InstanceDeleting)
-}
-
-func TestDeleteNoConflictRequest(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	vmssName := "test-asg"
-	var vmssCapacity int64 = 3
-
-	manager := newTestAzureManager(t)
-
-	expectedVMSSVMs := []compute.VirtualMachineScaleSetVM{
-		{
-			ID:         to.StringPtr(fakeVirtualMachineScaleSetVMID),
-			InstanceID: to.StringPtr("0"),
-			VirtualMachineScaleSetVMProperties: &compute.VirtualMachineScaleSetVMProperties{
-				VMID:              to.StringPtr("123E4567-E89B-12D3-A456-426655440000"),
-				ProvisioningState: to.StringPtr("Deleting"),
-			},
-		},
-	}
-	expectedScaleSets := []compute.VirtualMachineScaleSet{
-		{
-			Name: &vmssName,
-			Sku: &compute.Sku{
-				Capacity: &vmssCapacity,
-			},
-		},
-	}
-
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup).Return(expectedScaleSets, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	mockVMSSVMClient := mockvmssvmclient.NewMockInterface(ctrl)
-	mockVMSSVMClient.EXPECT().List(gomock.Any(), manager.config.ResourceGroup, "test-asg", gomock.Any()).Return(expectedVMSSVMs, nil).AnyTimes()
-	manager.azClient.virtualMachineScaleSetVMsClient = mockVMSSVMClient
-
-	resourceLimiter := cloudprovider.NewResourceLimiter(
-		map[string]int64{cloudprovider.ResourceNameCores: 1, cloudprovider.ResourceNameMemory: 10000000},
-		map[string]int64{cloudprovider.ResourceNameCores: 10, cloudprovider.ResourceNameMemory: 100000000})
-	provider, err := BuildAzureCloudProvider(manager, resourceLimiter)
-	assert.NoError(t, err)
-
-	registered := manager.RegisterNodeGroup(newTestScaleSet(manager, "test-asg"))
-	manager.explicitlyConfigured["test-asg"] = true
-	assert.True(t, registered)
-	manager.Refresh()
-
-	node := &apiv1.Node{
-		Spec: apiv1.NodeSpec{
-			ProviderID: "azure://" + fmt.Sprintf(fakeVirtualMachineScaleSetVMID, 0),
-		},
-	}
-
-	scaleSet, ok := provider.NodeGroups()[0].(*ScaleSet)
-	assert.True(t, ok)
-
-	err = scaleSet.DeleteNodes([]*apiv1.Node{node})
-}
-
-func TestId(t *testing.T) {
-	provider := newTestProvider(t)
-	registered := provider.azureManager.RegisterNodeGroup(
-		newTestScaleSet(provider.azureManager, "test-asg"))
-	assert.True(t, registered)
-	assert.Equal(t, len(provider.NodeGroups()), 1)
-	assert.Equal(t, provider.NodeGroups()[0].Id(), "test-asg")
-}
-
-func TestDebug(t *testing.T) {
-	asg := ScaleSet{
-		manager: newTestAzureManager(t),
-		minSize: 5,
-		maxSize: 55,
-	}
-	asg.Name = "test-scale-set"
-	assert.Equal(t, asg.Debug(), "test-scale-set (5:55)")
-}
-
-func TestScaleSetNodes(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	expectedVMSSVMs := newTestVMSSVMList(3)
-	expectedScaleSets := newTestVMSSList(3, "test-asg", "eastus")
-
-	provider := newTestProvider(t)
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), provider.azureManager.config.ResourceGroup).Return(expectedScaleSets, nil).AnyTimes()
-	provider.azureManager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	mockVMSSVMClient := mockvmssvmclient.NewMockInterface(ctrl)
-	mockVMSSVMClient.EXPECT().List(gomock.Any(), provider.azureManager.config.ResourceGroup, "test-asg", gomock.Any()).Return(expectedVMSSVMs, nil).AnyTimes()
-	provider.azureManager.azClient.virtualMachineScaleSetVMsClient = mockVMSSVMClient
-
-	registered := provider.azureManager.RegisterNodeGroup(
-		newTestScaleSet(provider.azureManager, "test-asg"))
-	provider.azureManager.explicitlyConfigured["test-asg"] = true
-	provider.azureManager.Refresh()
-	assert.True(t, registered)
-	assert.Equal(t, len(provider.NodeGroups()), 1)
-
-	node := &apiv1.Node{
-		Spec: apiv1.NodeSpec{
-			ProviderID: "azure://" + fmt.Sprintf(fakeVirtualMachineScaleSetVMID, 0),
-		},
-	}
-	group, err := provider.NodeGroupForNode(node)
-	assert.NoError(t, err)
-	assert.NotNil(t, group, "Group should not be nil")
-	assert.Equal(t, group.Id(), "test-asg")
-	assert.Equal(t, group.MinSize(), 1)
-	assert.Equal(t, group.MaxSize(), 5)
-
-	ss, ok := group.(*ScaleSet)
-	assert.True(t, ok)
-	assert.NotNil(t, ss)
-	instances, err := group.Nodes()
-	assert.NoError(t, err)
-	assert.Equal(t, len(instances), 3)
-	assert.Equal(t, instances[0], cloudprovider.Instance{Id: "azure://" + fmt.Sprintf(fakeVirtualMachineScaleSetVMID, 0)})
-	assert.Equal(t, instances[1], cloudprovider.Instance{Id: "azure://" + fmt.Sprintf(fakeVirtualMachineScaleSetVMID, 1)})
-	assert.Equal(t, instances[2], cloudprovider.Instance{Id: "azure://" + fmt.Sprintf(fakeVirtualMachineScaleSetVMID, 2)})
-}
-
-func TestTemplateNodeInfo(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	expectedScaleSets := newTestVMSSList(3, "test-asg", "eastus")
-
-	provider := newTestProvider(t)
-	mockVMSSClient := mockvmssclient.NewMockInterface(ctrl)
-	mockVMSSClient.EXPECT().List(gomock.Any(), provider.azureManager.config.ResourceGroup).Return(expectedScaleSets, nil).AnyTimes()
-	provider.azureManager.azClient.virtualMachineScaleSetsClient = mockVMSSClient
-	err := provider.azureManager.forceRefresh()
-	assert.NoError(t, err)
-
-	registered := provider.azureManager.RegisterNodeGroup(
-		newTestScaleSet(provider.azureManager, "test-asg"))
-	assert.True(t, registered)
-	assert.Equal(t, len(provider.NodeGroups()), 1)
-
-	asg := ScaleSet{
-		manager: provider.azureManager,
-		minSize: 1,
-		maxSize: 5,
-	}
-	asg.Name = "test-asg"
-
-	nodeInfo, err := asg.TemplateNodeInfo()
-	assert.NoError(t, err)
-	assert.NotNil(t, nodeInfo)
-	assert.NotEmpty(t, nodeInfo.Pods)
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_template.go b/cluster-autoscaler/cloudprovider/azure/azure_template.go
deleted file mode 100644
index eb931f31c..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_template.go
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
-Copyright 2020 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"fmt"
-	"github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2019-12-01/compute"
-	apiv1 "k8s.io/api/core/v1"
-	"k8s.io/apimachinery/pkg/api/resource"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-	"k8s.io/autoscaler/cluster-autoscaler/utils/gpu"
-	cloudvolume "k8s.io/cloud-provider/volume"
-	"k8s.io/klog/v2"
-	kubeletapis "k8s.io/kubelet/pkg/apis"
-	"math/rand"
-	"regexp"
-	"strings"
-)
-
-func buildInstanceOS(template compute.VirtualMachineScaleSet) string {
-	instanceOS := cloudprovider.DefaultOS
-	if template.VirtualMachineProfile != nil && template.VirtualMachineProfile.OsProfile != nil && template.VirtualMachineProfile.OsProfile.WindowsConfiguration != nil {
-		instanceOS = "windows"
-	}
-
-	return instanceOS
-}
-
-func buildGenericLabels(template compute.VirtualMachineScaleSet, nodeName string) map[string]string {
-	result := make(map[string]string)
-
-	result[kubeletapis.LabelArch] = cloudprovider.DefaultArch
-	result[apiv1.LabelArchStable] = cloudprovider.DefaultArch
-
-	result[kubeletapis.LabelOS] = buildInstanceOS(template)
-	result[apiv1.LabelOSStable] = buildInstanceOS(template)
-
-	result[apiv1.LabelInstanceType] = *template.Sku.Name
-	result[apiv1.LabelZoneRegion] = strings.ToLower(*template.Location)
-
-	if template.Zones != nil && len(*template.Zones) > 0 {
-		failureDomains := make([]string, len(*template.Zones))
-		for k, v := range *template.Zones {
-			failureDomains[k] = strings.ToLower(*template.Location) + "-" + v
-		}
-
-		result[apiv1.LabelZoneFailureDomain] = strings.Join(failureDomains[:], cloudvolume.LabelMultiZoneDelimiter)
-	} else {
-		result[apiv1.LabelZoneFailureDomain] = "0"
-	}
-
-	result[apiv1.LabelHostname] = nodeName
-	return result
-}
-
-func buildNodeFromTemplate(scaleSetName string, template compute.VirtualMachineScaleSet) (*apiv1.Node, error) {
-	node := apiv1.Node{}
-	nodeName := fmt.Sprintf("%s-asg-%d", scaleSetName, rand.Int63())
-
-	node.ObjectMeta = metav1.ObjectMeta{
-		Name:     nodeName,
-		SelfLink: fmt.Sprintf("/api/v1/nodes/%s", nodeName),
-		Labels:   map[string]string{},
-	}
-
-	node.Status = apiv1.NodeStatus{
-		Capacity: apiv1.ResourceList{},
-	}
-
-	var vmssType *InstanceType
-	for k := range InstanceTypes {
-		if strings.EqualFold(k, *template.Sku.Name) {
-			vmssType = InstanceTypes[k]
-			break
-		}
-	}
-
-	promoRe := regexp.MustCompile(`(?i)_promo`)
-	if promoRe.MatchString(*template.Sku.Name) {
-		if vmssType == nil {
-			// We didn't find an exact match but this is a promo type, check for matching standard
-			klog.V(1).Infof("No exact match found for %s, checking standard types", *template.Sku.Name)
-			skuName := promoRe.ReplaceAllString(*template.Sku.Name, "")
-			for k := range InstanceTypes {
-				if strings.EqualFold(k, skuName) {
-					vmssType = InstanceTypes[k]
-					break
-				}
-			}
-		}
-	}
-
-	if vmssType == nil {
-		return nil, fmt.Errorf("instance type %q not supported", *template.Sku.Name)
-	}
-	node.Status.Capacity[apiv1.ResourcePods] = *resource.NewQuantity(110, resource.DecimalSI)
-	node.Status.Capacity[apiv1.ResourceCPU] = *resource.NewQuantity(vmssType.VCPU, resource.DecimalSI)
-	node.Status.Capacity[gpu.ResourceNvidiaGPU] = *resource.NewQuantity(vmssType.GPU, resource.DecimalSI)
-	node.Status.Capacity[apiv1.ResourceMemory] = *resource.NewQuantity(vmssType.MemoryMb*1024*1024, resource.DecimalSI)
-
-	resourcesFromTags := extractAllocatableResourcesFromScaleSet(template.Tags)
-	for resourceName, val := range resourcesFromTags {
-		node.Status.Capacity[apiv1.ResourceName(resourceName)] = *val
-	}
-
-	// TODO: set real allocatable.
-	node.Status.Allocatable = node.Status.Capacity
-
-	// NodeLabels
-	if template.Tags != nil {
-		for k, v := range template.Tags {
-			if v != nil {
-				node.Labels[k] = *v
-			} else {
-				node.Labels[k] = ""
-			}
-
-		}
-	}
-
-	// GenericLabels
-	node.Labels = cloudprovider.JoinStringMaps(node.Labels, buildGenericLabels(template, nodeName))
-	// Labels from the Scale Set's Tags
-	node.Labels = cloudprovider.JoinStringMaps(node.Labels, extractLabelsFromScaleSet(template.Tags))
-
-	// Taints from the Scale Set's Tags
-	node.Spec.Taints = extractTaintsFromScaleSet(template.Tags)
-
-	node.Status.Conditions = cloudprovider.BuildReadyConditions()
-	return &node, nil
-}
-
-func extractLabelsFromScaleSet(tags map[string]*string) map[string]string {
-	result := make(map[string]string)
-
-	for tagName, tagValue := range tags {
-		splits := strings.Split(tagName, nodeLabelTagName)
-		if len(splits) > 1 {
-			label := strings.Replace(splits[1], "_", "/", -1)
-			if label != "" {
-				result[label] = *tagValue
-			}
-		}
-	}
-
-	return result
-}
-
-func extractTaintsFromScaleSet(tags map[string]*string) []apiv1.Taint {
-	taints := make([]apiv1.Taint, 0)
-
-	for tagName, tagValue := range tags {
-		// The tag value must be in the format <tag>:NoSchedule
-		r, _ := regexp.Compile("(.*):(?:NoSchedule|NoExecute|PreferNoSchedule)")
-
-		if r.MatchString(*tagValue) {
-			splits := strings.Split(tagName, nodeTaintTagName)
-			if len(splits) > 1 {
-				values := strings.SplitN(*tagValue, ":", 2)
-				if len(values) > 1 {
-					taintKey := strings.Replace(splits[1], "_", "/", -1)
-					taints = append(taints, apiv1.Taint{
-						Key:    taintKey,
-						Value:  values[0],
-						Effect: apiv1.TaintEffect(values[1]),
-					})
-				}
-			}
-		}
-	}
-
-	return taints
-}
-
-func extractAllocatableResourcesFromScaleSet(tags map[string]*string) map[string]*resource.Quantity {
-	resources := make(map[string]*resource.Quantity)
-
-	for tagName, tagValue := range tags {
-		resourceName := strings.Split(tagName, nodeResourcesTagName)
-		if len(resourceName) < 2 || resourceName[1] == "" {
-			continue
-		}
-
-		quantity, err := resource.ParseQuantity(*tagValue)
-		if err != nil {
-			continue
-		}
-		resources[resourceName[1]] = &quantity
-	}
-
-	return resources
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_template_test.go b/cluster-autoscaler/cloudprovider/azure/azure_template_test.go
deleted file mode 100644
index 3ee23080e..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_template_test.go
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
-Copyright 2020 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"fmt"
-	"github.com/Azure/go-autorest/autorest/to"
-	"github.com/stretchr/testify/assert"
-	apiv1 "k8s.io/api/core/v1"
-	"k8s.io/apimachinery/pkg/api/resource"
-	"testing"
-)
-
-func TestExtractLabelsFromScaleSet(t *testing.T) {
-	expectedNodeLabelKey := "zip"
-	expectedNodeLabelValue := "zap"
-	extraNodeLabelValue := "buzz"
-	blankString := ""
-
-	tags := map[string]*string{
-		fmt.Sprintf("%s%s", nodeLabelTagName, expectedNodeLabelKey): &expectedNodeLabelValue,
-		"fizz": &extraNodeLabelValue,
-		"bip":  &blankString,
-	}
-
-	labels := extractLabelsFromScaleSet(tags)
-	assert.Len(t, labels, 1)
-	assert.Equal(t, expectedNodeLabelValue, labels[expectedNodeLabelKey])
-}
-
-func TestExtractTaintsFromScaleSet(t *testing.T) {
-	noScheduleTaintValue := "foo:NoSchedule"
-	noExecuteTaintValue := "bar:NoExecute"
-	preferNoScheduleTaintValue := "fizz:PreferNoSchedule"
-	noSplitTaintValue := "some_value"
-	blankTaintValue := ""
-	regularTagValue := "baz"
-
-	tags := map[string]*string{
-		fmt.Sprintf("%s%s", nodeTaintTagName, "dedicated"):                          &noScheduleTaintValue,
-		fmt.Sprintf("%s%s", nodeTaintTagName, "group"):                              &noExecuteTaintValue,
-		fmt.Sprintf("%s%s", nodeTaintTagName, "app"):                                &preferNoScheduleTaintValue,
-		fmt.Sprintf("%s%s", nodeTaintTagName, "k8s.io_testing_underscore_to_slash"): &preferNoScheduleTaintValue,
-		"bar": &regularTagValue,
-		fmt.Sprintf("%s%s", nodeTaintTagName, "blank"):   &blankTaintValue,
-		fmt.Sprintf("%s%s", nodeTaintTagName, "nosplit"): &noSplitTaintValue,
-	}
-
-	expectedTaints := []apiv1.Taint{
-		{
-			Key:    "dedicated",
-			Value:  "foo",
-			Effect: apiv1.TaintEffectNoSchedule,
-		},
-		{
-			Key:    "group",
-			Value:  "bar",
-			Effect: apiv1.TaintEffectNoExecute,
-		},
-		{
-			Key:    "app",
-			Value:  "fizz",
-			Effect: apiv1.TaintEffectPreferNoSchedule,
-		},
-		{
-			Key:    "k8s.io/testing/underscore/to/slash",
-			Value:  "fizz",
-			Effect: apiv1.TaintEffectPreferNoSchedule,
-		},
-	}
-
-	taints := extractTaintsFromScaleSet(tags)
-	assert.Len(t, taints, 4)
-	assert.Equal(t, makeTaintSet(expectedTaints), makeTaintSet(taints))
-}
-
-func TestExtractAllocatableResourcesFromScaleSet(t *testing.T) {
-	tags := map[string]*string{
-		fmt.Sprintf("%s%s", nodeResourcesTagName, "cpu"):               to.StringPtr("100m"),
-		fmt.Sprintf("%s%s", nodeResourcesTagName, "memory"):            to.StringPtr("100M"),
-		fmt.Sprintf("%s%s", nodeResourcesTagName, "ephemeral-storage"): to.StringPtr("20G"),
-	}
-
-	labels := extractAllocatableResourcesFromScaleSet(tags)
-
-	assert.Equal(t, resource.NewMilliQuantity(100, resource.DecimalSI).String(), labels["cpu"].String())
-	expectedMemory := resource.MustParse("100M")
-	assert.Equal(t, (&expectedMemory).String(), labels["memory"].String())
-	expectedEphemeralStorage := resource.MustParse("20G")
-	assert.Equal(t, (&expectedEphemeralStorage).String(), labels["ephemeral-storage"].String())
-}
-
-func makeTaintSet(taints []apiv1.Taint) map[apiv1.Taint]bool {
-	set := make(map[apiv1.Taint]bool)
-	for _, taint := range taints {
-		set[taint] = true
-	}
-	return set
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_util.go b/cluster-autoscaler/cloudprovider/azure/azure_util.go
deleted file mode 100644
index 1f81c8d65..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_util.go
+++ /dev/null
@@ -1,609 +0,0 @@
-/*
-Copyright 2017 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"context"
-	"crypto/rsa"
-	"crypto/x509"
-	"encoding/json"
-	"fmt"
-	"io/ioutil"
-	"net/http"
-	"net/url"
-	"regexp"
-	"sort"
-	"strconv"
-	"strings"
-	"time"
-
-	"github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2019-12-01/compute"
-	azStorage "github.com/Azure/azure-sdk-for-go/storage"
-	"github.com/Azure/go-autorest/autorest"
-	"github.com/Azure/go-autorest/autorest/to"
-
-	"golang.org/x/crypto/pkcs12"
-
-	"k8s.io/autoscaler/cluster-autoscaler/version"
-	klog "k8s.io/klog/v2"
-	"k8s.io/legacy-cloud-providers/azure/retry"
-)
-
-const (
-	//Field names
-	customDataFieldName      = "customData"
-	dependsOnFieldName       = "dependsOn"
-	hardwareProfileFieldName = "hardwareProfile"
-	imageReferenceFieldName  = "imageReference"
-	nameFieldName            = "name"
-	osProfileFieldName       = "osProfile"
-	propertiesFieldName      = "properties"
-	resourcesFieldName       = "resources"
-	storageProfileFieldName  = "storageProfile"
-	typeFieldName            = "type"
-	vmSizeFieldName          = "vmSize"
-
-	// ARM resource Types
-	nsgResourceType = "Microsoft.Network/networkSecurityGroups"
-	rtResourceType  = "Microsoft.Network/routeTables"
-	vmResourceType  = "Microsoft.Compute/virtualMachines"
-	vmExtensionType = "Microsoft.Compute/virtualMachines/extensions"
-
-	// resource ids
-	nsgID = "nsgID"
-	rtID  = "routeTableID"
-
-	k8sLinuxVMNamingFormat         = "^[0-9a-zA-Z]{3}-(.+)-([0-9a-fA-F]{8})-{0,2}([0-9]+)$"
-	k8sLinuxVMAgentPoolNameIndex   = 1
-	k8sLinuxVMAgentClusterIDIndex  = 2
-	k8sLinuxVMAgentIndexArrayIndex = 3
-
-	k8sWindowsOldVMNamingFormat            = "^([a-fA-F0-9]{5})([0-9a-zA-Z]{3})([9])([a-zA-Z0-9]{3,5})$"
-	k8sWindowsVMNamingFormat               = "^([a-fA-F0-9]{4})([0-9a-zA-Z]{3})([0-9]{3,8})$"
-	k8sWindowsVMAgentPoolPrefixIndex       = 1
-	k8sWindowsVMAgentOrchestratorNameIndex = 2
-	k8sWindowsVMAgentPoolInfoIndex         = 3
-
-	nodeLabelTagName     = "k8s.io_cluster-autoscaler_node-template_label_"
-	nodeTaintTagName     = "k8s.io_cluster-autoscaler_node-template_taint_"
-	nodeResourcesTagName = "k8s.io_cluster-autoscaler_node-template_resources_"
-)
-
-var (
-	vmnameLinuxRegexp        = regexp.MustCompile(k8sLinuxVMNamingFormat)
-	vmnameWindowsRegexp      = regexp.MustCompile(k8sWindowsVMNamingFormat)
-	oldvmnameWindowsRegexp   = regexp.MustCompile(k8sWindowsOldVMNamingFormat)
-	azureResourceGroupNameRE = regexp.MustCompile(`.*/subscriptions/(?:.*)/resourceGroups/(.+)/providers/(?:.*)`)
-)
-
-//AzUtil consists of utility functions which utilizes clients to different services.
-//Since they span across various clients they cannot be fitted into individual client structs
-//so adding them here.
-type AzUtil struct {
-	manager *AzureManager
-}
-
-// DeleteBlob deletes the blob using the storage client.
-func (util *AzUtil) DeleteBlob(accountName, vhdContainer, vhdBlob string) error {
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-
-	storageKeysResult, rerr := util.manager.azClient.storageAccountsClient.ListKeys(ctx, util.manager.config.ResourceGroup, accountName)
-	if rerr != nil {
-		return rerr.Error()
-	}
-
-	keys := *storageKeysResult.Keys
-	client, err := azStorage.NewBasicClientOnSovereignCloud(accountName, to.String(keys[0].Value), util.manager.env)
-	if err != nil {
-		return err
-	}
-
-	bs := client.GetBlobService()
-	containerRef := bs.GetContainerReference(vhdContainer)
-	blobRef := containerRef.GetBlobReference(vhdBlob)
-
-	return blobRef.Delete(&azStorage.DeleteBlobOptions{})
-}
-
-// DeleteVirtualMachine deletes a VM and any associated OS disk
-func (util *AzUtil) DeleteVirtualMachine(rg string, name string) error {
-	ctx, cancel := getContextWithCancel()
-	defer cancel()
-
-	vm, rerr := util.manager.azClient.virtualMachinesClient.Get(ctx, rg, name, "")
-	if rerr != nil {
-		if exists, _ := checkResourceExistsFromRetryError(rerr); !exists {
-			klog.V(2).Infof("VirtualMachine %s/%s has already been removed", rg, name)
-			return nil
-		}
-
-		klog.Errorf("failed to get VM: %s/%s: %s", rg, name, rerr.Error())
-		return rerr.Error()
-	}
-
-	vhd := vm.VirtualMachineProperties.StorageProfile.OsDisk.Vhd
-	managedDisk := vm.VirtualMachineProperties.StorageProfile.OsDisk.ManagedDisk
-	if vhd == nil && managedDisk == nil {
-		klog.Errorf("failed to get a valid os disk URI for VM: %s/%s", rg, name)
-		return fmt.Errorf("os disk does not have a VHD URI")
-	}
-
-	osDiskName := vm.VirtualMachineProperties.StorageProfile.OsDisk.Name
-	var nicName string
-	var err error
-	nicID := (*vm.VirtualMachineProperties.NetworkProfile.NetworkInterfaces)[0].ID
-	if nicID == nil {
-		klog.Warningf("NIC ID is not set for VM (%s/%s)", rg, name)
-	} else {
-		nicName, err = resourceName(*nicID)
-		if err != nil {
-			return err
-		}
-		klog.Infof("found nic name for VM (%s/%s): %s", rg, name, nicName)
-	}
-
-	klog.Infof("deleting VM: %s/%s", rg, name)
-	deleteCtx, deleteCancel := getContextWithCancel()
-	defer deleteCancel()
-
-	klog.Infof("waiting for VirtualMachine deletion: %s/%s", rg, name)
-	rerr = util.manager.azClient.virtualMachinesClient.Delete(deleteCtx, rg, name)
-	_, realErr := checkResourceExistsFromRetryError(rerr)
-	if realErr != nil {
-		return realErr
-	}
-	klog.V(2).Infof("VirtualMachine %s/%s removed", rg, name)
-
-	if len(nicName) > 0 {
-		klog.Infof("deleting nic: %s/%s", rg, nicName)
-		interfaceCtx, interfaceCancel := getContextWithCancel()
-		defer interfaceCancel()
-		klog.Infof("waiting for nic deletion: %s/%s", rg, nicName)
-		nicErr := util.manager.azClient.interfacesClient.Delete(interfaceCtx, rg, nicName)
-		_, realErr := checkResourceExistsFromRetryError(nicErr)
-		if realErr != nil {
-			return realErr
-		}
-		klog.V(2).Infof("interface %s/%s removed", rg, nicName)
-	}
-
-	if vhd != nil {
-		accountName, vhdContainer, vhdBlob, err := splitBlobURI(*vhd.URI)
-		if err != nil {
-			return err
-		}
-
-		klog.Infof("found os disk storage reference: %s %s %s", accountName, vhdContainer, vhdBlob)
-
-		klog.Infof("deleting blob: %s/%s", vhdContainer, vhdBlob)
-		if err = util.DeleteBlob(accountName, vhdContainer, vhdBlob); err != nil {
-			_, realErr := checkResourceExistsFromError(err)
-			if realErr != nil {
-				return realErr
-			}
-			klog.V(2).Infof("Blob %s/%s removed", rg, vhdBlob)
-		}
-	} else if managedDisk != nil {
-		if osDiskName == nil {
-			klog.Warningf("osDisk is not set for VM %s/%s", rg, name)
-		} else {
-			klog.Infof("deleting managed disk: %s/%s", rg, *osDiskName)
-			disksCtx, disksCancel := getContextWithCancel()
-			defer disksCancel()
-			diskErr := util.manager.azClient.disksClient.Delete(disksCtx, rg, *osDiskName)
-			_, realErr := checkResourceExistsFromRetryError(diskErr)
-			if realErr != nil {
-				return realErr
-			}
-			klog.V(2).Infof("disk %s/%s removed", rg, *osDiskName)
-		}
-	}
-
-	return nil
-}
-
-// decodePkcs12 decodes a PKCS#12 client certificate by extracting the public certificate and
-// the private RSA key
-func decodePkcs12(pkcs []byte, password string) (*x509.Certificate, *rsa.PrivateKey, error) {
-	privateKey, certificate, err := pkcs12.Decode(pkcs, password)
-	if err != nil {
-		return nil, nil, fmt.Errorf("decoding the PKCS#12 client certificate: %v", err)
-	}
-	rsaPrivateKey, isRsaKey := privateKey.(*rsa.PrivateKey)
-	if !isRsaKey {
-		return nil, nil, fmt.Errorf("PKCS#12 certificate must contain a RSA private key")
-	}
-
-	return certificate, rsaPrivateKey, nil
-}
-
-func getUserAgentExtension() string {
-	return fmt.Sprintf("cluster-autoscaler/v%s", version.ClusterAutoscalerVersion)
-}
-
-func configureUserAgent(client *autorest.Client) {
-	client.UserAgent = fmt.Sprintf("%s; %s", client.UserAgent, getUserAgentExtension())
-}
-
-// normalizeForK8sVMASScalingUp takes a template and removes elements that are unwanted in a K8s VMAS scale up/down case
-func normalizeForK8sVMASScalingUp(templateMap map[string]interface{}) error {
-	if err := normalizeMasterResourcesForScaling(templateMap); err != nil {
-		return err
-	}
-	rtIndex := -1
-	nsgIndex := -1
-	resources := templateMap[resourcesFieldName].([]interface{})
-	for index, resource := range resources {
-		resourceMap, ok := resource.(map[string]interface{})
-		if !ok {
-			klog.Warning("Template improperly formatted for resource")
-			continue
-		}
-
-		resourceType, ok := resourceMap[typeFieldName].(string)
-		if ok && resourceType == nsgResourceType {
-			if nsgIndex != -1 {
-				err := fmt.Errorf("found 2 resources with type %s in the template. There should only be 1", nsgResourceType)
-				klog.Errorf(err.Error())
-				return err
-			}
-			nsgIndex = index
-		}
-		if ok && resourceType == rtResourceType {
-			if rtIndex != -1 {
-				err := fmt.Errorf("found 2 resources with type %s in the template. There should only be 1", rtResourceType)
-				klog.Warningf(err.Error())
-				return err
-			}
-			rtIndex = index
-		}
-
-		dependencies, ok := resourceMap[dependsOnFieldName].([]interface{})
-		if !ok {
-			continue
-		}
-
-		for dIndex := len(dependencies) - 1; dIndex >= 0; dIndex-- {
-			dependency := dependencies[dIndex].(string)
-			if strings.Contains(dependency, nsgResourceType) || strings.Contains(dependency, nsgID) ||
-				strings.Contains(dependency, rtResourceType) || strings.Contains(dependency, rtID) {
-				dependencies = append(dependencies[:dIndex], dependencies[dIndex+1:]...)
-			}
-		}
-
-		if len(dependencies) > 0 {
-			resourceMap[dependsOnFieldName] = dependencies
-		} else {
-			delete(resourceMap, dependsOnFieldName)
-		}
-	}
-
-	indexesToRemove := []int{}
-	if nsgIndex == -1 {
-		err := fmt.Errorf("found no resources with type %s in the template. There should have been 1", nsgResourceType)
-		klog.Errorf(err.Error())
-		return err
-	}
-	if rtIndex == -1 {
-		klog.Infof("Found no resources with type %s in the template.", rtResourceType)
-	} else {
-		indexesToRemove = append(indexesToRemove, rtIndex)
-	}
-	indexesToRemove = append(indexesToRemove, nsgIndex)
-	templateMap[resourcesFieldName] = removeIndexesFromArray(resources, indexesToRemove)
-
-	return nil
-}
-
-func removeIndexesFromArray(array []interface{}, indexes []int) []interface{} {
-	sort.Sort(sort.Reverse(sort.IntSlice(indexes)))
-	for _, index := range indexes {
-		array = append(array[:index], array[index+1:]...)
-	}
-	return array
-}
-
-// normalizeMasterResourcesForScaling takes a template and removes elements that are unwanted in any scale up/down case
-func normalizeMasterResourcesForScaling(templateMap map[string]interface{}) error {
-	resources := templateMap[resourcesFieldName].([]interface{})
-	indexesToRemove := []int{}
-	//update master nodes resources
-	for index, resource := range resources {
-		resourceMap, ok := resource.(map[string]interface{})
-		if !ok {
-			klog.Warning("Template improperly formatted")
-			continue
-		}
-
-		resourceType, ok := resourceMap[typeFieldName].(string)
-		if !ok || resourceType != vmResourceType {
-			resourceName, ok := resourceMap[nameFieldName].(string)
-			if !ok {
-				klog.Warning("Template improperly formatted")
-				continue
-			}
-			if strings.Contains(resourceName, "variables('masterVMNamePrefix')") && resourceType == vmExtensionType {
-				indexesToRemove = append(indexesToRemove, index)
-			}
-			continue
-		}
-
-		resourceName, ok := resourceMap[nameFieldName].(string)
-		if !ok {
-			klog.Warning("Template improperly formatted")
-			continue
-		}
-
-		// make sure this is only modifying the master vms
-		if !strings.Contains(resourceName, "variables('masterVMNamePrefix')") {
-			continue
-		}
-
-		resourceProperties, ok := resourceMap[propertiesFieldName].(map[string]interface{})
-		if !ok {
-			klog.Warning("Template improperly formatted")
-			continue
-		}
-
-		hardwareProfile, ok := resourceProperties[hardwareProfileFieldName].(map[string]interface{})
-		if !ok {
-			klog.Warning("Template improperly formatted")
-			continue
-		}
-
-		if hardwareProfile[vmSizeFieldName] != nil {
-			delete(hardwareProfile, vmSizeFieldName)
-		}
-
-		if !removeCustomData(resourceProperties) || !removeImageReference(resourceProperties) {
-			continue
-		}
-	}
-	templateMap[resourcesFieldName] = removeIndexesFromArray(resources, indexesToRemove)
-
-	return nil
-}
-
-func removeCustomData(resourceProperties map[string]interface{}) bool {
-	osProfile, ok := resourceProperties[osProfileFieldName].(map[string]interface{})
-	if !ok {
-		klog.Warning("Template improperly formatted")
-		return ok
-	}
-
-	if osProfile[customDataFieldName] != nil {
-		delete(osProfile, customDataFieldName)
-	}
-	return ok
-}
-
-func removeImageReference(resourceProperties map[string]interface{}) bool {
-	storageProfile, ok := resourceProperties[storageProfileFieldName].(map[string]interface{})
-	if !ok {
-		klog.Warningf("Template improperly formatted. Could not find: %s", storageProfileFieldName)
-		return ok
-	}
-
-	if storageProfile[imageReferenceFieldName] != nil {
-		delete(storageProfile, imageReferenceFieldName)
-	}
-	return ok
-}
-
-// resourceName returns the last segment (the resource name) for the specified resource identifier.
-func resourceName(ID string) (string, error) {
-	parts := strings.Split(ID, "/")
-	name := parts[len(parts)-1]
-	if len(name) == 0 {
-		return "", fmt.Errorf("resource name was missing from identifier")
-	}
-
-	return name, nil
-}
-
-// splitBlobURI returns a decomposed blob URI parts: accountName, containerName, blobName.
-func splitBlobURI(URI string) (string, string, string, error) {
-	uri, err := url.Parse(URI)
-	if err != nil {
-		return "", "", "", err
-	}
-
-	accountName := strings.Split(uri.Host, ".")[0]
-	urlParts := strings.Split(uri.Path, "/")
-
-	containerName := urlParts[1]
-	blobPath := strings.Join(urlParts[2:], "/")
-
-	return accountName, containerName, blobPath, nil
-}
-
-// k8sLinuxVMNameParts returns parts of Linux VM name e.g: k8s-agentpool1-11290731-0
-func k8sLinuxVMNameParts(vmName string) (poolIdentifier, nameSuffix string, agentIndex int, err error) {
-	vmNameParts := vmnameLinuxRegexp.FindStringSubmatch(vmName)
-	if len(vmNameParts) != 4 {
-		return "", "", -1, fmt.Errorf("resource name was missing from identifier")
-	}
-
-	vmNum, err := strconv.Atoi(vmNameParts[k8sLinuxVMAgentIndexArrayIndex])
-
-	if err != nil {
-		return "", "", -1, fmt.Errorf("error parsing VM Name: %v", err)
-	}
-
-	return vmNameParts[k8sLinuxVMAgentPoolNameIndex], vmNameParts[k8sLinuxVMAgentClusterIDIndex], vmNum, nil
-}
-
-// windowsVMNameParts returns parts of Windows VM name
-func windowsVMNameParts(vmName string) (poolPrefix string, orch string, poolIndex int, agentIndex int, err error) {
-	var poolInfo string
-	vmNameParts := oldvmnameWindowsRegexp.FindStringSubmatch(vmName)
-	if len(vmNameParts) != 5 {
-		vmNameParts = vmnameWindowsRegexp.FindStringSubmatch(vmName)
-		if len(vmNameParts) != 4 {
-			return "", "", -1, -1, fmt.Errorf("resource name was missing from identifier")
-		}
-		poolInfo = vmNameParts[3]
-	} else {
-		poolInfo = vmNameParts[4]
-	}
-
-	poolPrefix = vmNameParts[1]
-	orch = vmNameParts[2]
-
-	poolIndex, err = strconv.Atoi(poolInfo[:2])
-	if err != nil {
-		return "", "", -1, -1, fmt.Errorf("error parsing VM Name: %v", err)
-	}
-	agentIndex, err = strconv.Atoi(poolInfo[2:])
-	if err != nil {
-		return "", "", -1, -1, fmt.Errorf("error parsing VM Name: %v", err)
-	}
-
-	return poolPrefix, orch, poolIndex, agentIndex, nil
-}
-
-// GetVMNameIndex return the index of VM in the node pools.
-func GetVMNameIndex(osType compute.OperatingSystemTypes, vmName string) (int, error) {
-	var agentIndex int
-	var err error
-	if osType == compute.Linux {
-		_, _, agentIndex, err = k8sLinuxVMNameParts(vmName)
-		if err != nil {
-			return 0, err
-		}
-	} else if osType == compute.Windows {
-		_, _, _, agentIndex, err = windowsVMNameParts(vmName)
-		if err != nil {
-			return 0, err
-		}
-	}
-
-	return agentIndex, nil
-}
-
-// getLastSegment gets the last segment (splitting by '/'.)
-func getLastSegment(ID string) (string, error) {
-	parts := strings.Split(strings.TrimSpace(ID), "/")
-	name := parts[len(parts)-1]
-	if len(name) == 0 {
-		return "", fmt.Errorf("identifier '/' not found in resource name %q", ID)
-	}
-
-	return name, nil
-}
-
-// readDeploymentParameters gets deployment parameters from paramFilePath.
-func readDeploymentParameters(paramFilePath string) (map[string]interface{}, error) {
-	contents, err := ioutil.ReadFile(paramFilePath)
-	if err != nil {
-		klog.Errorf("Failed to read deployment parameters from file %q: %v", paramFilePath, err)
-		return nil, err
-	}
-
-	deploymentParameters := make(map[string]interface{})
-	if err := json.Unmarshal(contents, &deploymentParameters); err != nil {
-		klog.Errorf("Failed to unmarshal deployment parameters from file %q: %v", paramFilePath, err)
-		return nil, err
-	}
-
-	if v, ok := deploymentParameters["parameters"]; ok {
-		return v.(map[string]interface{}), nil
-	}
-
-	return nil, fmt.Errorf("failed to get deployment parameters from file %s", paramFilePath)
-}
-
-func getContextWithCancel() (context.Context, context.CancelFunc) {
-	return context.WithCancel(context.Background())
-}
-
-func getContextWithTimeout(timeout time.Duration) (context.Context, context.CancelFunc) {
-	return context.WithTimeout(context.Background(), timeout)
-}
-
-// checkExistsFromError inspects an error and returns a true if err is nil,
-// false if error is an autorest.Error with StatusCode=404 and will return the
-// error back if error is another status code or another type of error.
-func checkResourceExistsFromError(err error) (bool, error) {
-	if err == nil {
-		return true, nil
-	}
-	v, ok := err.(autorest.DetailedError)
-	if !ok {
-		return false, err
-	}
-	if v.StatusCode == http.StatusNotFound {
-		return false, nil
-	}
-	return false, v
-}
-
-func checkResourceExistsFromRetryError(err *retry.Error) (bool, error) {
-	if err == nil {
-		return true, nil
-	}
-	if err.HTTPStatusCode == http.StatusNotFound {
-		return false, nil
-	}
-	return false, err.Error()
-}
-
-// isSuccessHTTPResponse determines if the response from an HTTP request suggests success
-func isSuccessHTTPResponse(resp *http.Response, err error) (isSuccess bool, realError error) {
-	if err != nil {
-		return false, err
-	}
-
-	if resp != nil {
-		// HTTP 2xx suggests a successful response
-		if 199 < resp.StatusCode && resp.StatusCode < 300 {
-			return true, nil
-		}
-
-		return false, fmt.Errorf("failed with HTTP status code %d", resp.StatusCode)
-	}
-
-	// This shouldn't happen, it only ensures all exceptions are handled.
-	return false, fmt.Errorf("failed with unknown error")
-}
-
-// convertResourceGroupNameToLower converts the resource group name in the resource ID to be lowered.
-func convertResourceGroupNameToLower(resourceID string) (string, error) {
-	matches := azureResourceGroupNameRE.FindStringSubmatch(resourceID)
-	if len(matches) != 2 {
-		return "", fmt.Errorf("%q isn't in Azure resource ID format", resourceID)
-	}
-
-	resourceGroup := matches[1]
-	return strings.Replace(resourceID, resourceGroup, strings.ToLower(resourceGroup), 1), nil
-}
-
-// isAzureRequestsThrottled returns true when the err is http.StatusTooManyRequests (429),
-// and when err shows the requests was not executed due to an ongoing throttling period.
-func isAzureRequestsThrottled(rerr *retry.Error) bool {
-	klog.V(6).Infof("isAzureRequestsThrottled: starts for error %v", rerr)
-	if rerr == nil {
-		return false
-	}
-
-	if rerr.HTTPStatusCode == 0 && rerr.RetryAfter.After(time.Now()) {
-		return true
-	}
-
-	return rerr.HTTPStatusCode == http.StatusTooManyRequests
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/azure_util_test.go b/cluster-autoscaler/cloudprovider/azure/azure_util_test.go
deleted file mode 100644
index 50538ddc2..000000000
--- a/cluster-autoscaler/cloudprovider/azure/azure_util_test.go
+++ /dev/null
@@ -1,539 +0,0 @@
-/*
-Copyright 2017 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package azure
-
-import (
-	"fmt"
-	"net/http"
-	"strings"
-	"testing"
-	"time"
-
-	"github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2019-12-01/compute"
-	"github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2019-06-01/storage"
-	"github.com/Azure/go-autorest/autorest/to"
-	"github.com/golang/mock/gomock"
-	"github.com/stretchr/testify/assert"
-
-	"k8s.io/legacy-cloud-providers/azure/clients/diskclient/mockdiskclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/interfaceclient/mockinterfaceclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient/mockstorageaccountclient"
-	"k8s.io/legacy-cloud-providers/azure/clients/vmclient/mockvmclient"
-	"k8s.io/legacy-cloud-providers/azure/retry"
-)
-
-func GetTestAzureUtil(t *testing.T) *AzUtil {
-	return &AzUtil{manager: newTestAzureManager(t)}
-}
-
-func TestSplitBlobURI(t *testing.T) {
-	expectedAccountName := "vhdstorage8h8pjybi9hbsl6"
-	expectedContainerName := "vhds"
-	expectedBlobPath := "osdisks/disk1234.vhd"
-	accountName, containerName, blobPath, err := splitBlobURI("https://vhdstorage8h8pjybi9hbsl6.blob.core.windows.net/vhds/osdisks/disk1234.vhd")
-	if accountName != expectedAccountName {
-		t.Fatalf("incorrect account name. expected=%s actual=%s", expectedAccountName, accountName)
-	}
-	if containerName != expectedContainerName {
-		t.Fatalf("incorrect account name. expected=%s actual=%s", expectedContainerName, containerName)
-	}
-	if blobPath != expectedBlobPath {
-		t.Fatalf("incorrect account name. expected=%s actual=%s", expectedBlobPath, blobPath)
-	}
-	if err != nil {
-		t.Fatalf("unexpected error: %s", err)
-	}
-}
-
-func TestK8sLinuxVMNameParts(t *testing.T) {
-	data := []struct {
-		poolIdentifier, nameSuffix string
-		agentIndex                 int
-	}{
-		{"agentpool1", "38988164", 10},
-		{"agent-pool1", "38988164", 8},
-		{"agent-pool-1", "38988164", 0},
-	}
-
-	for _, el := range data {
-		vmName := fmt.Sprintf("k8s-%s-%s-%d", el.poolIdentifier, el.nameSuffix, el.agentIndex)
-		poolIdentifier, nameSuffix, agentIndex, err := k8sLinuxVMNameParts(vmName)
-		if poolIdentifier != el.poolIdentifier {
-			t.Fatalf("incorrect poolIdentifier. expected=%s actual=%s", el.poolIdentifier, poolIdentifier)
-		}
-		if nameSuffix != el.nameSuffix {
-			t.Fatalf("incorrect nameSuffix. expected=%s actual=%s", el.nameSuffix, nameSuffix)
-		}
-		if agentIndex != el.agentIndex {
-			t.Fatalf("incorrect agentIndex. expected=%d actual=%d", el.agentIndex, agentIndex)
-		}
-		if err != nil {
-			t.Fatalf("unexpected error: %s", err)
-		}
-	}
-}
-
-func TestWindowsVMNameParts(t *testing.T) {
-	data := []struct {
-		VMName, expectedPoolPrefix, expectedOrch string
-		expectedPoolIndex, expectedAgentIndex    int
-	}{
-		{"38988k8s90312", "38988", "k8s", 3, 12},
-		{"4506k8s010", "4506", "k8s", 1, 0},
-		{"2314k8s03000001", "2314", "k8s", 3, 1},
-		{"2314k8s0310", "2314", "k8s", 3, 10},
-	}
-
-	for _, d := range data {
-		poolPrefix, orch, poolIndex, agentIndex, err := windowsVMNameParts(d.VMName)
-		if poolPrefix != d.expectedPoolPrefix {
-			t.Fatalf("incorrect poolPrefix. expected=%s actual=%s", d.expectedPoolPrefix, poolPrefix)
-		}
-		if orch != d.expectedOrch {
-			t.Fatalf("incorrect aks string. expected=%s actual=%s", d.expectedOrch, orch)
-		}
-		if poolIndex != d.expectedPoolIndex {
-			t.Fatalf("incorrect poolIndex. expected=%d actual=%d", d.expectedPoolIndex, poolIndex)
-		}
-		if agentIndex != d.expectedAgentIndex {
-			t.Fatalf("incorrect agentIndex. expected=%d actual=%d", d.expectedAgentIndex, agentIndex)
-		}
-		if err != nil {
-			t.Fatalf("unexpected error: %s", err)
-		}
-	}
-}
-
-func TestGetVMNameIndexLinux(t *testing.T) {
-	expectedAgentIndex := 65
-
-	agentIndex, err := GetVMNameIndex(compute.Linux, "k8s-agentpool1-38988164-65")
-	if agentIndex != expectedAgentIndex {
-		t.Fatalf("incorrect agentIndex. expected=%d actual=%d", expectedAgentIndex, agentIndex)
-	}
-	if err != nil {
-		t.Fatalf("unexpected error: %s", err)
-	}
-}
-
-func TestGetVMNameIndexWindows(t *testing.T) {
-	expectedAgentIndex := 20
-
-	agentIndex, err := GetVMNameIndex(compute.Windows, "38988k8s90320")
-	if agentIndex != expectedAgentIndex {
-		t.Fatalf("incorrect agentIndex. expected=%d actual=%d", expectedAgentIndex, agentIndex)
-	}
-	if err != nil {
-		t.Fatalf("unexpected error: %s", err)
-	}
-}
-
-func TestIsSuccessResponse(t *testing.T) {
-	tests := []struct {
-		name          string
-		resp          *http.Response
-		err           error
-		expected      bool
-		expectedError error
-	}{
-		{
-			name:          "both resp and err nil should report error",
-			expected:      false,
-			expectedError: fmt.Errorf("failed with unknown error"),
-		},
-		{
-			name: "http.StatusNotFound should report error",
-			resp: &http.Response{
-				StatusCode: http.StatusNotFound,
-			},
-			expected:      false,
-			expectedError: fmt.Errorf("failed with HTTP status code %d", http.StatusNotFound),
-		},
-		{
-			name: "http.StatusInternalServerError should report error",
-			resp: &http.Response{
-				StatusCode: http.StatusInternalServerError,
-			},
-			expected:      false,
-			expectedError: fmt.Errorf("failed with HTTP status code %d", http.StatusInternalServerError),
-		},
-		{
-			name: "http.StatusOK shouldn't report error",
-			resp: &http.Response{
-				StatusCode: http.StatusOK,
-			},
-			expected: true,
-		},
-		{
-			name: "non-nil response error with http.StatusOK should report error",
-			resp: &http.Response{
-				StatusCode: http.StatusOK,
-			},
-			err:           fmt.Errorf("test error"),
-			expected:      false,
-			expectedError: fmt.Errorf("test error"),
-		},
-		{
-			name: "non-nil response error with http.StatusInternalServerError should report error",
-			resp: &http.Response{
-				StatusCode: http.StatusInternalServerError,
-			},
-			err:           fmt.Errorf("test error"),
-			expected:      false,
-			expectedError: fmt.Errorf("test error"),
-		},
-	}
-
-	for _, test := range tests {
-		result, realError := isSuccessHTTPResponse(test.resp, test.err)
-		assert.Equal(t, test.expected, result, "[%s] expected: %v, saw: %v", test.name, result, test.expected)
-		assert.Equal(t, test.expectedError, realError, "[%s] expected: %v, saw: %v", test.name, realError, test.expectedError)
-	}
-}
-func TestConvertResourceGroupNameToLower(t *testing.T) {
-	tests := []struct {
-		desc        string
-		resourceID  string
-		expected    string
-		expectError bool
-	}{
-		{
-			desc:        "empty string should report error",
-			resourceID:  "",
-			expectError: true,
-		},
-		{
-			desc:        "resourceID not in Azure format should report error",
-			resourceID:  "invalid-id",
-			expectError: true,
-		},
-		{
-			desc:        "providerID not in Azure format should report error",
-			resourceID:  "azure://invalid-id",
-			expectError: true,
-		},
-		{
-			desc:       "resource group name in VM providerID should be converted",
-			resourceID: "azure:///subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroupName/providers/Microsoft.Compute/virtualMachines/k8s-agent-AAAAAAAA-0",
-			expected:   "azure:///subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroupname/providers/Microsoft.Compute/virtualMachines/k8s-agent-AAAAAAAA-0",
-		},
-		{
-			desc:       "resource group name in VM resourceID should be converted",
-			resourceID: "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroupName/providers/Microsoft.Compute/virtualMachines/k8s-agent-AAAAAAAA-0",
-			expected:   "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroupname/providers/Microsoft.Compute/virtualMachines/k8s-agent-AAAAAAAA-0",
-		},
-		{
-			desc:       "resource group name in VMSS providerID should be converted",
-			resourceID: "azure:///subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroupName/providers/Microsoft.Compute/virtualMachineScaleSets/myScaleSetName/virtualMachines/156",
-			expected:   "azure:///subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroupname/providers/Microsoft.Compute/virtualMachineScaleSets/myScaleSetName/virtualMachines/156",
-		},
-		{
-			desc:       "resource group name in VMSS resourceID should be converted",
-			resourceID: "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroupName/providers/Microsoft.Compute/virtualMachineScaleSets/myScaleSetName/virtualMachines/156",
-			expected:   "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroupname/providers/Microsoft.Compute/virtualMachineScaleSets/myScaleSetName/virtualMachines/156",
-		},
-	}
-
-	for _, test := range tests {
-		real, err := convertResourceGroupNameToLower(test.resourceID)
-		if test.expectError {
-			assert.NotNil(t, err, test.desc)
-			continue
-		}
-
-		assert.Nil(t, err, test.desc)
-		assert.Equal(t, test.expected, real, test.desc)
-	}
-}
-
-func TestIsAzureRequestsThrottled(t *testing.T) {
-	tests := []struct {
-		desc     string
-		rerr     *retry.Error
-		expected bool
-	}{
-		{
-			desc:     "nil error should return false",
-			expected: false,
-		},
-		{
-			desc: "non http.StatusTooManyRequests error should return false",
-			rerr: &retry.Error{
-				HTTPStatusCode: http.StatusBadRequest,
-			},
-			expected: false,
-		},
-		{
-			desc: "http.StatusTooManyRequests error should return true",
-			rerr: &retry.Error{
-				HTTPStatusCode: http.StatusTooManyRequests,
-			},
-			expected: true,
-		},
-		{
-			desc: "Nul HTTP code and non-expired Retry-After should return true",
-			rerr: &retry.Error{
-				RetryAfter: time.Now().Add(time.Hour),
-			},
-			expected: true,
-		},
-	}
-
-	for _, test := range tests {
-		real := isAzureRequestsThrottled(test.rerr)
-		assert.Equal(t, test.expected, real, test.desc)
-	}
-}
-
-func TestDeleteVirtualMachine(t *testing.T) {
-	ctrl := gomock.NewController(t)
-	defer ctrl.Finish()
-
-	azUtil := GetTestAzureUtil(t)
-	mockVMClient := mockvmclient.NewMockInterface(ctrl)
-	azUtil.manager.azClient.virtualMachinesClient = mockVMClient
-
-	mockVMClient.EXPECT().Get(
-		gomock.Any(),
-		azUtil.manager.config.ResourceGroup,
-		"vm",
-		gomock.Any()).Return(compute.VirtualMachine{}, errInternal)
-
-	err := azUtil.DeleteVirtualMachine("rg", "vm")
-	assert.NoError(t, err)
-
-	mockVMClient.EXPECT().Get(
-		gomock.Any(),
-		azUtil.manager.config.ResourceGroup,
-		"vm",
-		gomock.Any()).Return(compute.VirtualMachine{
-		VirtualMachineProperties: &compute.VirtualMachineProperties{
-			StorageProfile: &compute.StorageProfile{
-				OsDisk: &compute.OSDisk{},
-			},
-		},
-	}, nil)
-	err = azUtil.DeleteVirtualMachine("rg", "vm")
-	expectedErr := fmt.Errorf("os disk does not have a VHD URI")
-	assert.Equal(t, expectedErr, err)
-
-	mockVMClient.EXPECT().Get(
-		gomock.Any(),
-		azUtil.manager.config.ResourceGroup,
-		"vm",
-		gomock.Any()).Return(compute.VirtualMachine{
-		VirtualMachineProperties: &compute.VirtualMachineProperties{
-			StorageProfile: &compute.StorageProfile{
-				OsDisk: &compute.OSDisk{
-					Vhd: &compute.VirtualHardDisk{
-						URI: to.StringPtr("https://vhdstorage8h8pjybi9hbsl6.blob.core.windows.net" +
-							"/vhds/osdisks/disk1234.vhd"),
-					},
-				},
-			},
-			NetworkProfile: &compute.NetworkProfile{
-				NetworkInterfaces: &[]compute.NetworkInterfaceReference{
-					{ID: to.StringPtr("foo/bar")},
-				},
-			},
-		},
-	}, nil)
-	mockVMClient.EXPECT().Delete(
-		gomock.Any(),
-		azUtil.manager.config.ResourceGroup,
-		"vm").Return(nil).Times(2)
-	mockSAClient := mockstorageaccountclient.NewMockInterface(ctrl)
-	mockSAClient.EXPECT().ListKeys(
-		gomock.Any(),
-		azUtil.manager.config.ResourceGroup,
-		"vhdstorage8h8pjybi9hbsl6").Return(storage.AccountListKeysResult{
-		Keys: &[]storage.AccountKey{
-			{Value: to.StringPtr("dmFsdWUK")},
-		},
-	}, nil)
-	azUtil.manager.azClient.storageAccountsClient = mockSAClient
-	mockNICClient := mockinterfaceclient.NewMockInterface(ctrl)
-	mockNICClient.EXPECT().Delete(
-		gomock.Any(),
-		azUtil.manager.config.ResourceGroup,
-		"bar").Return(nil).Times(2)
-	azUtil.manager.azClient.interfacesClient = mockNICClient
-	err = azUtil.DeleteVirtualMachine("rg", "vm")
-	assert.True(t, strings.Contains(err.Error(), "no such host"))
-
-	mockVMClient.EXPECT().Get(
-		gomock.Any(),
-		azUtil.manager.config.ResourceGroup,
-		"vm",
-		gomock.Any()).Return(compute.VirtualMachine{
-		VirtualMachineProperties: &compute.VirtualMachineProperties{
-			StorageProfile: &compute.StorageProfile{
-				OsDisk: &compute.OSDisk{
-					Name:        to.StringPtr("disk"),
-					ManagedDisk: &compute.ManagedDiskParameters{},
-				},
-			},
-			NetworkProfile: &compute.NetworkProfile{
-				NetworkInterfaces: &[]compute.NetworkInterfaceReference{
-					{ID: to.StringPtr("foo/bar")},
-				},
-			},
-		},
-	}, nil)
-	mockDiskClient := mockdiskclient.NewMockInterface(ctrl)
-	mockDiskClient.EXPECT().Delete(
-		gomock.Any(),
-		azUtil.manager.config.ResourceGroup,
-		"disk").Return(nil)
-	azUtil.manager.azClient.disksClient = mockDiskClient
-	err = azUtil.DeleteVirtualMachine("rg", "vm")
-	assert.NoError(t, err)
-}
-
-func TestNormalizeMasterResourcesForScaling(t *testing.T) {
-	templateMap := map[string]interface{}{
-		resourcesFieldName: []interface{}{
-			map[string]interface{}{
-				nameFieldName: "variables('masterVMNamePrefix')",
-				typeFieldName: vmExtensionType,
-			},
-			map[string]interface{}{
-				nameFieldName: 1,
-				typeFieldName: vmResourceType,
-			},
-			map[string]interface{}{
-				nameFieldName: "foo",
-				typeFieldName: vmResourceType,
-			},
-			map[string]interface{}{
-				nameFieldName:       "variables('masterVMNamePrefix')",
-				typeFieldName:       vmResourceType,
-				propertiesFieldName: "foo",
-			},
-			map[string]interface{}{
-				nameFieldName: "variables('masterVMNamePrefix')",
-				typeFieldName: vmResourceType,
-				propertiesFieldName: map[string]interface{}{
-					hardwareProfileFieldName: "foo",
-				},
-			},
-			map[string]interface{}{
-				nameFieldName: "variables('masterVMNamePrefix')",
-				typeFieldName: vmResourceType,
-				propertiesFieldName: map[string]interface{}{
-					hardwareProfileFieldName: map[string]interface{}{
-						vmSizeFieldName: "size",
-					},
-				},
-			},
-			map[string]interface{}{
-				nameFieldName: "variables('masterVMNamePrefix')",
-				typeFieldName: vmResourceType,
-				propertiesFieldName: map[string]interface{}{
-					hardwareProfileFieldName: map[string]interface{}{},
-					osProfileFieldName:       "foo",
-				},
-			},
-			map[string]interface{}{
-				nameFieldName: "variables('masterVMNamePrefix')",
-				typeFieldName: vmResourceType,
-				propertiesFieldName: map[string]interface{}{
-					hardwareProfileFieldName: map[string]interface{}{},
-					osProfileFieldName: map[string]interface{}{
-						customDataFieldName: "data",
-					},
-				},
-			},
-			map[string]interface{}{
-				nameFieldName: "variables('masterVMNamePrefix')",
-				typeFieldName: vmResourceType,
-				propertiesFieldName: map[string]interface{}{
-					hardwareProfileFieldName: map[string]interface{}{},
-					storageProfileFieldName:  "foo",
-				},
-			},
-			map[string]interface{}{
-				nameFieldName: "variables('masterVMNamePrefix')",
-				typeFieldName: vmResourceType,
-				propertiesFieldName: map[string]interface{}{
-					hardwareProfileFieldName: map[string]interface{}{},
-					storageProfileFieldName: map[string]interface{}{
-						imageReferenceFieldName: "image",
-					},
-				},
-			},
-		},
-	}
-	err := normalizeMasterResourcesForScaling(templateMap)
-	assert.Equal(t, 9, len(templateMap[resourcesFieldName].([]interface{})))
-	assert.NoError(t, err)
-}
-
-func TestNormalizeForK8sVMASScalingUp(t *testing.T) {
-	templateMap := map[string]interface{}{
-		resourcesFieldName: []interface{}{
-			map[string]interface{}{
-				typeFieldName: nsgResourceType,
-			},
-			map[string]interface{}{
-				typeFieldName: nsgResourceType,
-			},
-		},
-	}
-	err := normalizeForK8sVMASScalingUp(templateMap)
-	expectedErr := fmt.Errorf("found 2 resources with type %s in the template. "+
-		"There should only be 1", nsgResourceType)
-	assert.Equal(t, expectedErr, err)
-
-	templateMap = map[string]interface{}{
-		resourcesFieldName: []interface{}{
-			map[string]interface{}{
-				typeFieldName: rtResourceType,
-			},
-			map[string]interface{}{
-				typeFieldName: rtResourceType,
-			},
-		},
-	}
-	expectedErr = fmt.Errorf("found 2 resources with type %s in the template. "+
-		"There should only be 1", rtResourceType)
-	err = normalizeForK8sVMASScalingUp(templateMap)
-	assert.Equal(t, expectedErr, err)
-
-	templateMap = map[string]interface{}{
-		resourcesFieldName: []interface{}{
-			map[string]interface{}{
-				typeFieldName: nsgResourceType,
-			},
-			map[string]interface{}{
-				dependsOnFieldName: []interface{}{nsgResourceType, "foo"},
-			},
-		},
-	}
-	err = normalizeForK8sVMASScalingUp(templateMap)
-	for _, resource := range templateMap[resourcesFieldName].([]interface{}) {
-		deps, ok := resource.([]interface{})
-		if ok {
-			for _, dep := range deps {
-				if names, ok := dep.(map[string]interface{})[dependsOnFieldName]; ok {
-					assert.Equal(t, 1, len(names.([]interface{})))
-				}
-			}
-		}
-	}
-	assert.NoError(t, err)
-}
diff --git a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-aks.yaml b/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-aks.yaml
deleted file mode 100644
index 4e1f1f17f..000000000
--- a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-aks.yaml
+++ /dev/null
@@ -1,214 +0,0 @@
----
-apiVersion: v1
-kind: ServiceAccount
-metadata:
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRole
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["events", "endpoints"]
-    verbs: ["create", "patch"]
-  - apiGroups: [""]
-    resources: ["pods/eviction"]
-    verbs: ["create"]
-  - apiGroups: [""]
-    resources: ["pods/status"]
-    verbs: ["update"]
-  - apiGroups: [""]
-    resources: ["endpoints"]
-    resourceNames: ["cluster-autoscaler"]
-    verbs: ["get", "update"]
-  - apiGroups: [""]
-    resources: ["nodes"]
-    verbs: ["watch", "list", "get", "update"]
-  - apiGroups: [""]
-    resources:
-      - "pods"
-      - "services"
-      - "replicationcontrollers"
-      - "persistentvolumeclaims"
-      - "persistentvolumes"
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["extensions"]
-    resources: ["replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["policy"]
-    resources: ["poddisruptionbudgets"]
-    verbs: ["watch", "list"]
-  - apiGroups: ["apps"]
-    resources: ["statefulsets", "replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["storage.k8s.io"]
-    resources: ["storageclasses", "csinodes"]
-    verbs: ["get", "list", "watch"]
-  - apiGroups: ["batch"]
-    resources: ["jobs", "cronjobs"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["coordination.k8s.io"]
-    resources: ["leases"]
-    verbs: ["create"]
-  - apiGroups: ["coordination.k8s.io"]
-    resourceNames: ["cluster-autoscaler"]
-    resources: ["leases"]
-    verbs: ["get", "update"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: Role
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    verbs: ["create","list","watch"]
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    resourceNames:
-      - "cluster-autoscaler-status"
-      - "cluster-autoscaler-priority-expander"
-    verbs: ["delete", "get", "update", "watch"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRoleBinding
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: ClusterRole
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: RoleBinding
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: Role
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: v1
-data:
-  ClientID: <base64-encoded-client-id>
-  ClientSecret: <base64-encoded-client-secret>
-  ResourceGroup: <base64-encoded-resource-group>
-  SubscriptionID: <base64-encode-subscription-id>
-  TenantID: <base64-encoded-tenant-id>
-  VMType: QUtTCg==
-  ClusterName: <base64-encoded-clustername>
-  NodeResourceGroup: <base64-encoded-node-resource-group>
-kind: Secret
-metadata:
-  name: cluster-autoscaler-azure
-  namespace: kube-system
----
-apiVersion: apps/v1
-kind: Deployment
-metadata:
-  labels:
-    app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
-spec:
-  replicas: 1
-  selector:
-    matchLabels:
-      app: cluster-autoscaler
-  template:
-    metadata:
-      labels:
-        app: cluster-autoscaler
-    spec:
-      serviceAccountName: cluster-autoscaler
-      containers:
-        - image: k8s.gcr.io/cluster-autoscaler:{{ ca_version }}
-          imagePullPolicy: Always
-          name: cluster-autoscaler
-          resources:
-            limits:
-              cpu: 100m
-              memory: 300Mi
-            requests:
-              cpu: 100m
-              memory: 300Mi
-          command:
-            - ./cluster-autoscaler
-            - --v=3
-            - --logtostderr=true
-            - --cloud-provider=azure
-            - --skip-nodes-with-local-storage=false
-            - --nodes=3:10:nodepool1
-          env:
-            - name: ARM_SUBSCRIPTION_ID
-              valueFrom:
-                secretKeyRef:
-                  key: SubscriptionID
-                  name: cluster-autoscaler-azure
-            - name: ARM_RESOURCE_GROUP
-              valueFrom:
-                secretKeyRef:
-                  key: ResourceGroup
-                  name: cluster-autoscaler-azure
-            - name: ARM_TENANT_ID
-              valueFrom:
-                secretKeyRef:
-                  key: TenantID
-                  name: cluster-autoscaler-azure
-            - name: ARM_CLIENT_ID
-              valueFrom:
-                secretKeyRef:
-                  key: ClientID
-                  name: cluster-autoscaler-azure
-            - name: ARM_CLIENT_SECRET
-              valueFrom:
-                secretKeyRef:
-                  key: ClientSecret
-                  name: cluster-autoscaler-azure
-            - name: ARM_VM_TYPE
-              valueFrom:
-                secretKeyRef:
-                  key: VMType
-                  name: cluster-autoscaler-azure
-            - name: AZURE_CLUSTER_NAME
-              valueFrom:
-                secretKeyRef:
-                  key: ClusterName
-                  name: cluster-autoscaler-azure
-            - name: AZURE_NODE_RESOURCE_GROUP
-              valueFrom:
-                secretKeyRef:
-                  key: NodeResourceGroup
-                  name: cluster-autoscaler-azure
-      restartPolicy: Always
diff --git a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-autodiscover.yaml b/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-autodiscover.yaml
deleted file mode 100644
index 5a680c238..000000000
--- a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-autodiscover.yaml
+++ /dev/null
@@ -1,225 +0,0 @@
----
-apiVersion: v1
-kind: ServiceAccount
-metadata:
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRole
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["events", "endpoints"]
-    verbs: ["create", "patch"]
-  - apiGroups: [""]
-    resources: ["pods/eviction"]
-    verbs: ["create"]
-  - apiGroups: [""]
-    resources: ["pods/status"]
-    verbs: ["update"]
-  - apiGroups: [""]
-    resources: ["endpoints"]
-    resourceNames: ["cluster-autoscaler"]
-    verbs: ["get", "update"]
-  - apiGroups: [""]
-    resources: ["nodes"]
-    verbs: ["watch", "list", "get", "update"]
-  - apiGroups: [""]
-    resources:
-      - "pods"
-      - "services"
-      - "replicationcontrollers"
-      - "persistentvolumeclaims"
-      - "persistentvolumes"
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["extensions"]
-    resources: ["replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["policy"]
-    resources: ["poddisruptionbudgets"]
-    verbs: ["watch", "list"]
-  - apiGroups: ["apps"]
-    resources: ["statefulsets", "replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["storage.k8s.io"]
-    resources: ["storageclasses", "csinodes"]
-    verbs: ["get", "list", "watch"]
-  - apiGroups: ["batch"]
-    resources: ["jobs", "cronjobs"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["coordination.k8s.io"]
-    resources: ["leases"]
-    verbs: ["create"]
-  - apiGroups: ["coordination.k8s.io"]
-    resourceNames: ["cluster-autoscaler"]
-    resources: ["leases"]
-    verbs: ["get", "update"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: Role
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    verbs: ["create","list","watch"]
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    resourceNames:
-      - "cluster-autoscaler-status"
-      - "cluster-autoscaler-priority-expander"
-    verbs: ["delete", "get", "update", "watch"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRoleBinding
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: ClusterRole
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: RoleBinding
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: Role
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: v1
-data:
-  ResourceGroup: <base64-encoded-resource-group>
-  SubscriptionID: <base64-encode-subscription-id>
-  Deployment: <base64-encoded-azure-initial-deploy-name>
-  VMType: c3RhbmRhcmQ=
-kind: Secret
-metadata:
-  name: cluster-autoscaler-azure
-  namespace: kube-system
----
-apiVersion: apps/v1
-kind: Deployment
-metadata:
-  labels:
-    app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
-spec:
-  replicas: 1
-  selector:
-    matchLabels:
-      app: cluster-autoscaler
-  template:
-    metadata:
-      labels:
-        app: cluster-autoscaler
-    spec:
-      hostNetwork: true
-      serviceAccountName: cluster-autoscaler
-      tolerations:
-        - effect: NoSchedule
-          operator: "Equal"
-          value: "true"
-          key: node-role.kubernetes.io/master
-      nodeSelector:
-        kubernetes.io/role: master
-      containers:
-        - command:
-            - ./cluster-autoscaler
-            - --v=3
-            - --logtostderr=true
-            - --cloud-provider=azure
-            - --skip-nodes-with-local-storage=false
-            - --node-group-auto-discovery=label:cluster-autoscaler-enabled=true,cluster-autoscaler-name=<YOUR CLUSTER NAME>
-          env:
-            - name: ARM_SUBSCRIPTION_ID
-              valueFrom:
-                secretKeyRef:
-                  key: SubscriptionID
-                  name: cluster-autoscaler-azure
-            - name: ARM_RESOURCE_GROUP
-              valueFrom:
-                secretKeyRef:
-                  key: ResourceGroup
-                  name: cluster-autoscaler-azure
-            - name: ARM_USE_MANAGED_IDENTITY_EXTENSION
-              value: "true"
-            - name: ARM_VM_TYPE
-              valueFrom:
-                secretKeyRef:
-                  key: VMType
-                  name: cluster-autoscaler-azure
-            - name: ARM_DEPLOYMENT
-              valueFrom:
-                secretKeyRef:
-                  key: Deployment
-                  name: cluster-autoscaler-azure
-          image: k8s.gcr.io/cluster-autoscaler:{{ ca_version }}
-          imagePullPolicy: Always
-          name: cluster-autoscaler
-          resources:
-            limits:
-              cpu: 100m
-              memory: 300Mi
-            requests:
-              cpu: 100m
-              memory: 300Mi
-          volumeMounts:
-            - mountPath: /etc/ssl/certs/ca-certificates.crt
-              name: ssl-certs
-              readOnly: true
-            - mountPath: /var/lib/azure/
-              name: deploy-parameters
-              readOnly: true
-            - mountPath: /var/lib/waagent/
-              name: waagent
-              readOnly: true
-      dnsPolicy: ClusterFirst
-      restartPolicy: Always
-      volumes:
-        - hostPath:
-            path: /etc/ssl/certs/ca-certificates.crt
-            type: ""
-          name: ssl-certs
-        - name: deploy-parameters
-          secret:
-            secretName: cluster-autoscaler-azure-deploy-parameters
-            items:
-              - key: deploy-parameters
-                path: azuredeploy.parameters.json
-        - hostPath:
-            path: /var/lib/waagent/
-          name: waagent
diff --git a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-standard-control-plane.yaml b/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-standard-control-plane.yaml
deleted file mode 100644
index f7738f1fd..000000000
--- a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-standard-control-plane.yaml
+++ /dev/null
@@ -1,235 +0,0 @@
----
-apiVersion: v1
-kind: ServiceAccount
-metadata:
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRole
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["events", "endpoints"]
-    verbs: ["create", "patch"]
-  - apiGroups: [""]
-    resources: ["pods/eviction"]
-    verbs: ["create"]
-  - apiGroups: [""]
-    resources: ["pods/status"]
-    verbs: ["update"]
-  - apiGroups: [""]
-    resources: ["endpoints"]
-    resourceNames: ["cluster-autoscaler"]
-    verbs: ["get", "update"]
-  - apiGroups: [""]
-    resources: ["nodes"]
-    verbs: ["watch", "list", "get", "update"]
-  - apiGroups: [""]
-    resources:
-      - "pods"
-      - "services"
-      - "replicationcontrollers"
-      - "persistentvolumeclaims"
-      - "persistentvolumes"
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["extensions"]
-    resources: ["replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["policy"]
-    resources: ["poddisruptionbudgets"]
-    verbs: ["watch", "list"]
-  - apiGroups: ["apps"]
-    resources: ["statefulsets", "replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["storage.k8s.io"]
-    resources: ["storageclasses", "csinodes"]
-    verbs: ["get", "list", "watch"]
-  - apiGroups: ["batch"]
-    resources: ["jobs", "cronjobs"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["coordination.k8s.io"]
-    resources: ["leases"]
-    verbs: ["create"]
-  - apiGroups: ["coordination.k8s.io"]
-    resourceNames: ["cluster-autoscaler"]
-    resources: ["leases"]
-    verbs: ["get", "update"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: Role
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    verbs: ["create","list","watch"]
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    resourceNames:
-      - "cluster-autoscaler-status"
-      - "cluster-autoscaler-priority-expander"
-    verbs: ["delete", "get", "update", "watch"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRoleBinding
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: ClusterRole
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: RoleBinding
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: Role
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: v1
-data:
-  ClientID: <base64-encoded-client-id>
-  ClientSecret: <base64-encoded-client-secret>
-  ResourceGroup: <base64-encoded-resource-group>
-  SubscriptionID: <base64-encoded-subscription-id>
-  TenantID: <base64-encoded-tenant-id>
-  Deployment: <base64-encoded-azure-initial-deploy-name>
-  VMType: c3RhbmRhcmQ=
-kind: Secret
-metadata:
-  name: cluster-autoscaler-azure
-  namespace: kube-system
----
-apiVersion: apps/v1
-kind: Deployment
-metadata:
-  labels:
-    app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
-spec:
-  replicas: 1
-  selector:
-    matchLabels:
-      app: cluster-autoscaler
-  template:
-    metadata:
-      labels:
-        app: cluster-autoscaler
-    spec:
-      serviceAccountName: cluster-autoscaler
-      tolerations:
-        - effect: NoSchedule
-          operator: "Equal"
-          value: "true"
-          key: node-role.kubernetes.io/master
-      nodeSelector:
-        kubernetes.io/role: master
-      containers:
-        - command:
-            - ./cluster-autoscaler
-            - --v=3
-            - --logtostderr=true
-            - --cloud-provider=azure
-            - --skip-nodes-with-local-storage=false
-            - --nodes=1:10:agentpool1
-            - --nodes=1:10:agentpool2
-          env:
-            - name: ARM_SUBSCRIPTION_ID
-              valueFrom:
-                secretKeyRef:
-                  key: SubscriptionID
-                  name: cluster-autoscaler-azure
-            - name: ARM_RESOURCE_GROUP
-              valueFrom:
-                secretKeyRef:
-                  key: ResourceGroup
-                  name: cluster-autoscaler-azure
-            - name: ARM_TENANT_ID
-              valueFrom:
-                secretKeyRef:
-                  key: TenantID
-                  name: cluster-autoscaler-azure
-            - name: ARM_CLIENT_ID
-              valueFrom:
-                secretKeyRef:
-                  key: ClientID
-                  name: cluster-autoscaler-azure
-            - name: ARM_CLIENT_SECRET
-              valueFrom:
-                secretKeyRef:
-                  key: ClientSecret
-                  name: cluster-autoscaler-azure
-            - name: ARM_VM_TYPE
-              valueFrom:
-                secretKeyRef:
-                  key: VMType
-                  name: cluster-autoscaler-azure
-            - name: ARM_DEPLOYMENT
-              valueFrom:
-                secretKeyRef:
-                  key: Deployment
-                  name: cluster-autoscaler-azure
-          image: k8s.gcr.io/cluster-autoscaler:{{ ca_version }}
-          imagePullPolicy: Always
-          name: cluster-autoscaler
-          resources:
-            limits:
-              cpu: 100m
-              memory: 300Mi
-            requests:
-              cpu: 100m
-              memory: 300Mi
-          volumeMounts:
-            - mountPath: /etc/ssl/certs/ca-certificates.crt
-              name: ssl-certs
-              readOnly: true
-            - mountPath: /var/lib/azure/
-              name: deploy-parameters
-              readOnly: true
-      dnsPolicy: ClusterFirst
-      restartPolicy: Always
-      volumes:
-        - hostPath:
-            path: /etc/ssl/certs/ca-certificates.crt
-            type: ""
-          name: ssl-certs
-        - name: deploy-parameters
-          secret:
-            secretName: cluster-autoscaler-azure-deploy-parameters
-            items:
-              - key: deploy-parameters
-                path: azuredeploy.parameters.json
diff --git a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-standard-msi.yaml b/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-standard-msi.yaml
deleted file mode 100644
index 2dedce4dc..000000000
--- a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-standard-msi.yaml
+++ /dev/null
@@ -1,226 +0,0 @@
----
-apiVersion: v1
-kind: ServiceAccount
-metadata:
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRole
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["events", "endpoints"]
-    verbs: ["create", "patch"]
-  - apiGroups: [""]
-    resources: ["pods/eviction"]
-    verbs: ["create"]
-  - apiGroups: [""]
-    resources: ["pods/status"]
-    verbs: ["update"]
-  - apiGroups: [""]
-    resources: ["endpoints"]
-    resourceNames: ["cluster-autoscaler"]
-    verbs: ["get", "update"]
-  - apiGroups: [""]
-    resources: ["nodes"]
-    verbs: ["watch", "list", "get", "update"]
-  - apiGroups: [""]
-    resources:
-      - "pods"
-      - "services"
-      - "replicationcontrollers"
-      - "persistentvolumeclaims"
-      - "persistentvolumes"
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["extensions"]
-    resources: ["replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["policy"]
-    resources: ["poddisruptionbudgets"]
-    verbs: ["watch", "list"]
-  - apiGroups: ["apps"]
-    resources: ["statefulsets", "replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["storage.k8s.io"]
-    resources: ["storageclasses", "csinodes"]
-    verbs: ["get", "list", "watch"]
-  - apiGroups: ["batch"]
-    resources: ["jobs", "cronjobs"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["coordination.k8s.io"]
-    resources: ["leases"]
-    verbs: ["create"]
-  - apiGroups: ["coordination.k8s.io"]
-    resourceNames: ["cluster-autoscaler"]
-    resources: ["leases"]
-    verbs: ["get", "update"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: Role
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    verbs: ["create","list","watch"]
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    resourceNames:
-      - "cluster-autoscaler-status"
-      - "cluster-autoscaler-priority-expander"
-    verbs: ["delete", "get", "update", "watch"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRoleBinding
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: ClusterRole
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: RoleBinding
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: Role
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: v1
-data:
-  ResourceGroup: <base64-encoded-resource-group>
-  SubscriptionID: <base64-encode-subscription-id>
-  Deployment: <base64-encoded-azure-initial-deploy-name>
-  VMType: c3RhbmRhcmQ=
-kind: Secret
-metadata:
-  name: cluster-autoscaler-azure
-  namespace: kube-system
----
-apiVersion: apps/v1
-kind: Deployment
-metadata:
-  labels:
-    app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
-spec:
-  replicas: 1
-  selector:
-    matchLabels:
-      app: cluster-autoscaler
-  template:
-    metadata:
-      labels:
-        app: cluster-autoscaler
-    spec:
-      hostNetwork: true
-      serviceAccountName: cluster-autoscaler
-      tolerations:
-        - effect: NoSchedule
-          operator: "Equal"
-          value: "true"
-          key: node-role.kubernetes.io/master
-      nodeSelector:
-        kubernetes.io/role: master
-      containers:
-        - command:
-            - ./cluster-autoscaler
-            - --v=3
-            - --logtostderr=true
-            - --cloud-provider=azure
-            - --skip-nodes-with-local-storage=false
-            - --nodes=1:10:agentpool1
-            - --nodes=1:10:agentpool2
-          env:
-            - name: ARM_SUBSCRIPTION_ID
-              valueFrom:
-                secretKeyRef:
-                  key: SubscriptionID
-                  name: cluster-autoscaler-azure
-            - name: ARM_RESOURCE_GROUP
-              valueFrom:
-                secretKeyRef:
-                  key: ResourceGroup
-                  name: cluster-autoscaler-azure
-            - name: ARM_USE_MANAGED_IDENTITY_EXTENSION
-              value: "true"
-            - name: ARM_VM_TYPE
-              valueFrom:
-                secretKeyRef:
-                  key: VMType
-                  name: cluster-autoscaler-azure
-            - name: ARM_DEPLOYMENT
-              valueFrom:
-                secretKeyRef:
-                  key: Deployment
-                  name: cluster-autoscaler-azure
-          image: k8s.gcr.io/cluster-autoscaler:{{ ca_version }}
-          imagePullPolicy: Always
-          name: cluster-autoscaler
-          resources:
-            limits:
-              cpu: 100m
-              memory: 300Mi
-            requests:
-              cpu: 100m
-              memory: 300Mi
-          volumeMounts:
-            - mountPath: /etc/ssl/certs/ca-certificates.crt
-              name: ssl-certs
-              readOnly: true
-            - mountPath: /var/lib/azure/
-              name: deploy-parameters
-              readOnly: true
-            - mountPath: /var/lib/waagent/
-              name: waagent
-              readOnly: true
-      dnsPolicy: ClusterFirst
-      restartPolicy: Always
-      volumes:
-        - hostPath:
-            path: /etc/ssl/certs/ca-certificates.crt
-            type: ""
-          name: ssl-certs
-        - name: deploy-parameters
-          secret:
-            secretName: cluster-autoscaler-azure-deploy-parameters
-            items:
-              - key: deploy-parameters
-                path: azuredeploy.parameters.json
-        - hostPath:
-            path: /var/lib/waagent/
-          name: waagent
diff --git a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-standard.yaml b/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-standard.yaml
deleted file mode 100644
index b7efff22c..000000000
--- a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-standard.yaml
+++ /dev/null
@@ -1,228 +0,0 @@
----
-apiVersion: v1
-kind: ServiceAccount
-metadata:
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRole
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["events", "endpoints"]
-    verbs: ["create", "patch"]
-  - apiGroups: [""]
-    resources: ["pods/eviction"]
-    verbs: ["create"]
-  - apiGroups: [""]
-    resources: ["pods/status"]
-    verbs: ["update"]
-  - apiGroups: [""]
-    resources: ["endpoints"]
-    resourceNames: ["cluster-autoscaler"]
-    verbs: ["get", "update"]
-  - apiGroups: [""]
-    resources: ["nodes"]
-    verbs: ["watch", "list", "get", "update"]
-  - apiGroups: [""]
-    resources:
-      - "pods"
-      - "services"
-      - "replicationcontrollers"
-      - "persistentvolumeclaims"
-      - "persistentvolumes"
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["extensions"]
-    resources: ["replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["policy"]
-    resources: ["poddisruptionbudgets"]
-    verbs: ["watch", "list"]
-  - apiGroups: ["apps"]
-    resources: ["statefulsets", "replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["storage.k8s.io"]
-    resources: ["storageclasses", "csinodes"]
-    verbs: ["get", "list", "watch"]
-  - apiGroups: ["batch"]
-    resources: ["jobs", "cronjobs"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["coordination.k8s.io"]
-    resources: ["leases"]
-    verbs: ["create"]
-  - apiGroups: ["coordination.k8s.io"]
-    resourceNames: ["cluster-autoscaler"]
-    resources: ["leases"]
-    verbs: ["get", "update"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: Role
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    verbs: ["create","list","watch"]
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    resourceNames:
-      - "cluster-autoscaler-status"
-      - "cluster-autoscaler-priority-expander"
-    verbs: ["delete", "get", "update", "watch"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRoleBinding
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: ClusterRole
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: RoleBinding
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: Role
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: v1
-data:
-  ClientID: <base64-encoded-client-id>
-  ClientSecret: <base64-encoded-client-secret>
-  ResourceGroup: <base64-encoded-resource-group>
-  SubscriptionID: <base64-encode-subscription-id>
-  TenantID: <base64-encoded-tenant-id>
-  Deployment: <base64-encoded-azure-initial-deploy-name>
-  VMType: c3RhbmRhcmQ=
-kind: Secret
-metadata:
-  name: cluster-autoscaler-azure
-  namespace: kube-system
----
-apiVersion: apps/v1
-kind: Deployment
-metadata:
-  labels:
-    app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
-spec:
-  replicas: 1
-  selector:
-    matchLabels:
-      app: cluster-autoscaler
-  template:
-    metadata:
-      labels:
-        app: cluster-autoscaler
-    spec:
-      serviceAccountName: cluster-autoscaler
-      containers:
-        - command:
-            - ./cluster-autoscaler
-            - --v=3
-            - --logtostderr=true
-            - --cloud-provider=azure
-            - --skip-nodes-with-local-storage=false
-            - --nodes=1:10:agentpool1
-            - --nodes=1:10:agentpool2
-          env:
-            - name: ARM_SUBSCRIPTION_ID
-              valueFrom:
-                secretKeyRef:
-                  key: SubscriptionID
-                  name: cluster-autoscaler-azure
-            - name: ARM_RESOURCE_GROUP
-              valueFrom:
-                secretKeyRef:
-                  key: ResourceGroup
-                  name: cluster-autoscaler-azure
-            - name: ARM_TENANT_ID
-              valueFrom:
-                secretKeyRef:
-                  key: TenantID
-                  name: cluster-autoscaler-azure
-            - name: ARM_CLIENT_ID
-              valueFrom:
-                secretKeyRef:
-                  key: ClientID
-                  name: cluster-autoscaler-azure
-            - name: ARM_CLIENT_SECRET
-              valueFrom:
-                secretKeyRef:
-                  key: ClientSecret
-                  name: cluster-autoscaler-azure
-            - name: ARM_VM_TYPE
-              valueFrom:
-                secretKeyRef:
-                  key: VMType
-                  name: cluster-autoscaler-azure
-            - name: ARM_DEPLOYMENT
-              valueFrom:
-                secretKeyRef:
-                  key: Deployment
-                  name: cluster-autoscaler-azure
-          image: k8s.gcr.io/cluster-autoscaler:{{ ca_version }}
-          imagePullPolicy: Always
-          name: cluster-autoscaler
-          resources:
-            limits:
-              cpu: 100m
-              memory: 300Mi
-            requests:
-              cpu: 100m
-              memory: 300Mi
-          volumeMounts:
-            - mountPath: /etc/ssl/certs/ca-certificates.crt
-              name: ssl-certs
-              readOnly: true
-            - mountPath: /var/lib/azure/
-              name: deploy-parameters
-              readOnly: true
-      dnsPolicy: ClusterFirst
-      restartPolicy: Always
-      volumes:
-        - hostPath:
-            path: /etc/ssl/certs/ca-certificates.crt
-            type: ""
-          name: ssl-certs
-        - name: deploy-parameters
-          secret:
-            secretName: cluster-autoscaler-azure-deploy-parameters
-            items:
-              - key: deploy-parameters
-                path: azuredeploy.parameters.json
diff --git a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-vmss-control-plane.yaml b/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-vmss-control-plane.yaml
deleted file mode 100644
index 0a343395a..000000000
--- a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-vmss-control-plane.yaml
+++ /dev/null
@@ -1,219 +0,0 @@
----
-apiVersion: v1
-kind: ServiceAccount
-metadata:
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRole
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["events", "endpoints"]
-    verbs: ["create", "patch"]
-  - apiGroups: [""]
-    resources: ["pods/eviction"]
-    verbs: ["create"]
-  - apiGroups: [""]
-    resources: ["pods/status"]
-    verbs: ["update"]
-  - apiGroups: [""]
-    resources: ["endpoints"]
-    resourceNames: ["cluster-autoscaler"]
-    verbs: ["get", "update"]
-  - apiGroups: [""]
-    resources: ["nodes"]
-    verbs: ["watch", "list", "get", "update"]
-  - apiGroups: [""]
-    resources:
-      - "pods"
-      - "services"
-      - "replicationcontrollers"
-      - "persistentvolumeclaims"
-      - "persistentvolumes"
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["extensions"]
-    resources: ["replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["policy"]
-    resources: ["poddisruptionbudgets"]
-    verbs: ["watch", "list"]
-  - apiGroups: ["apps"]
-    resources: ["statefulsets", "replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["storage.k8s.io"]
-    resources: ["storageclasses", "csinodes"]
-    verbs: ["get", "list", "watch"]
-  - apiGroups: ["batch"]
-    resources: ["jobs", "cronjobs"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["coordination.k8s.io"]
-    resources: ["leases"]
-    verbs: ["create"]
-  - apiGroups: ["coordination.k8s.io"]
-    resourceNames: ["cluster-autoscaler"]
-    resources: ["leases"]
-    verbs: ["get", "update"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: Role
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    verbs: ["create","list","watch"]
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    resourceNames:
-      - "cluster-autoscaler-status"
-      - "cluster-autoscaler-priority-expander"
-    verbs: ["delete", "get", "update", "watch"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRoleBinding
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: ClusterRole
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: RoleBinding
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: Role
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: v1
-data:
-  ClientID: <base64-encoded-client-id>
-  ClientSecret: <base64-encoded-client-secret>
-  ResourceGroup: <base64-encoded-resource-group>
-  SubscriptionID: <base64-encode-subscription-id>
-  TenantID: <base64-encoded-tenant-id>
-  VMType: dm1zcw==
-kind: Secret
-metadata:
-  name: cluster-autoscaler-azure
-  namespace: kube-system
----
-apiVersion: apps/v1
-kind: Deployment
-metadata:
-  labels:
-    app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
-spec:
-  replicas: 1
-  selector:
-    matchLabels:
-      app: cluster-autoscaler
-  template:
-    metadata:
-      labels:
-        app: cluster-autoscaler
-    spec:
-      serviceAccountName: cluster-autoscaler
-      tolerations:
-        - effect: NoSchedule
-          operator: "Equal"
-          value: "true"
-          key: node-role.kubernetes.io/master
-      nodeSelector:
-        kubernetes.io/role: master
-      containers:
-        - image: k8s.gcr.io/cluster-autoscaler:{{ ca_version }}
-          imagePullPolicy: Always
-          name: cluster-autoscaler
-          command:
-            - ./cluster-autoscaler
-            - --v=3
-            - --logtostderr=true
-            - --cloud-provider=azure
-            - --skip-nodes-with-local-storage=false
-            - --nodes=1:10:vmss1
-            - --nodes=1:10:vmss2
-          env:
-            - name: ARM_SUBSCRIPTION_ID
-              valueFrom:
-                secretKeyRef:
-                  key: SubscriptionID
-                  name: cluster-autoscaler-azure
-            - name: ARM_RESOURCE_GROUP
-              valueFrom:
-                secretKeyRef:
-                  key: ResourceGroup
-                  name: cluster-autoscaler-azure
-            - name: ARM_TENANT_ID
-              valueFrom:
-                secretKeyRef:
-                  key: TenantID
-                  name: cluster-autoscaler-azure
-            - name: ARM_CLIENT_ID
-              valueFrom:
-                secretKeyRef:
-                  key: ClientID
-                  name: cluster-autoscaler-azure
-            - name: ARM_CLIENT_SECRET
-              valueFrom:
-                secretKeyRef:
-                  key: ClientSecret
-                  name: cluster-autoscaler-azure
-            - name: ARM_VM_TYPE
-              valueFrom:
-                secretKeyRef:
-                  key: VMType
-                  name: cluster-autoscaler-azure
-          resources:
-            limits:
-              cpu: 100m
-              memory: 300Mi
-            requests:
-              cpu: 100m
-              memory: 300Mi
-          volumeMounts:
-            - mountPath: /etc/ssl/certs/ca-certificates.crt
-              name: ssl-certs
-              readOnly: true
-      restartPolicy: Always
-      volumes:
-        - hostPath:
-            path: /etc/ssl/certs/ca-certificates.crt
-            type: ""
-          name: ssl-certs
diff --git a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-vmss-msi.yaml b/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-vmss-msi.yaml
deleted file mode 100644
index bba365627..000000000
--- a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-vmss-msi.yaml
+++ /dev/null
@@ -1,210 +0,0 @@
----
-apiVersion: v1
-kind: ServiceAccount
-metadata:
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRole
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["events", "endpoints"]
-    verbs: ["create", "patch"]
-  - apiGroups: [""]
-    resources: ["pods/eviction"]
-    verbs: ["create"]
-  - apiGroups: [""]
-    resources: ["pods/status"]
-    verbs: ["update"]
-  - apiGroups: [""]
-    resources: ["endpoints"]
-    resourceNames: ["cluster-autoscaler"]
-    verbs: ["get", "update"]
-  - apiGroups: [""]
-    resources: ["nodes"]
-    verbs: ["watch", "list", "get", "update"]
-  - apiGroups: [""]
-    resources:
-      - "pods"
-      - "services"
-      - "replicationcontrollers"
-      - "persistentvolumeclaims"
-      - "persistentvolumes"
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["extensions"]
-    resources: ["replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["policy"]
-    resources: ["poddisruptionbudgets"]
-    verbs: ["watch", "list"]
-  - apiGroups: ["apps"]
-    resources: ["statefulsets", "replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["storage.k8s.io"]
-    resources: ["storageclasses", "csinodes"]
-    verbs: ["get", "list", "watch"]
-  - apiGroups: ["batch"]
-    resources: ["jobs", "cronjobs"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["coordination.k8s.io"]
-    resources: ["leases"]
-    verbs: ["create"]
-  - apiGroups: ["coordination.k8s.io"]
-    resourceNames: ["cluster-autoscaler"]
-    resources: ["leases"]
-    verbs: ["get", "update"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: Role
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    verbs: ["create","list","watch"]
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    resourceNames:
-      - "cluster-autoscaler-status"
-      - "cluster-autoscaler-priority-expander"
-    verbs: ["delete", "get", "update", "watch"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRoleBinding
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: ClusterRole
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: RoleBinding
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: Role
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: v1
-data:
-  ResourceGroup: <base64-encoded-resource-group>
-  SubscriptionID: <base64-encode-subscription-id>
-  VMType: dm1zcw==
-kind: Secret
-metadata:
-  name: cluster-autoscaler-azure
-  namespace: kube-system
----
-apiVersion: apps/v1
-kind: Deployment
-metadata:
-  labels:
-    app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
-spec:
-  replicas: 1
-  selector:
-    matchLabels:
-      app: cluster-autoscaler
-  template:
-    metadata:
-      labels:
-        app: cluster-autoscaler
-    spec:
-      hostNetwork: true
-      serviceAccountName: cluster-autoscaler
-      tolerations:
-        - effect: NoSchedule
-          operator: "Equal"
-          value: "true"
-          key: node-role.kubernetes.io/master
-      nodeSelector:
-        kubernetes.io/role: master
-      containers:
-        - image: k8s.gcr.io/cluster-autoscaler:{{ ca_version }}
-          imagePullPolicy: Always
-          name: cluster-autoscaler
-          command:
-            - ./cluster-autoscaler
-            - --v=3
-            - --logtostderr=true
-            - --cloud-provider=azure
-            - --skip-nodes-with-local-storage=false
-            - --nodes=1:10:vmss1
-            - --nodes=1:10:vmss2
-          env:
-            - name: ARM_SUBSCRIPTION_ID
-              valueFrom:
-                secretKeyRef:
-                  key: SubscriptionID
-                  name: cluster-autoscaler-azure
-            - name: ARM_RESOURCE_GROUP
-              valueFrom:
-                secretKeyRef:
-                  key: ResourceGroup
-                  name: cluster-autoscaler-azure
-            - name: ARM_USE_MANAGED_IDENTITY_EXTENSION
-              value: "true"
-            - name: ARM_VM_TYPE
-              valueFrom:
-                secretKeyRef:
-                  key: VMType
-                  name: cluster-autoscaler-azure
-          resources:
-            limits:
-              cpu: 100m
-              memory: 300Mi
-            requests:
-              cpu: 100m
-              memory: 300Mi
-          volumeMounts:
-            - mountPath: /etc/ssl/certs/ca-certificates.crt
-              name: ssl-certs
-              readOnly: true
-            - mountPath: /var/lib/waagent/
-              name: waagent
-              readOnly: true
-      restartPolicy: Always
-      volumes:
-        - hostPath:
-            path: /etc/ssl/certs/ca-certificates.crt
-            type: ""
-          name: ssl-certs
-        - hostPath:
-            path: /var/lib/waagent/
-          name: waagent
diff --git a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-vmss.yaml b/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-vmss.yaml
deleted file mode 100644
index 5a45508c9..000000000
--- a/cluster-autoscaler/cloudprovider/azure/examples/cluster-autoscaler-vmss.yaml
+++ /dev/null
@@ -1,212 +0,0 @@
----
-apiVersion: v1
-kind: ServiceAccount
-metadata:
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRole
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["events", "endpoints"]
-    verbs: ["create", "patch"]
-  - apiGroups: [""]
-    resources: ["pods/eviction"]
-    verbs: ["create"]
-  - apiGroups: [""]
-    resources: ["pods/status"]
-    verbs: ["update"]
-  - apiGroups: [""]
-    resources: ["endpoints"]
-    resourceNames: ["cluster-autoscaler"]
-    verbs: ["get", "update"]
-  - apiGroups: [""]
-    resources: ["nodes"]
-    verbs: ["watch", "list", "get", "update"]
-  - apiGroups: [""]
-    resources:
-      - "pods"
-      - "services"
-      - "replicationcontrollers"
-      - "persistentvolumeclaims"
-      - "persistentvolumes"
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["extensions"]
-    resources: ["replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["policy"]
-    resources: ["poddisruptionbudgets"]
-    verbs: ["watch", "list"]
-  - apiGroups: ["apps"]
-    resources: ["statefulsets", "replicasets", "daemonsets"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["storage.k8s.io"]
-    resources: ["storageclasses", "csinodes"]
-    verbs: ["get", "list", "watch"]
-  - apiGroups: ["batch"]
-    resources: ["jobs", "cronjobs"]
-    verbs: ["watch", "list", "get"]
-  - apiGroups: ["coordination.k8s.io"]
-    resources: ["leases"]
-    verbs: ["create"]
-  - apiGroups: ["coordination.k8s.io"]
-    resourceNames: ["cluster-autoscaler"]
-    resources: ["leases"]
-    verbs: ["get", "update"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: Role
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-rules:
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    verbs: ["create","list","watch"]
-  - apiGroups: [""]
-    resources: ["configmaps"]
-    resourceNames:
-      - "cluster-autoscaler-status"
-      - "cluster-autoscaler-priority-expander"
-    verbs: ["delete", "get", "update", "watch"]
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: ClusterRoleBinding
-metadata:
-  name: cluster-autoscaler
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: ClusterRole
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: rbac.authorization.k8s.io/v1
-kind: RoleBinding
-metadata:
-  name: cluster-autoscaler
-  namespace: kube-system
-  labels:
-    k8s-addon: cluster-autoscaler.addons.k8s.io
-    k8s-app: cluster-autoscaler
-roleRef:
-  apiGroup: rbac.authorization.k8s.io
-  kind: Role
-  name: cluster-autoscaler
-subjects:
-  - kind: ServiceAccount
-    name: cluster-autoscaler
-    namespace: kube-system
-
----
-apiVersion: v1
-data:
-  ClientID: <base64-encoded-client-id>
-  ClientSecret: <base64-encoded-client-secret>
-  ResourceGroup: <base64-encoded-resource-group>
-  SubscriptionID: <base64-encode-subscription-id>
-  TenantID: <base64-encoded-tenant-id>
-  VMType: dm1zcw==
-kind: Secret
-metadata:
-  name: cluster-autoscaler-azure
-  namespace: kube-system
----
-apiVersion: apps/v1
-kind: Deployment
-metadata:
-  labels:
-    app: cluster-autoscaler
-  name: cluster-autoscaler
-  namespace: kube-system
-spec:
-  replicas: 1
-  selector:
-    matchLabels:
-      app: cluster-autoscaler
-  template:
-    metadata:
-      labels:
-        app: cluster-autoscaler
-    spec:
-      serviceAccountName: cluster-autoscaler
-      containers:
-        - image: k8s.gcr.io/cluster-autoscaler:{{ ca_version }}
-          imagePullPolicy: Always
-          name: cluster-autoscaler
-          resources:
-            limits:
-              cpu: 100m
-              memory: 300Mi
-            requests:
-              cpu: 100m
-              memory: 300Mi
-          command:
-            - ./cluster-autoscaler
-            - --v=3
-            - --logtostderr=true
-            - --cloud-provider=azure
-            - --skip-nodes-with-local-storage=false
-            - --nodes=1:10:vmss1
-            - --nodes=1:10:vmss2
-          env:
-            - name: ARM_SUBSCRIPTION_ID
-              valueFrom:
-                secretKeyRef:
-                  key: SubscriptionID
-                  name: cluster-autoscaler-azure
-            - name: ARM_RESOURCE_GROUP
-              valueFrom:
-                secretKeyRef:
-                  key: ResourceGroup
-                  name: cluster-autoscaler-azure
-            - name: ARM_TENANT_ID
-              valueFrom:
-                secretKeyRef:
-                  key: TenantID
-                  name: cluster-autoscaler-azure
-            - name: ARM_CLIENT_ID
-              valueFrom:
-                secretKeyRef:
-                  key: ClientID
-                  name: cluster-autoscaler-azure
-            - name: ARM_CLIENT_SECRET
-              valueFrom:
-                secretKeyRef:
-                  key: ClientSecret
-                  name: cluster-autoscaler-azure
-            - name: ARM_VM_TYPE
-              valueFrom:
-                secretKeyRef:
-                  key: VMType
-                  name: cluster-autoscaler-azure
-          volumeMounts:
-            - mountPath: /etc/ssl/certs/ca-certificates.crt
-              name: ssl-certs
-              readOnly: true
-      restartPolicy: Always
-      volumes:
-        - hostPath:
-            path: /etc/ssl/certs/ca-certificates.crt
-            type: ""
-          name: ssl-certs
diff --git a/cluster-autoscaler/cloudprovider/builder/builder_all.go b/cluster-autoscaler/cloudprovider/builder/builder_all.go
index 5053e3f3b..b013ecb93 100644
--- a/cluster-autoscaler/cloudprovider/builder/builder_all.go
+++ b/cluster-autoscaler/cloudprovider/builder/builder_all.go
@@ -22,7 +22,6 @@ import (
 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/alicloud"
 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/aws"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/azure"
 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/baiducloud"
 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/cloudstack"
 	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/clusterapi"
@@ -42,7 +41,6 @@ import (
 // AvailableCloudProviders supported by the cloud provider builder.
 var AvailableCloudProviders = []string{
 	cloudprovider.AwsProviderName,
-	cloudprovider.AzureProviderName,
 	cloudprovider.GceProviderName,
 	cloudprovider.AlicloudProviderName,
 	cloudprovider.CloudStackProviderName,
@@ -67,8 +65,6 @@ func buildCloudProvider(opts config.AutoscalingOptions, do cloudprovider.NodeGro
 		return gce.BuildGCE(opts, do, rl)
 	case cloudprovider.AwsProviderName:
 		return aws.BuildAWS(opts, do, rl)
-	case cloudprovider.AzureProviderName:
-		return azure.BuildAzure(opts, do, rl)
 	case cloudprovider.AlicloudProviderName:
 		return alicloud.BuildAlicloud(opts, do, rl)
 	case cloudprovider.CloudStackProviderName:
diff --git a/cluster-autoscaler/cloudprovider/builder/builder_azure.go b/cluster-autoscaler/cloudprovider/builder/builder_azure.go
deleted file mode 100644
index 2568fe365..000000000
--- a/cluster-autoscaler/cloudprovider/builder/builder_azure.go
+++ /dev/null
@@ -1,42 +0,0 @@
-// +build azure
-
-/*
-Copyright 2018 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package builder
-
-import (
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider"
-	"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/azure"
-	"k8s.io/autoscaler/cluster-autoscaler/config"
-)
-
-// AvailableCloudProviders supported by the cloud provider builder.
-var AvailableCloudProviders = []string{
-	cloudprovider.AzureProviderName,
-}
-
-// DefaultCloudProvider on Azure-only build is Azure.
-const DefaultCloudProvider = cloudprovider.AzureProviderName
-
-func buildCloudProvider(opts config.AutoscalingOptions, do cloudprovider.NodeGroupDiscoveryOptions, rl *cloudprovider.ResourceLimiter) cloudprovider.CloudProvider {
-	switch opts.CloudProviderName {
-	case cloudprovider.AzureProviderName:
-		return azure.BuildAzure(opts, do, rl)
-	}
-
-	return nil
-}
diff --git a/cluster-autoscaler/go.mod b/cluster-autoscaler/go.mod
index b2d2017c5..99fbb9285 100644
--- a/cluster-autoscaler/go.mod
+++ b/cluster-autoscaler/go.mod
@@ -4,16 +4,10 @@ go 1.16
 
 require (
 	cloud.google.com/go v0.54.0
-	github.com/Azure/azure-sdk-for-go v43.0.0+incompatible
-	github.com/Azure/go-autorest/autorest v0.11.12
-	github.com/Azure/go-autorest/autorest/adal v0.9.5
-	github.com/Azure/go-autorest/autorest/date v0.3.0
-	github.com/Azure/go-autorest/autorest/to v0.2.0
 	github.com/aws/aws-sdk-go v1.35.24
 	github.com/digitalocean/godo v1.27.0
 	github.com/ghodss/yaml v1.0.0
 	github.com/gofrs/uuid v4.3.1+incompatible
-	github.com/golang/mock v1.4.4
 	github.com/google/uuid v1.1.2
 	github.com/jmespath/go-jmespath v0.4.0
 	github.com/json-iterator/go v1.1.10
@@ -21,7 +15,6 @@ require (
 	github.com/prometheus/client_golang v1.7.1
 	github.com/spf13/pflag v1.0.5
 	github.com/stretchr/testify v1.6.1
-	golang.org/x/crypto v0.0.0-20210220033148-5ea612d1eb83
 	golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d
 	google.golang.org/api v0.20.0
 	gopkg.in/gcfg.v1 v1.2.0
diff --git a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/accounts.go b/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/accounts.go
deleted file mode 100644
index 4c3fe8e1d..000000000
--- a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/accounts.go
+++ /dev/null
@@ -1,1157 +0,0 @@
-package storage
-
-// Copyright (c) Microsoft and contributors.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// Code generated by Microsoft (R) AutoRest Code Generator.
-// Changes may cause incorrect behavior and will be lost if the code is regenerated.
-
-import (
-	"context"
-	"github.com/Azure/go-autorest/autorest"
-	"github.com/Azure/go-autorest/autorest/azure"
-	"github.com/Azure/go-autorest/autorest/validation"
-	"github.com/Azure/go-autorest/tracing"
-	"net/http"
-)
-
-// AccountsClient is the the Azure Storage Management API.
-type AccountsClient struct {
-	BaseClient
-}
-
-// NewAccountsClient creates an instance of the AccountsClient client.
-func NewAccountsClient(subscriptionID string) AccountsClient {
-	return NewAccountsClientWithBaseURI(DefaultBaseURI, subscriptionID)
-}
-
-// NewAccountsClientWithBaseURI creates an instance of the AccountsClient client using a custom endpoint.  Use this
-// when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
-func NewAccountsClientWithBaseURI(baseURI string, subscriptionID string) AccountsClient {
-	return AccountsClient{NewWithBaseURI(baseURI, subscriptionID)}
-}
-
-// CheckNameAvailability checks that the storage account name is valid and is not already in use.
-// Parameters:
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-func (client AccountsClient) CheckNameAvailability(ctx context.Context, accountName AccountCheckNameAvailabilityParameters) (result CheckNameAvailabilityResult, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/AccountsClient.CheckNameAvailability")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName.Name", Name: validation.Null, Rule: true, Chain: nil},
-				{Target: "accountName.Type", Name: validation.Null, Rule: true, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.AccountsClient", "CheckNameAvailability", err.Error())
-	}
-
-	req, err := client.CheckNameAvailabilityPreparer(ctx, accountName)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "CheckNameAvailability", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.CheckNameAvailabilitySender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "CheckNameAvailability", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.CheckNameAvailabilityResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "CheckNameAvailability", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// CheckNameAvailabilityPreparer prepares the CheckNameAvailability request.
-func (client AccountsClient) CheckNameAvailabilityPreparer(ctx context.Context, accountName AccountCheckNameAvailabilityParameters) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"subscriptionId": autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPost(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/providers/Microsoft.Storage/checkNameAvailability", pathParameters),
-		autorest.WithJSON(accountName),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// CheckNameAvailabilitySender sends the CheckNameAvailability request. The method will close the
-// http.Response Body if it receives an error.
-func (client AccountsClient) CheckNameAvailabilitySender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// CheckNameAvailabilityResponder handles the response to the CheckNameAvailability request. The method always
-// closes the http.Response Body.
-func (client AccountsClient) CheckNameAvailabilityResponder(resp *http.Response) (result CheckNameAvailabilityResult, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// Create asynchronously creates a new storage account with the specified parameters. If an account is already created
-// and a subsequent create request is issued with different properties, the account properties will be updated. If an
-// account is already created and a subsequent create or update request is issued with the exact same set of
-// properties, the request will succeed.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// parameters - the parameters to provide for the created account.
-func (client AccountsClient) Create(ctx context.Context, resourceGroupName string, accountName string, parameters AccountCreateParameters) (result AccountsCreateFuture, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/AccountsClient.Create")
-		defer func() {
-			sc := -1
-			if result.Response() != nil {
-				sc = result.Response().StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: parameters,
-			Constraints: []validation.Constraint{{Target: "parameters.Sku", Name: validation.Null, Rule: true, Chain: nil},
-				{Target: "parameters.Location", Name: validation.Null, Rule: true, Chain: nil},
-				{Target: "parameters.Identity", Name: validation.Null, Rule: false,
-					Chain: []validation.Constraint{{Target: "parameters.Identity.Type", Name: validation.Null, Rule: true, Chain: nil}}},
-				{Target: "parameters.AccountPropertiesCreateParameters", Name: validation.Null, Rule: false,
-					Chain: []validation.Constraint{{Target: "parameters.AccountPropertiesCreateParameters.CustomDomain", Name: validation.Null, Rule: false,
-						Chain: []validation.Constraint{{Target: "parameters.AccountPropertiesCreateParameters.CustomDomain.Name", Name: validation.Null, Rule: true, Chain: nil}}},
-					}}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.AccountsClient", "Create", err.Error())
-	}
-
-	req, err := client.CreatePreparer(ctx, resourceGroupName, accountName, parameters)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "Create", nil, "Failure preparing request")
-		return
-	}
-
-	result, err = client.CreateSender(req)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "Create", result.Response(), "Failure sending request")
-		return
-	}
-
-	return
-}
-
-// CreatePreparer prepares the Create request.
-func (client AccountsClient) CreatePreparer(ctx context.Context, resourceGroupName string, accountName string, parameters AccountCreateParameters) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPut(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}", pathParameters),
-		autorest.WithJSON(parameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// CreateSender sends the Create request. The method will close the
-// http.Response Body if it receives an error.
-func (client AccountsClient) CreateSender(req *http.Request) (future AccountsCreateFuture, err error) {
-	var resp *http.Response
-	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
-	if err != nil {
-		return
-	}
-	future.Future, err = azure.NewFutureFromResponse(resp)
-	return
-}
-
-// CreateResponder handles the response to the Create request. The method always
-// closes the http.Response Body.
-func (client AccountsClient) CreateResponder(resp *http.Response) (result Account, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// Delete deletes a storage account in Microsoft Azure.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-func (client AccountsClient) Delete(ctx context.Context, resourceGroupName string, accountName string) (result autorest.Response, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/AccountsClient.Delete")
-		defer func() {
-			sc := -1
-			if result.Response != nil {
-				sc = result.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.AccountsClient", "Delete", err.Error())
-	}
-
-	req, err := client.DeletePreparer(ctx, resourceGroupName, accountName)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "Delete", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.DeleteSender(req)
-	if err != nil {
-		result.Response = resp
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "Delete", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.DeleteResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "Delete", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// DeletePreparer prepares the Delete request.
-func (client AccountsClient) DeletePreparer(ctx context.Context, resourceGroupName string, accountName string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsDelete(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// DeleteSender sends the Delete request. The method will close the
-// http.Response Body if it receives an error.
-func (client AccountsClient) DeleteSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// DeleteResponder handles the response to the Delete request. The method always
-// closes the http.Response Body.
-func (client AccountsClient) DeleteResponder(resp *http.Response) (result autorest.Response, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
-		autorest.ByClosing())
-	result.Response = resp
-	return
-}
-
-// Failover failover request can be triggered for a storage account in case of availability issues. The failover occurs
-// from the storage account's primary cluster to secondary cluster for RA-GRS accounts. The secondary cluster will
-// become primary after failover.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-func (client AccountsClient) Failover(ctx context.Context, resourceGroupName string, accountName string) (result AccountsFailoverFuture, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/AccountsClient.Failover")
-		defer func() {
-			sc := -1
-			if result.Response() != nil {
-				sc = result.Response().StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.AccountsClient", "Failover", err.Error())
-	}
-
-	req, err := client.FailoverPreparer(ctx, resourceGroupName, accountName)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "Failover", nil, "Failure preparing request")
-		return
-	}
-
-	result, err = client.FailoverSender(req)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "Failover", result.Response(), "Failure sending request")
-		return
-	}
-
-	return
-}
-
-// FailoverPreparer prepares the Failover request.
-func (client AccountsClient) FailoverPreparer(ctx context.Context, resourceGroupName string, accountName string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsPost(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/failover", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// FailoverSender sends the Failover request. The method will close the
-// http.Response Body if it receives an error.
-func (client AccountsClient) FailoverSender(req *http.Request) (future AccountsFailoverFuture, err error) {
-	var resp *http.Response
-	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
-	if err != nil {
-		return
-	}
-	future.Future, err = azure.NewFutureFromResponse(resp)
-	return
-}
-
-// FailoverResponder handles the response to the Failover request. The method always
-// closes the http.Response Body.
-func (client AccountsClient) FailoverResponder(resp *http.Response) (result autorest.Response, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
-		autorest.ByClosing())
-	result.Response = resp
-	return
-}
-
-// GetProperties returns the properties for the specified storage account including but not limited to name, SKU name,
-// location, and account status. The ListKeys operation should be used to retrieve storage keys.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// expand - may be used to expand the properties within account's properties. By default, data is not included
-// when fetching properties. Currently we only support geoReplicationStats.
-func (client AccountsClient) GetProperties(ctx context.Context, resourceGroupName string, accountName string, expand AccountExpand) (result Account, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/AccountsClient.GetProperties")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.AccountsClient", "GetProperties", err.Error())
-	}
-
-	req, err := client.GetPropertiesPreparer(ctx, resourceGroupName, accountName, expand)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "GetProperties", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.GetPropertiesSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "GetProperties", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.GetPropertiesResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "GetProperties", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// GetPropertiesPreparer prepares the GetProperties request.
-func (client AccountsClient) GetPropertiesPreparer(ctx context.Context, resourceGroupName string, accountName string, expand AccountExpand) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-	if len(string(expand)) > 0 {
-		queryParameters["$expand"] = autorest.Encode("query", expand)
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsGet(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// GetPropertiesSender sends the GetProperties request. The method will close the
-// http.Response Body if it receives an error.
-func (client AccountsClient) GetPropertiesSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// GetPropertiesResponder handles the response to the GetProperties request. The method always
-// closes the http.Response Body.
-func (client AccountsClient) GetPropertiesResponder(resp *http.Response) (result Account, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// List lists all the storage accounts available under the subscription. Note that storage keys are not returned; use
-// the ListKeys operation for this.
-func (client AccountsClient) List(ctx context.Context) (result AccountListResult, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/AccountsClient.List")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.AccountsClient", "List", err.Error())
-	}
-
-	req, err := client.ListPreparer(ctx)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "List", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.ListSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "List", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.ListResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "List", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// ListPreparer prepares the List request.
-func (client AccountsClient) ListPreparer(ctx context.Context) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"subscriptionId": autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsGet(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/providers/Microsoft.Storage/storageAccounts", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// ListSender sends the List request. The method will close the
-// http.Response Body if it receives an error.
-func (client AccountsClient) ListSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// ListResponder handles the response to the List request. The method always
-// closes the http.Response Body.
-func (client AccountsClient) ListResponder(resp *http.Response) (result AccountListResult, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// ListAccountSAS list SAS credentials of a storage account.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// parameters - the parameters to provide to list SAS credentials for the storage account.
-func (client AccountsClient) ListAccountSAS(ctx context.Context, resourceGroupName string, accountName string, parameters AccountSasParameters) (result ListAccountSasResponse, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/AccountsClient.ListAccountSAS")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: parameters,
-			Constraints: []validation.Constraint{{Target: "parameters.SharedAccessExpiryTime", Name: validation.Null, Rule: true, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.AccountsClient", "ListAccountSAS", err.Error())
-	}
-
-	req, err := client.ListAccountSASPreparer(ctx, resourceGroupName, accountName, parameters)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "ListAccountSAS", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.ListAccountSASSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "ListAccountSAS", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.ListAccountSASResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "ListAccountSAS", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// ListAccountSASPreparer prepares the ListAccountSAS request.
-func (client AccountsClient) ListAccountSASPreparer(ctx context.Context, resourceGroupName string, accountName string, parameters AccountSasParameters) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPost(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/ListAccountSas", pathParameters),
-		autorest.WithJSON(parameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// ListAccountSASSender sends the ListAccountSAS request. The method will close the
-// http.Response Body if it receives an error.
-func (client AccountsClient) ListAccountSASSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// ListAccountSASResponder handles the response to the ListAccountSAS request. The method always
-// closes the http.Response Body.
-func (client AccountsClient) ListAccountSASResponder(resp *http.Response) (result ListAccountSasResponse, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// ListByResourceGroup lists all the storage accounts available under the given resource group. Note that storage keys
-// are not returned; use the ListKeys operation for this.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-func (client AccountsClient) ListByResourceGroup(ctx context.Context, resourceGroupName string) (result AccountListResult, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/AccountsClient.ListByResourceGroup")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.AccountsClient", "ListByResourceGroup", err.Error())
-	}
-
-	req, err := client.ListByResourceGroupPreparer(ctx, resourceGroupName)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "ListByResourceGroup", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.ListByResourceGroupSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "ListByResourceGroup", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.ListByResourceGroupResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "ListByResourceGroup", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// ListByResourceGroupPreparer prepares the ListByResourceGroup request.
-func (client AccountsClient) ListByResourceGroupPreparer(ctx context.Context, resourceGroupName string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsGet(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// ListByResourceGroupSender sends the ListByResourceGroup request. The method will close the
-// http.Response Body if it receives an error.
-func (client AccountsClient) ListByResourceGroupSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// ListByResourceGroupResponder handles the response to the ListByResourceGroup request. The method always
-// closes the http.Response Body.
-func (client AccountsClient) ListByResourceGroupResponder(resp *http.Response) (result AccountListResult, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// ListKeys lists the access keys for the specified storage account.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-func (client AccountsClient) ListKeys(ctx context.Context, resourceGroupName string, accountName string) (result AccountListKeysResult, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/AccountsClient.ListKeys")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.AccountsClient", "ListKeys", err.Error())
-	}
-
-	req, err := client.ListKeysPreparer(ctx, resourceGroupName, accountName)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "ListKeys", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.ListKeysSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "ListKeys", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.ListKeysResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "ListKeys", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// ListKeysPreparer prepares the ListKeys request.
-func (client AccountsClient) ListKeysPreparer(ctx context.Context, resourceGroupName string, accountName string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsPost(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/listKeys", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// ListKeysSender sends the ListKeys request. The method will close the
-// http.Response Body if it receives an error.
-func (client AccountsClient) ListKeysSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// ListKeysResponder handles the response to the ListKeys request. The method always
-// closes the http.Response Body.
-func (client AccountsClient) ListKeysResponder(resp *http.Response) (result AccountListKeysResult, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// ListServiceSAS list service SAS credentials of a specific resource.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// parameters - the parameters to provide to list service SAS credentials.
-func (client AccountsClient) ListServiceSAS(ctx context.Context, resourceGroupName string, accountName string, parameters ServiceSasParameters) (result ListServiceSasResponse, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/AccountsClient.ListServiceSAS")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: parameters,
-			Constraints: []validation.Constraint{{Target: "parameters.CanonicalizedResource", Name: validation.Null, Rule: true, Chain: nil},
-				{Target: "parameters.Identifier", Name: validation.Null, Rule: false,
-					Chain: []validation.Constraint{{Target: "parameters.Identifier", Name: validation.MaxLength, Rule: 64, Chain: nil}}}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.AccountsClient", "ListServiceSAS", err.Error())
-	}
-
-	req, err := client.ListServiceSASPreparer(ctx, resourceGroupName, accountName, parameters)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "ListServiceSAS", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.ListServiceSASSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "ListServiceSAS", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.ListServiceSASResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "ListServiceSAS", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// ListServiceSASPreparer prepares the ListServiceSAS request.
-func (client AccountsClient) ListServiceSASPreparer(ctx context.Context, resourceGroupName string, accountName string, parameters ServiceSasParameters) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPost(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/ListServiceSas", pathParameters),
-		autorest.WithJSON(parameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// ListServiceSASSender sends the ListServiceSAS request. The method will close the
-// http.Response Body if it receives an error.
-func (client AccountsClient) ListServiceSASSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// ListServiceSASResponder handles the response to the ListServiceSAS request. The method always
-// closes the http.Response Body.
-func (client AccountsClient) ListServiceSASResponder(resp *http.Response) (result ListServiceSasResponse, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// RegenerateKey regenerates one of the access keys for the specified storage account.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// regenerateKey - specifies name of the key which should be regenerated -- key1 or key2.
-func (client AccountsClient) RegenerateKey(ctx context.Context, resourceGroupName string, accountName string, regenerateKey AccountRegenerateKeyParameters) (result AccountListKeysResult, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/AccountsClient.RegenerateKey")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: regenerateKey,
-			Constraints: []validation.Constraint{{Target: "regenerateKey.KeyName", Name: validation.Null, Rule: true, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.AccountsClient", "RegenerateKey", err.Error())
-	}
-
-	req, err := client.RegenerateKeyPreparer(ctx, resourceGroupName, accountName, regenerateKey)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "RegenerateKey", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.RegenerateKeySender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "RegenerateKey", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.RegenerateKeyResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "RegenerateKey", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// RegenerateKeyPreparer prepares the RegenerateKey request.
-func (client AccountsClient) RegenerateKeyPreparer(ctx context.Context, resourceGroupName string, accountName string, regenerateKey AccountRegenerateKeyParameters) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPost(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/regenerateKey", pathParameters),
-		autorest.WithJSON(regenerateKey),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// RegenerateKeySender sends the RegenerateKey request. The method will close the
-// http.Response Body if it receives an error.
-func (client AccountsClient) RegenerateKeySender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// RegenerateKeyResponder handles the response to the RegenerateKey request. The method always
-// closes the http.Response Body.
-func (client AccountsClient) RegenerateKeyResponder(resp *http.Response) (result AccountListKeysResult, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// Update the update operation can be used to update the SKU, encryption, access tier, or tags for a storage account.
-// It can also be used to map the account to a custom domain. Only one custom domain is supported per storage account;
-// the replacement/change of custom domain is not supported. In order to replace an old custom domain, the old value
-// must be cleared/unregistered before a new value can be set. The update of multiple properties is supported. This
-// call does not change the storage keys for the account. If you want to change the storage account keys, use the
-// regenerate keys operation. The location and name of the storage account cannot be changed after creation.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// parameters - the parameters to provide for the updated account.
-func (client AccountsClient) Update(ctx context.Context, resourceGroupName string, accountName string, parameters AccountUpdateParameters) (result Account, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/AccountsClient.Update")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.AccountsClient", "Update", err.Error())
-	}
-
-	req, err := client.UpdatePreparer(ctx, resourceGroupName, accountName, parameters)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "Update", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.UpdateSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "Update", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.UpdateResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsClient", "Update", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// UpdatePreparer prepares the Update request.
-func (client AccountsClient) UpdatePreparer(ctx context.Context, resourceGroupName string, accountName string, parameters AccountUpdateParameters) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPatch(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}", pathParameters),
-		autorest.WithJSON(parameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// UpdateSender sends the Update request. The method will close the
-// http.Response Body if it receives an error.
-func (client AccountsClient) UpdateSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// UpdateResponder handles the response to the Update request. The method always
-// closes the http.Response Body.
-func (client AccountsClient) UpdateResponder(resp *http.Response) (result Account, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
diff --git a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/blobcontainers.go b/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/blobcontainers.go
deleted file mode 100644
index 39072e5f4..000000000
--- a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/blobcontainers.go
+++ /dev/null
@@ -1,1405 +0,0 @@
-package storage
-
-// Copyright (c) Microsoft and contributors.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// Code generated by Microsoft (R) AutoRest Code Generator.
-// Changes may cause incorrect behavior and will be lost if the code is regenerated.
-
-import (
-	"context"
-	"github.com/Azure/go-autorest/autorest"
-	"github.com/Azure/go-autorest/autorest/azure"
-	"github.com/Azure/go-autorest/autorest/validation"
-	"github.com/Azure/go-autorest/tracing"
-	"net/http"
-)
-
-// BlobContainersClient is the the Azure Storage Management API.
-type BlobContainersClient struct {
-	BaseClient
-}
-
-// NewBlobContainersClient creates an instance of the BlobContainersClient client.
-func NewBlobContainersClient(subscriptionID string) BlobContainersClient {
-	return NewBlobContainersClientWithBaseURI(DefaultBaseURI, subscriptionID)
-}
-
-// NewBlobContainersClientWithBaseURI creates an instance of the BlobContainersClient client using a custom endpoint.
-// Use this when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
-func NewBlobContainersClientWithBaseURI(baseURI string, subscriptionID string) BlobContainersClient {
-	return BlobContainersClient{NewWithBaseURI(baseURI, subscriptionID)}
-}
-
-// ClearLegalHold clears legal hold tags. Clearing the same or non-existent tag results in an idempotent operation.
-// ClearLegalHold clears out only the specified tags in the request.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// containerName - the name of the blob container within the specified storage account. Blob container names
-// must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only. Every
-// dash (-) character must be immediately preceded and followed by a letter or number.
-// legalHold - the LegalHold property that will be clear from a blob container.
-func (client BlobContainersClient) ClearLegalHold(ctx context.Context, resourceGroupName string, accountName string, containerName string, legalHold LegalHold) (result LegalHold, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobContainersClient.ClearLegalHold")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: containerName,
-			Constraints: []validation.Constraint{{Target: "containerName", Name: validation.MaxLength, Rule: 63, Chain: nil},
-				{Target: "containerName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
-		{TargetValue: legalHold,
-			Constraints: []validation.Constraint{{Target: "legalHold.Tags", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.BlobContainersClient", "ClearLegalHold", err.Error())
-	}
-
-	req, err := client.ClearLegalHoldPreparer(ctx, resourceGroupName, accountName, containerName, legalHold)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "ClearLegalHold", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.ClearLegalHoldSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "ClearLegalHold", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.ClearLegalHoldResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "ClearLegalHold", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// ClearLegalHoldPreparer prepares the ClearLegalHold request.
-func (client BlobContainersClient) ClearLegalHoldPreparer(ctx context.Context, resourceGroupName string, accountName string, containerName string, legalHold LegalHold) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"containerName":     autorest.Encode("path", containerName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	legalHold.HasLegalHold = nil
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPost(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/clearLegalHold", pathParameters),
-		autorest.WithJSON(legalHold),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// ClearLegalHoldSender sends the ClearLegalHold request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobContainersClient) ClearLegalHoldSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// ClearLegalHoldResponder handles the response to the ClearLegalHold request. The method always
-// closes the http.Response Body.
-func (client BlobContainersClient) ClearLegalHoldResponder(resp *http.Response) (result LegalHold, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// Create creates a new container under the specified account as described by request body. The container resource
-// includes metadata and properties for that container. It does not include a list of the blobs contained by the
-// container.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// containerName - the name of the blob container within the specified storage account. Blob container names
-// must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only. Every
-// dash (-) character must be immediately preceded and followed by a letter or number.
-// blobContainer - properties of the blob container to create.
-func (client BlobContainersClient) Create(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainer BlobContainer) (result BlobContainer, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobContainersClient.Create")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: containerName,
-			Constraints: []validation.Constraint{{Target: "containerName", Name: validation.MaxLength, Rule: 63, Chain: nil},
-				{Target: "containerName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: blobContainer,
-			Constraints: []validation.Constraint{{Target: "blobContainer.ContainerProperties", Name: validation.Null, Rule: false,
-				Chain: []validation.Constraint{{Target: "blobContainer.ContainerProperties.ImmutabilityPolicy", Name: validation.Null, Rule: false,
-					Chain: []validation.Constraint{{Target: "blobContainer.ContainerProperties.ImmutabilityPolicy.ImmutabilityPolicyProperty", Name: validation.Null, Rule: false,
-						Chain: []validation.Constraint{{Target: "blobContainer.ContainerProperties.ImmutabilityPolicy.ImmutabilityPolicyProperty.ImmutabilityPeriodSinceCreationInDays", Name: validation.Null, Rule: true, Chain: nil}}},
-					}},
-				}}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.BlobContainersClient", "Create", err.Error())
-	}
-
-	req, err := client.CreatePreparer(ctx, resourceGroupName, accountName, containerName, blobContainer)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Create", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.CreateSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Create", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.CreateResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Create", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// CreatePreparer prepares the Create request.
-func (client BlobContainersClient) CreatePreparer(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainer BlobContainer) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"containerName":     autorest.Encode("path", containerName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPut(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}", pathParameters),
-		autorest.WithJSON(blobContainer),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// CreateSender sends the Create request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobContainersClient) CreateSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// CreateResponder handles the response to the Create request. The method always
-// closes the http.Response Body.
-func (client BlobContainersClient) CreateResponder(resp *http.Response) (result BlobContainer, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// CreateOrUpdateImmutabilityPolicy creates or updates an unlocked immutability policy. ETag in If-Match is honored if
-// given but not required for this operation.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// containerName - the name of the blob container within the specified storage account. Blob container names
-// must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only. Every
-// dash (-) character must be immediately preceded and followed by a letter or number.
-// parameters - the ImmutabilityPolicy Properties that will be created or updated to a blob container.
-// ifMatch - the entity state (ETag) version of the immutability policy to update. A value of "*" can be used
-// to apply the operation only if the immutability policy already exists. If omitted, this operation will
-// always be applied.
-func (client BlobContainersClient) CreateOrUpdateImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, parameters *ImmutabilityPolicy, ifMatch string) (result ImmutabilityPolicy, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobContainersClient.CreateOrUpdateImmutabilityPolicy")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: containerName,
-			Constraints: []validation.Constraint{{Target: "containerName", Name: validation.MaxLength, Rule: 63, Chain: nil},
-				{Target: "containerName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
-		{TargetValue: parameters,
-			Constraints: []validation.Constraint{{Target: "parameters", Name: validation.Null, Rule: false,
-				Chain: []validation.Constraint{{Target: "parameters.ImmutabilityPolicyProperty", Name: validation.Null, Rule: true,
-					Chain: []validation.Constraint{{Target: "parameters.ImmutabilityPolicyProperty.ImmutabilityPeriodSinceCreationInDays", Name: validation.Null, Rule: true, Chain: nil}}},
-				}}}}}); err != nil {
-		return result, validation.NewError("storage.BlobContainersClient", "CreateOrUpdateImmutabilityPolicy", err.Error())
-	}
-
-	req, err := client.CreateOrUpdateImmutabilityPolicyPreparer(ctx, resourceGroupName, accountName, containerName, parameters, ifMatch)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "CreateOrUpdateImmutabilityPolicy", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.CreateOrUpdateImmutabilityPolicySender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "CreateOrUpdateImmutabilityPolicy", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.CreateOrUpdateImmutabilityPolicyResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "CreateOrUpdateImmutabilityPolicy", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// CreateOrUpdateImmutabilityPolicyPreparer prepares the CreateOrUpdateImmutabilityPolicy request.
-func (client BlobContainersClient) CreateOrUpdateImmutabilityPolicyPreparer(ctx context.Context, resourceGroupName string, accountName string, containerName string, parameters *ImmutabilityPolicy, ifMatch string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":            autorest.Encode("path", accountName),
-		"containerName":          autorest.Encode("path", containerName),
-		"immutabilityPolicyName": autorest.Encode("path", "default"),
-		"resourceGroupName":      autorest.Encode("path", resourceGroupName),
-		"subscriptionId":         autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPut(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/{immutabilityPolicyName}", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	if parameters != nil {
-		preparer = autorest.DecoratePreparer(preparer,
-			autorest.WithJSON(parameters))
-	}
-	if len(ifMatch) > 0 {
-		preparer = autorest.DecoratePreparer(preparer,
-			autorest.WithHeader("If-Match", autorest.String(ifMatch)))
-	}
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// CreateOrUpdateImmutabilityPolicySender sends the CreateOrUpdateImmutabilityPolicy request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobContainersClient) CreateOrUpdateImmutabilityPolicySender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// CreateOrUpdateImmutabilityPolicyResponder handles the response to the CreateOrUpdateImmutabilityPolicy request. The method always
-// closes the http.Response Body.
-func (client BlobContainersClient) CreateOrUpdateImmutabilityPolicyResponder(resp *http.Response) (result ImmutabilityPolicy, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// Delete deletes specified container under its account.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// containerName - the name of the blob container within the specified storage account. Blob container names
-// must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only. Every
-// dash (-) character must be immediately preceded and followed by a letter or number.
-func (client BlobContainersClient) Delete(ctx context.Context, resourceGroupName string, accountName string, containerName string) (result autorest.Response, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobContainersClient.Delete")
-		defer func() {
-			sc := -1
-			if result.Response != nil {
-				sc = result.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: containerName,
-			Constraints: []validation.Constraint{{Target: "containerName", Name: validation.MaxLength, Rule: 63, Chain: nil},
-				{Target: "containerName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.BlobContainersClient", "Delete", err.Error())
-	}
-
-	req, err := client.DeletePreparer(ctx, resourceGroupName, accountName, containerName)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Delete", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.DeleteSender(req)
-	if err != nil {
-		result.Response = resp
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Delete", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.DeleteResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Delete", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// DeletePreparer prepares the Delete request.
-func (client BlobContainersClient) DeletePreparer(ctx context.Context, resourceGroupName string, accountName string, containerName string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"containerName":     autorest.Encode("path", containerName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsDelete(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// DeleteSender sends the Delete request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobContainersClient) DeleteSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// DeleteResponder handles the response to the Delete request. The method always
-// closes the http.Response Body.
-func (client BlobContainersClient) DeleteResponder(resp *http.Response) (result autorest.Response, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
-		autorest.ByClosing())
-	result.Response = resp
-	return
-}
-
-// DeleteImmutabilityPolicy aborts an unlocked immutability policy. The response of delete has
-// immutabilityPeriodSinceCreationInDays set to 0. ETag in If-Match is required for this operation. Deleting a locked
-// immutability policy is not allowed, only way is to delete the container after deleting all blobs inside the
-// container.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// containerName - the name of the blob container within the specified storage account. Blob container names
-// must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only. Every
-// dash (-) character must be immediately preceded and followed by a letter or number.
-// ifMatch - the entity state (ETag) version of the immutability policy to update. A value of "*" can be used
-// to apply the operation only if the immutability policy already exists. If omitted, this operation will
-// always be applied.
-func (client BlobContainersClient) DeleteImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string) (result ImmutabilityPolicy, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobContainersClient.DeleteImmutabilityPolicy")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: containerName,
-			Constraints: []validation.Constraint{{Target: "containerName", Name: validation.MaxLength, Rule: 63, Chain: nil},
-				{Target: "containerName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.BlobContainersClient", "DeleteImmutabilityPolicy", err.Error())
-	}
-
-	req, err := client.DeleteImmutabilityPolicyPreparer(ctx, resourceGroupName, accountName, containerName, ifMatch)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "DeleteImmutabilityPolicy", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.DeleteImmutabilityPolicySender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "DeleteImmutabilityPolicy", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.DeleteImmutabilityPolicyResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "DeleteImmutabilityPolicy", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// DeleteImmutabilityPolicyPreparer prepares the DeleteImmutabilityPolicy request.
-func (client BlobContainersClient) DeleteImmutabilityPolicyPreparer(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":            autorest.Encode("path", accountName),
-		"containerName":          autorest.Encode("path", containerName),
-		"immutabilityPolicyName": autorest.Encode("path", "default"),
-		"resourceGroupName":      autorest.Encode("path", resourceGroupName),
-		"subscriptionId":         autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsDelete(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/{immutabilityPolicyName}", pathParameters),
-		autorest.WithQueryParameters(queryParameters),
-		autorest.WithHeader("If-Match", autorest.String(ifMatch)))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// DeleteImmutabilityPolicySender sends the DeleteImmutabilityPolicy request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobContainersClient) DeleteImmutabilityPolicySender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// DeleteImmutabilityPolicyResponder handles the response to the DeleteImmutabilityPolicy request. The method always
-// closes the http.Response Body.
-func (client BlobContainersClient) DeleteImmutabilityPolicyResponder(resp *http.Response) (result ImmutabilityPolicy, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// ExtendImmutabilityPolicy extends the immutabilityPeriodSinceCreationInDays of a locked immutabilityPolicy. The only
-// action allowed on a Locked policy will be this action. ETag in If-Match is required for this operation.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// containerName - the name of the blob container within the specified storage account. Blob container names
-// must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only. Every
-// dash (-) character must be immediately preceded and followed by a letter or number.
-// ifMatch - the entity state (ETag) version of the immutability policy to update. A value of "*" can be used
-// to apply the operation only if the immutability policy already exists. If omitted, this operation will
-// always be applied.
-// parameters - the ImmutabilityPolicy Properties that will be extended for a blob container.
-func (client BlobContainersClient) ExtendImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string, parameters *ImmutabilityPolicy) (result ImmutabilityPolicy, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobContainersClient.ExtendImmutabilityPolicy")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: containerName,
-			Constraints: []validation.Constraint{{Target: "containerName", Name: validation.MaxLength, Rule: 63, Chain: nil},
-				{Target: "containerName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
-		{TargetValue: parameters,
-			Constraints: []validation.Constraint{{Target: "parameters", Name: validation.Null, Rule: false,
-				Chain: []validation.Constraint{{Target: "parameters.ImmutabilityPolicyProperty", Name: validation.Null, Rule: true,
-					Chain: []validation.Constraint{{Target: "parameters.ImmutabilityPolicyProperty.ImmutabilityPeriodSinceCreationInDays", Name: validation.Null, Rule: true, Chain: nil}}},
-				}}}}}); err != nil {
-		return result, validation.NewError("storage.BlobContainersClient", "ExtendImmutabilityPolicy", err.Error())
-	}
-
-	req, err := client.ExtendImmutabilityPolicyPreparer(ctx, resourceGroupName, accountName, containerName, ifMatch, parameters)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "ExtendImmutabilityPolicy", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.ExtendImmutabilityPolicySender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "ExtendImmutabilityPolicy", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.ExtendImmutabilityPolicyResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "ExtendImmutabilityPolicy", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// ExtendImmutabilityPolicyPreparer prepares the ExtendImmutabilityPolicy request.
-func (client BlobContainersClient) ExtendImmutabilityPolicyPreparer(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string, parameters *ImmutabilityPolicy) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"containerName":     autorest.Encode("path", containerName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPost(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/default/extend", pathParameters),
-		autorest.WithQueryParameters(queryParameters),
-		autorest.WithHeader("If-Match", autorest.String(ifMatch)))
-	if parameters != nil {
-		preparer = autorest.DecoratePreparer(preparer,
-			autorest.WithJSON(parameters))
-	}
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// ExtendImmutabilityPolicySender sends the ExtendImmutabilityPolicy request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobContainersClient) ExtendImmutabilityPolicySender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// ExtendImmutabilityPolicyResponder handles the response to the ExtendImmutabilityPolicy request. The method always
-// closes the http.Response Body.
-func (client BlobContainersClient) ExtendImmutabilityPolicyResponder(resp *http.Response) (result ImmutabilityPolicy, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// Get gets properties of a specified container.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// containerName - the name of the blob container within the specified storage account. Blob container names
-// must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only. Every
-// dash (-) character must be immediately preceded and followed by a letter or number.
-func (client BlobContainersClient) Get(ctx context.Context, resourceGroupName string, accountName string, containerName string) (result BlobContainer, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobContainersClient.Get")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: containerName,
-			Constraints: []validation.Constraint{{Target: "containerName", Name: validation.MaxLength, Rule: 63, Chain: nil},
-				{Target: "containerName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.BlobContainersClient", "Get", err.Error())
-	}
-
-	req, err := client.GetPreparer(ctx, resourceGroupName, accountName, containerName)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Get", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.GetSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Get", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.GetResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Get", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// GetPreparer prepares the Get request.
-func (client BlobContainersClient) GetPreparer(ctx context.Context, resourceGroupName string, accountName string, containerName string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"containerName":     autorest.Encode("path", containerName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsGet(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// GetSender sends the Get request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobContainersClient) GetSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// GetResponder handles the response to the Get request. The method always
-// closes the http.Response Body.
-func (client BlobContainersClient) GetResponder(resp *http.Response) (result BlobContainer, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// GetImmutabilityPolicy gets the existing immutability policy along with the corresponding ETag in response headers
-// and body.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// containerName - the name of the blob container within the specified storage account. Blob container names
-// must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only. Every
-// dash (-) character must be immediately preceded and followed by a letter or number.
-// ifMatch - the entity state (ETag) version of the immutability policy to update. A value of "*" can be used
-// to apply the operation only if the immutability policy already exists. If omitted, this operation will
-// always be applied.
-func (client BlobContainersClient) GetImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string) (result ImmutabilityPolicy, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobContainersClient.GetImmutabilityPolicy")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: containerName,
-			Constraints: []validation.Constraint{{Target: "containerName", Name: validation.MaxLength, Rule: 63, Chain: nil},
-				{Target: "containerName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.BlobContainersClient", "GetImmutabilityPolicy", err.Error())
-	}
-
-	req, err := client.GetImmutabilityPolicyPreparer(ctx, resourceGroupName, accountName, containerName, ifMatch)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "GetImmutabilityPolicy", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.GetImmutabilityPolicySender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "GetImmutabilityPolicy", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.GetImmutabilityPolicyResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "GetImmutabilityPolicy", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// GetImmutabilityPolicyPreparer prepares the GetImmutabilityPolicy request.
-func (client BlobContainersClient) GetImmutabilityPolicyPreparer(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":            autorest.Encode("path", accountName),
-		"containerName":          autorest.Encode("path", containerName),
-		"immutabilityPolicyName": autorest.Encode("path", "default"),
-		"resourceGroupName":      autorest.Encode("path", resourceGroupName),
-		"subscriptionId":         autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsGet(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/{immutabilityPolicyName}", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	if len(ifMatch) > 0 {
-		preparer = autorest.DecoratePreparer(preparer,
-			autorest.WithHeader("If-Match", autorest.String(ifMatch)))
-	}
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// GetImmutabilityPolicySender sends the GetImmutabilityPolicy request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobContainersClient) GetImmutabilityPolicySender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// GetImmutabilityPolicyResponder handles the response to the GetImmutabilityPolicy request. The method always
-// closes the http.Response Body.
-func (client BlobContainersClient) GetImmutabilityPolicyResponder(resp *http.Response) (result ImmutabilityPolicy, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// Lease the Lease Container operation establishes and manages a lock on a container for delete operations. The lock
-// duration can be 15 to 60 seconds, or can be infinite.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// containerName - the name of the blob container within the specified storage account. Blob container names
-// must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only. Every
-// dash (-) character must be immediately preceded and followed by a letter or number.
-// parameters - lease Container request body.
-func (client BlobContainersClient) Lease(ctx context.Context, resourceGroupName string, accountName string, containerName string, parameters *LeaseContainerRequest) (result LeaseContainerResponse, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobContainersClient.Lease")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: containerName,
-			Constraints: []validation.Constraint{{Target: "containerName", Name: validation.MaxLength, Rule: 63, Chain: nil},
-				{Target: "containerName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.BlobContainersClient", "Lease", err.Error())
-	}
-
-	req, err := client.LeasePreparer(ctx, resourceGroupName, accountName, containerName, parameters)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Lease", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.LeaseSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Lease", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.LeaseResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Lease", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// LeasePreparer prepares the Lease request.
-func (client BlobContainersClient) LeasePreparer(ctx context.Context, resourceGroupName string, accountName string, containerName string, parameters *LeaseContainerRequest) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"containerName":     autorest.Encode("path", containerName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPost(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/lease", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	if parameters != nil {
-		preparer = autorest.DecoratePreparer(preparer,
-			autorest.WithJSON(parameters))
-	}
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// LeaseSender sends the Lease request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobContainersClient) LeaseSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// LeaseResponder handles the response to the Lease request. The method always
-// closes the http.Response Body.
-func (client BlobContainersClient) LeaseResponder(resp *http.Response) (result LeaseContainerResponse, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// List lists all containers and does not support a prefix like data plane. Also SRP today does not return continuation
-// token.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-func (client BlobContainersClient) List(ctx context.Context, resourceGroupName string, accountName string) (result ListContainerItems, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobContainersClient.List")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.BlobContainersClient", "List", err.Error())
-	}
-
-	req, err := client.ListPreparer(ctx, resourceGroupName, accountName)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "List", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.ListSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "List", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.ListResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "List", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// ListPreparer prepares the List request.
-func (client BlobContainersClient) ListPreparer(ctx context.Context, resourceGroupName string, accountName string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsGet(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// ListSender sends the List request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobContainersClient) ListSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// ListResponder handles the response to the List request. The method always
-// closes the http.Response Body.
-func (client BlobContainersClient) ListResponder(resp *http.Response) (result ListContainerItems, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// LockImmutabilityPolicy sets the ImmutabilityPolicy to Locked state. The only action allowed on a Locked policy is
-// ExtendImmutabilityPolicy action. ETag in If-Match is required for this operation.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// containerName - the name of the blob container within the specified storage account. Blob container names
-// must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only. Every
-// dash (-) character must be immediately preceded and followed by a letter or number.
-// ifMatch - the entity state (ETag) version of the immutability policy to update. A value of "*" can be used
-// to apply the operation only if the immutability policy already exists. If omitted, this operation will
-// always be applied.
-func (client BlobContainersClient) LockImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string) (result ImmutabilityPolicy, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobContainersClient.LockImmutabilityPolicy")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: containerName,
-			Constraints: []validation.Constraint{{Target: "containerName", Name: validation.MaxLength, Rule: 63, Chain: nil},
-				{Target: "containerName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.BlobContainersClient", "LockImmutabilityPolicy", err.Error())
-	}
-
-	req, err := client.LockImmutabilityPolicyPreparer(ctx, resourceGroupName, accountName, containerName, ifMatch)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "LockImmutabilityPolicy", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.LockImmutabilityPolicySender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "LockImmutabilityPolicy", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.LockImmutabilityPolicyResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "LockImmutabilityPolicy", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// LockImmutabilityPolicyPreparer prepares the LockImmutabilityPolicy request.
-func (client BlobContainersClient) LockImmutabilityPolicyPreparer(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"containerName":     autorest.Encode("path", containerName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsPost(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/default/lock", pathParameters),
-		autorest.WithQueryParameters(queryParameters),
-		autorest.WithHeader("If-Match", autorest.String(ifMatch)))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// LockImmutabilityPolicySender sends the LockImmutabilityPolicy request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobContainersClient) LockImmutabilityPolicySender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// LockImmutabilityPolicyResponder handles the response to the LockImmutabilityPolicy request. The method always
-// closes the http.Response Body.
-func (client BlobContainersClient) LockImmutabilityPolicyResponder(resp *http.Response) (result ImmutabilityPolicy, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// SetLegalHold sets legal hold tags. Setting the same tag results in an idempotent operation. SetLegalHold follows an
-// append pattern and does not clear out the existing tags that are not specified in the request.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// containerName - the name of the blob container within the specified storage account. Blob container names
-// must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only. Every
-// dash (-) character must be immediately preceded and followed by a letter or number.
-// legalHold - the LegalHold property that will be set to a blob container.
-func (client BlobContainersClient) SetLegalHold(ctx context.Context, resourceGroupName string, accountName string, containerName string, legalHold LegalHold) (result LegalHold, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobContainersClient.SetLegalHold")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: containerName,
-			Constraints: []validation.Constraint{{Target: "containerName", Name: validation.MaxLength, Rule: 63, Chain: nil},
-				{Target: "containerName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
-		{TargetValue: legalHold,
-			Constraints: []validation.Constraint{{Target: "legalHold.Tags", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.BlobContainersClient", "SetLegalHold", err.Error())
-	}
-
-	req, err := client.SetLegalHoldPreparer(ctx, resourceGroupName, accountName, containerName, legalHold)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "SetLegalHold", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.SetLegalHoldSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "SetLegalHold", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.SetLegalHoldResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "SetLegalHold", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// SetLegalHoldPreparer prepares the SetLegalHold request.
-func (client BlobContainersClient) SetLegalHoldPreparer(ctx context.Context, resourceGroupName string, accountName string, containerName string, legalHold LegalHold) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"containerName":     autorest.Encode("path", containerName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	legalHold.HasLegalHold = nil
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPost(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/setLegalHold", pathParameters),
-		autorest.WithJSON(legalHold),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// SetLegalHoldSender sends the SetLegalHold request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobContainersClient) SetLegalHoldSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// SetLegalHoldResponder handles the response to the SetLegalHold request. The method always
-// closes the http.Response Body.
-func (client BlobContainersClient) SetLegalHoldResponder(resp *http.Response) (result LegalHold, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// Update updates container properties as specified in request body. Properties not mentioned in the request will be
-// unchanged. Update fails if the specified container doesn't already exist.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// containerName - the name of the blob container within the specified storage account. Blob container names
-// must be between 3 and 63 characters in length and use numbers, lower-case letters and dash (-) only. Every
-// dash (-) character must be immediately preceded and followed by a letter or number.
-// blobContainer - properties to update for the blob container.
-func (client BlobContainersClient) Update(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainer BlobContainer) (result BlobContainer, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobContainersClient.Update")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: containerName,
-			Constraints: []validation.Constraint{{Target: "containerName", Name: validation.MaxLength, Rule: 63, Chain: nil},
-				{Target: "containerName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.BlobContainersClient", "Update", err.Error())
-	}
-
-	req, err := client.UpdatePreparer(ctx, resourceGroupName, accountName, containerName, blobContainer)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Update", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.UpdateSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Update", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.UpdateResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobContainersClient", "Update", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// UpdatePreparer prepares the Update request.
-func (client BlobContainersClient) UpdatePreparer(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainer BlobContainer) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"containerName":     autorest.Encode("path", containerName),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPatch(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}", pathParameters),
-		autorest.WithJSON(blobContainer),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// UpdateSender sends the Update request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobContainersClient) UpdateSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// UpdateResponder handles the response to the Update request. The method always
-// closes the http.Response Body.
-func (client BlobContainersClient) UpdateResponder(resp *http.Response) (result BlobContainer, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
diff --git a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/blobservices.go b/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/blobservices.go
deleted file mode 100644
index a08d84b91..000000000
--- a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/blobservices.go
+++ /dev/null
@@ -1,242 +0,0 @@
-package storage
-
-// Copyright (c) Microsoft and contributors.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// Code generated by Microsoft (R) AutoRest Code Generator.
-// Changes may cause incorrect behavior and will be lost if the code is regenerated.
-
-import (
-	"context"
-	"github.com/Azure/go-autorest/autorest"
-	"github.com/Azure/go-autorest/autorest/azure"
-	"github.com/Azure/go-autorest/autorest/validation"
-	"github.com/Azure/go-autorest/tracing"
-	"net/http"
-)
-
-// BlobServicesClient is the the Azure Storage Management API.
-type BlobServicesClient struct {
-	BaseClient
-}
-
-// NewBlobServicesClient creates an instance of the BlobServicesClient client.
-func NewBlobServicesClient(subscriptionID string) BlobServicesClient {
-	return NewBlobServicesClientWithBaseURI(DefaultBaseURI, subscriptionID)
-}
-
-// NewBlobServicesClientWithBaseURI creates an instance of the BlobServicesClient client using a custom endpoint.  Use
-// this when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
-func NewBlobServicesClientWithBaseURI(baseURI string, subscriptionID string) BlobServicesClient {
-	return BlobServicesClient{NewWithBaseURI(baseURI, subscriptionID)}
-}
-
-// GetServiceProperties gets the properties of a storage accounts Blob service, including properties for Storage
-// Analytics and CORS (Cross-Origin Resource Sharing) rules.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-func (client BlobServicesClient) GetServiceProperties(ctx context.Context, resourceGroupName string, accountName string) (result BlobServiceProperties, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobServicesClient.GetServiceProperties")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.BlobServicesClient", "GetServiceProperties", err.Error())
-	}
-
-	req, err := client.GetServicePropertiesPreparer(ctx, resourceGroupName, accountName)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobServicesClient", "GetServiceProperties", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.GetServicePropertiesSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobServicesClient", "GetServiceProperties", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.GetServicePropertiesResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobServicesClient", "GetServiceProperties", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// GetServicePropertiesPreparer prepares the GetServiceProperties request.
-func (client BlobServicesClient) GetServicePropertiesPreparer(ctx context.Context, resourceGroupName string, accountName string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"BlobServicesName":  autorest.Encode("path", "default"),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsGet(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/{BlobServicesName}", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// GetServicePropertiesSender sends the GetServiceProperties request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobServicesClient) GetServicePropertiesSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// GetServicePropertiesResponder handles the response to the GetServiceProperties request. The method always
-// closes the http.Response Body.
-func (client BlobServicesClient) GetServicePropertiesResponder(resp *http.Response) (result BlobServiceProperties, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// SetServiceProperties sets the properties of a storage accounts Blob service, including properties for Storage
-// Analytics and CORS (Cross-Origin Resource Sharing) rules.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// parameters - the properties of a storage accounts Blob service, including properties for Storage Analytics
-// and CORS (Cross-Origin Resource Sharing) rules.
-func (client BlobServicesClient) SetServiceProperties(ctx context.Context, resourceGroupName string, accountName string, parameters BlobServiceProperties) (result BlobServiceProperties, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/BlobServicesClient.SetServiceProperties")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
-		{TargetValue: parameters,
-			Constraints: []validation.Constraint{{Target: "parameters.BlobServicePropertiesProperties", Name: validation.Null, Rule: false,
-				Chain: []validation.Constraint{{Target: "parameters.BlobServicePropertiesProperties.DeleteRetentionPolicy", Name: validation.Null, Rule: false,
-					Chain: []validation.Constraint{{Target: "parameters.BlobServicePropertiesProperties.DeleteRetentionPolicy.Days", Name: validation.Null, Rule: false,
-						Chain: []validation.Constraint{{Target: "parameters.BlobServicePropertiesProperties.DeleteRetentionPolicy.Days", Name: validation.InclusiveMaximum, Rule: int64(365), Chain: nil},
-							{Target: "parameters.BlobServicePropertiesProperties.DeleteRetentionPolicy.Days", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil},
-						}},
-					}},
-				}}}}}); err != nil {
-		return result, validation.NewError("storage.BlobServicesClient", "SetServiceProperties", err.Error())
-	}
-
-	req, err := client.SetServicePropertiesPreparer(ctx, resourceGroupName, accountName, parameters)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobServicesClient", "SetServiceProperties", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.SetServicePropertiesSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.BlobServicesClient", "SetServiceProperties", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.SetServicePropertiesResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.BlobServicesClient", "SetServiceProperties", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// SetServicePropertiesPreparer prepares the SetServiceProperties request.
-func (client BlobServicesClient) SetServicePropertiesPreparer(ctx context.Context, resourceGroupName string, accountName string, parameters BlobServiceProperties) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":       autorest.Encode("path", accountName),
-		"BlobServicesName":  autorest.Encode("path", "default"),
-		"resourceGroupName": autorest.Encode("path", resourceGroupName),
-		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPut(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/{BlobServicesName}", pathParameters),
-		autorest.WithJSON(parameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// SetServicePropertiesSender sends the SetServiceProperties request. The method will close the
-// http.Response Body if it receives an error.
-func (client BlobServicesClient) SetServicePropertiesSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// SetServicePropertiesResponder handles the response to the SetServiceProperties request. The method always
-// closes the http.Response Body.
-func (client BlobServicesClient) SetServicePropertiesResponder(resp *http.Response) (result BlobServiceProperties, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
diff --git a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/client.go b/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/client.go
deleted file mode 100644
index f606f71f2..000000000
--- a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/client.go
+++ /dev/null
@@ -1,52 +0,0 @@
-// Package storage implements the Azure ARM Storage service API version .
-//
-// The Azure Storage Management API.
-package storage
-
-// Copyright (c) Microsoft and contributors.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// Code generated by Microsoft (R) AutoRest Code Generator.
-// Changes may cause incorrect behavior and will be lost if the code is regenerated.
-
-import (
-	"github.com/Azure/go-autorest/autorest"
-)
-
-const (
-	// DefaultBaseURI is the default URI used for the service Storage
-	DefaultBaseURI = "https://management.azure.com"
-)
-
-// BaseClient is the base client for Storage.
-type BaseClient struct {
-	autorest.Client
-	BaseURI        string
-	SubscriptionID string
-}
-
-// New creates an instance of the BaseClient client.
-func New(subscriptionID string) BaseClient {
-	return NewWithBaseURI(DefaultBaseURI, subscriptionID)
-}
-
-// NewWithBaseURI creates an instance of the BaseClient client using a custom endpoint.  Use this when interacting with
-// an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
-func NewWithBaseURI(baseURI string, subscriptionID string) BaseClient {
-	return BaseClient{
-		Client:         autorest.NewClientWithUserAgent(UserAgent()),
-		BaseURI:        baseURI,
-		SubscriptionID: subscriptionID,
-	}
-}
diff --git a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/managementpolicies.go b/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/managementpolicies.go
deleted file mode 100644
index 317b8b2ff..000000000
--- a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/managementpolicies.go
+++ /dev/null
@@ -1,322 +0,0 @@
-package storage
-
-// Copyright (c) Microsoft and contributors.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// Code generated by Microsoft (R) AutoRest Code Generator.
-// Changes may cause incorrect behavior and will be lost if the code is regenerated.
-
-import (
-	"context"
-	"github.com/Azure/go-autorest/autorest"
-	"github.com/Azure/go-autorest/autorest/azure"
-	"github.com/Azure/go-autorest/autorest/validation"
-	"github.com/Azure/go-autorest/tracing"
-	"net/http"
-)
-
-// ManagementPoliciesClient is the the Azure Storage Management API.
-type ManagementPoliciesClient struct {
-	BaseClient
-}
-
-// NewManagementPoliciesClient creates an instance of the ManagementPoliciesClient client.
-func NewManagementPoliciesClient(subscriptionID string) ManagementPoliciesClient {
-	return NewManagementPoliciesClientWithBaseURI(DefaultBaseURI, subscriptionID)
-}
-
-// NewManagementPoliciesClientWithBaseURI creates an instance of the ManagementPoliciesClient client using a custom
-// endpoint.  Use this when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure
-// stack).
-func NewManagementPoliciesClientWithBaseURI(baseURI string, subscriptionID string) ManagementPoliciesClient {
-	return ManagementPoliciesClient{NewWithBaseURI(baseURI, subscriptionID)}
-}
-
-// CreateOrUpdate sets the data policy rules associated with the specified storage account.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-// properties - the data policy rules to set to a storage account.
-func (client ManagementPoliciesClient) CreateOrUpdate(ctx context.Context, resourceGroupName string, accountName string, properties ManagementPoliciesRulesSetParameter) (result AccountManagementPolicies, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/ManagementPoliciesClient.CreateOrUpdate")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.ManagementPoliciesClient", "CreateOrUpdate", err.Error())
-	}
-
-	req, err := client.CreateOrUpdatePreparer(ctx, resourceGroupName, accountName, properties)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.ManagementPoliciesClient", "CreateOrUpdate", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.CreateOrUpdateSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.ManagementPoliciesClient", "CreateOrUpdate", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.CreateOrUpdateResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.ManagementPoliciesClient", "CreateOrUpdate", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// CreateOrUpdatePreparer prepares the CreateOrUpdate request.
-func (client ManagementPoliciesClient) CreateOrUpdatePreparer(ctx context.Context, resourceGroupName string, accountName string, properties ManagementPoliciesRulesSetParameter) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":          autorest.Encode("path", accountName),
-		"managementPolicyName": autorest.Encode("path", "default"),
-		"resourceGroupName":    autorest.Encode("path", resourceGroupName),
-		"subscriptionId":       autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-03-01-preview"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsContentType("application/json; charset=utf-8"),
-		autorest.AsPut(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/managementPolicies/{managementPolicyName}", pathParameters),
-		autorest.WithJSON(properties),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// CreateOrUpdateSender sends the CreateOrUpdate request. The method will close the
-// http.Response Body if it receives an error.
-func (client ManagementPoliciesClient) CreateOrUpdateSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// CreateOrUpdateResponder handles the response to the CreateOrUpdate request. The method always
-// closes the http.Response Body.
-func (client ManagementPoliciesClient) CreateOrUpdateResponder(resp *http.Response) (result AccountManagementPolicies, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
-
-// Delete deletes the data policy rules associated with the specified storage account.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-func (client ManagementPoliciesClient) Delete(ctx context.Context, resourceGroupName string, accountName string) (result autorest.Response, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/ManagementPoliciesClient.Delete")
-		defer func() {
-			sc := -1
-			if result.Response != nil {
-				sc = result.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.ManagementPoliciesClient", "Delete", err.Error())
-	}
-
-	req, err := client.DeletePreparer(ctx, resourceGroupName, accountName)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.ManagementPoliciesClient", "Delete", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.DeleteSender(req)
-	if err != nil {
-		result.Response = resp
-		err = autorest.NewErrorWithError(err, "storage.ManagementPoliciesClient", "Delete", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.DeleteResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.ManagementPoliciesClient", "Delete", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// DeletePreparer prepares the Delete request.
-func (client ManagementPoliciesClient) DeletePreparer(ctx context.Context, resourceGroupName string, accountName string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":          autorest.Encode("path", accountName),
-		"managementPolicyName": autorest.Encode("path", "default"),
-		"resourceGroupName":    autorest.Encode("path", resourceGroupName),
-		"subscriptionId":       autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-03-01-preview"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsDelete(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/managementPolicies/{managementPolicyName}", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// DeleteSender sends the Delete request. The method will close the
-// http.Response Body if it receives an error.
-func (client ManagementPoliciesClient) DeleteSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// DeleteResponder handles the response to the Delete request. The method always
-// closes the http.Response Body.
-func (client ManagementPoliciesClient) DeleteResponder(resp *http.Response) (result autorest.Response, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
-		autorest.ByClosing())
-	result.Response = resp
-	return
-}
-
-// Get gets the data policy rules associated with the specified storage account.
-// Parameters:
-// resourceGroupName - the name of the resource group within the user's subscription. The name is case
-// insensitive.
-// accountName - the name of the storage account within the specified resource group. Storage account names
-// must be between 3 and 24 characters in length and use numbers and lower-case letters only.
-func (client ManagementPoliciesClient) Get(ctx context.Context, resourceGroupName string, accountName string) (result AccountManagementPolicies, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/ManagementPoliciesClient.Get")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: resourceGroupName,
-			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
-				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}},
-		{TargetValue: accountName,
-			Constraints: []validation.Constraint{{Target: "accountName", Name: validation.MaxLength, Rule: 24, Chain: nil},
-				{Target: "accountName", Name: validation.MinLength, Rule: 3, Chain: nil}}},
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.ManagementPoliciesClient", "Get", err.Error())
-	}
-
-	req, err := client.GetPreparer(ctx, resourceGroupName, accountName)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.ManagementPoliciesClient", "Get", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.GetSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.ManagementPoliciesClient", "Get", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.GetResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.ManagementPoliciesClient", "Get", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// GetPreparer prepares the Get request.
-func (client ManagementPoliciesClient) GetPreparer(ctx context.Context, resourceGroupName string, accountName string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"accountName":          autorest.Encode("path", accountName),
-		"managementPolicyName": autorest.Encode("path", "default"),
-		"resourceGroupName":    autorest.Encode("path", resourceGroupName),
-		"subscriptionId":       autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-03-01-preview"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsGet(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/managementPolicies/{managementPolicyName}", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// GetSender sends the Get request. The method will close the
-// http.Response Body if it receives an error.
-func (client ManagementPoliciesClient) GetSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// GetResponder handles the response to the Get request. The method always
-// closes the http.Response Body.
-func (client ManagementPoliciesClient) GetResponder(resp *http.Response) (result AccountManagementPolicies, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
diff --git a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/models.go b/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/models.go
deleted file mode 100644
index fa9a8acbc..000000000
--- a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/models.go
+++ /dev/null
@@ -1,2187 +0,0 @@
-package storage
-
-// Copyright (c) Microsoft and contributors.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// Code generated by Microsoft (R) AutoRest Code Generator.
-// Changes may cause incorrect behavior and will be lost if the code is regenerated.
-
-import (
-	"context"
-	"encoding/json"
-	"github.com/Azure/go-autorest/autorest"
-	"github.com/Azure/go-autorest/autorest/azure"
-	"github.com/Azure/go-autorest/autorest/date"
-	"net/http"
-)
-
-// The package's fully qualified name.
-const fqdn = "github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage"
-
-// AccessTier enumerates the values for access tier.
-type AccessTier string
-
-const (
-	// Cool ...
-	Cool AccessTier = "Cool"
-	// Hot ...
-	Hot AccessTier = "Hot"
-)
-
-// PossibleAccessTierValues returns an array of possible values for the AccessTier const type.
-func PossibleAccessTierValues() []AccessTier {
-	return []AccessTier{Cool, Hot}
-}
-
-// AccountExpand enumerates the values for account expand.
-type AccountExpand string
-
-const (
-	// AccountExpandGeoReplicationStats ...
-	AccountExpandGeoReplicationStats AccountExpand = "geoReplicationStats"
-)
-
-// PossibleAccountExpandValues returns an array of possible values for the AccountExpand const type.
-func PossibleAccountExpandValues() []AccountExpand {
-	return []AccountExpand{AccountExpandGeoReplicationStats}
-}
-
-// AccountStatus enumerates the values for account status.
-type AccountStatus string
-
-const (
-	// Available ...
-	Available AccountStatus = "available"
-	// Unavailable ...
-	Unavailable AccountStatus = "unavailable"
-)
-
-// PossibleAccountStatusValues returns an array of possible values for the AccountStatus const type.
-func PossibleAccountStatusValues() []AccountStatus {
-	return []AccountStatus{Available, Unavailable}
-}
-
-// Action enumerates the values for action.
-type Action string
-
-const (
-	// Allow ...
-	Allow Action = "Allow"
-)
-
-// PossibleActionValues returns an array of possible values for the Action const type.
-func PossibleActionValues() []Action {
-	return []Action{Allow}
-}
-
-// Action1 enumerates the values for action 1.
-type Action1 string
-
-const (
-	// Acquire ...
-	Acquire Action1 = "Acquire"
-	// Break ...
-	Break Action1 = "Break"
-	// Change ...
-	Change Action1 = "Change"
-	// Release ...
-	Release Action1 = "Release"
-	// Renew ...
-	Renew Action1 = "Renew"
-)
-
-// PossibleAction1Values returns an array of possible values for the Action1 const type.
-func PossibleAction1Values() []Action1 {
-	return []Action1{Acquire, Break, Change, Release, Renew}
-}
-
-// Bypass enumerates the values for bypass.
-type Bypass string
-
-const (
-	// AzureServices ...
-	AzureServices Bypass = "AzureServices"
-	// Logging ...
-	Logging Bypass = "Logging"
-	// Metrics ...
-	Metrics Bypass = "Metrics"
-	// None ...
-	None Bypass = "None"
-)
-
-// PossibleBypassValues returns an array of possible values for the Bypass const type.
-func PossibleBypassValues() []Bypass {
-	return []Bypass{AzureServices, Logging, Metrics, None}
-}
-
-// DefaultAction enumerates the values for default action.
-type DefaultAction string
-
-const (
-	// DefaultActionAllow ...
-	DefaultActionAllow DefaultAction = "Allow"
-	// DefaultActionDeny ...
-	DefaultActionDeny DefaultAction = "Deny"
-)
-
-// PossibleDefaultActionValues returns an array of possible values for the DefaultAction const type.
-func PossibleDefaultActionValues() []DefaultAction {
-	return []DefaultAction{DefaultActionAllow, DefaultActionDeny}
-}
-
-// GeoReplicationStatus enumerates the values for geo replication status.
-type GeoReplicationStatus string
-
-const (
-	// GeoReplicationStatusBootstrap ...
-	GeoReplicationStatusBootstrap GeoReplicationStatus = "Bootstrap"
-	// GeoReplicationStatusLive ...
-	GeoReplicationStatusLive GeoReplicationStatus = "Live"
-	// GeoReplicationStatusUnavailable ...
-	GeoReplicationStatusUnavailable GeoReplicationStatus = "Unavailable"
-)
-
-// PossibleGeoReplicationStatusValues returns an array of possible values for the GeoReplicationStatus const type.
-func PossibleGeoReplicationStatusValues() []GeoReplicationStatus {
-	return []GeoReplicationStatus{GeoReplicationStatusBootstrap, GeoReplicationStatusLive, GeoReplicationStatusUnavailable}
-}
-
-// HTTPProtocol enumerates the values for http protocol.
-type HTTPProtocol string
-
-const (
-	// HTTPS ...
-	HTTPS HTTPProtocol = "https"
-	// Httpshttp ...
-	Httpshttp HTTPProtocol = "https,http"
-)
-
-// PossibleHTTPProtocolValues returns an array of possible values for the HTTPProtocol const type.
-func PossibleHTTPProtocolValues() []HTTPProtocol {
-	return []HTTPProtocol{HTTPS, Httpshttp}
-}
-
-// ImmutabilityPolicyState enumerates the values for immutability policy state.
-type ImmutabilityPolicyState string
-
-const (
-	// Locked ...
-	Locked ImmutabilityPolicyState = "Locked"
-	// Unlocked ...
-	Unlocked ImmutabilityPolicyState = "Unlocked"
-)
-
-// PossibleImmutabilityPolicyStateValues returns an array of possible values for the ImmutabilityPolicyState const type.
-func PossibleImmutabilityPolicyStateValues() []ImmutabilityPolicyState {
-	return []ImmutabilityPolicyState{Locked, Unlocked}
-}
-
-// ImmutabilityPolicyUpdateType enumerates the values for immutability policy update type.
-type ImmutabilityPolicyUpdateType string
-
-const (
-	// Extend ...
-	Extend ImmutabilityPolicyUpdateType = "extend"
-	// Lock ...
-	Lock ImmutabilityPolicyUpdateType = "lock"
-	// Put ...
-	Put ImmutabilityPolicyUpdateType = "put"
-)
-
-// PossibleImmutabilityPolicyUpdateTypeValues returns an array of possible values for the ImmutabilityPolicyUpdateType const type.
-func PossibleImmutabilityPolicyUpdateTypeValues() []ImmutabilityPolicyUpdateType {
-	return []ImmutabilityPolicyUpdateType{Extend, Lock, Put}
-}
-
-// KeyPermission enumerates the values for key permission.
-type KeyPermission string
-
-const (
-	// Full ...
-	Full KeyPermission = "Full"
-	// Read ...
-	Read KeyPermission = "Read"
-)
-
-// PossibleKeyPermissionValues returns an array of possible values for the KeyPermission const type.
-func PossibleKeyPermissionValues() []KeyPermission {
-	return []KeyPermission{Full, Read}
-}
-
-// KeySource enumerates the values for key source.
-type KeySource string
-
-const (
-	// MicrosoftKeyvault ...
-	MicrosoftKeyvault KeySource = "Microsoft.Keyvault"
-	// MicrosoftStorage ...
-	MicrosoftStorage KeySource = "Microsoft.Storage"
-)
-
-// PossibleKeySourceValues returns an array of possible values for the KeySource const type.
-func PossibleKeySourceValues() []KeySource {
-	return []KeySource{MicrosoftKeyvault, MicrosoftStorage}
-}
-
-// Kind enumerates the values for kind.
-type Kind string
-
-const (
-	// BlobStorage ...
-	BlobStorage Kind = "BlobStorage"
-	// BlockBlobStorage ...
-	BlockBlobStorage Kind = "BlockBlobStorage"
-	// FileStorage ...
-	FileStorage Kind = "FileStorage"
-	// Storage ...
-	Storage Kind = "Storage"
-	// StorageV2 ...
-	StorageV2 Kind = "StorageV2"
-)
-
-// PossibleKindValues returns an array of possible values for the Kind const type.
-func PossibleKindValues() []Kind {
-	return []Kind{BlobStorage, BlockBlobStorage, FileStorage, Storage, StorageV2}
-}
-
-// LeaseDuration enumerates the values for lease duration.
-type LeaseDuration string
-
-const (
-	// Fixed ...
-	Fixed LeaseDuration = "Fixed"
-	// Infinite ...
-	Infinite LeaseDuration = "Infinite"
-)
-
-// PossibleLeaseDurationValues returns an array of possible values for the LeaseDuration const type.
-func PossibleLeaseDurationValues() []LeaseDuration {
-	return []LeaseDuration{Fixed, Infinite}
-}
-
-// LeaseState enumerates the values for lease state.
-type LeaseState string
-
-const (
-	// LeaseStateAvailable ...
-	LeaseStateAvailable LeaseState = "Available"
-	// LeaseStateBreaking ...
-	LeaseStateBreaking LeaseState = "Breaking"
-	// LeaseStateBroken ...
-	LeaseStateBroken LeaseState = "Broken"
-	// LeaseStateExpired ...
-	LeaseStateExpired LeaseState = "Expired"
-	// LeaseStateLeased ...
-	LeaseStateLeased LeaseState = "Leased"
-)
-
-// PossibleLeaseStateValues returns an array of possible values for the LeaseState const type.
-func PossibleLeaseStateValues() []LeaseState {
-	return []LeaseState{LeaseStateAvailable, LeaseStateBreaking, LeaseStateBroken, LeaseStateExpired, LeaseStateLeased}
-}
-
-// LeaseStatus enumerates the values for lease status.
-type LeaseStatus string
-
-const (
-	// LeaseStatusLocked ...
-	LeaseStatusLocked LeaseStatus = "Locked"
-	// LeaseStatusUnlocked ...
-	LeaseStatusUnlocked LeaseStatus = "Unlocked"
-)
-
-// PossibleLeaseStatusValues returns an array of possible values for the LeaseStatus const type.
-func PossibleLeaseStatusValues() []LeaseStatus {
-	return []LeaseStatus{LeaseStatusLocked, LeaseStatusUnlocked}
-}
-
-// Permissions enumerates the values for permissions.
-type Permissions string
-
-const (
-	// A ...
-	A Permissions = "a"
-	// C ...
-	C Permissions = "c"
-	// D ...
-	D Permissions = "d"
-	// L ...
-	L Permissions = "l"
-	// P ...
-	P Permissions = "p"
-	// R ...
-	R Permissions = "r"
-	// U ...
-	U Permissions = "u"
-	// W ...
-	W Permissions = "w"
-)
-
-// PossiblePermissionsValues returns an array of possible values for the Permissions const type.
-func PossiblePermissionsValues() []Permissions {
-	return []Permissions{A, C, D, L, P, R, U, W}
-}
-
-// ProvisioningState enumerates the values for provisioning state.
-type ProvisioningState string
-
-const (
-	// Creating ...
-	Creating ProvisioningState = "Creating"
-	// ResolvingDNS ...
-	ResolvingDNS ProvisioningState = "ResolvingDNS"
-	// Succeeded ...
-	Succeeded ProvisioningState = "Succeeded"
-)
-
-// PossibleProvisioningStateValues returns an array of possible values for the ProvisioningState const type.
-func PossibleProvisioningStateValues() []ProvisioningState {
-	return []ProvisioningState{Creating, ResolvingDNS, Succeeded}
-}
-
-// PublicAccess enumerates the values for public access.
-type PublicAccess string
-
-const (
-	// PublicAccessBlob ...
-	PublicAccessBlob PublicAccess = "Blob"
-	// PublicAccessContainer ...
-	PublicAccessContainer PublicAccess = "Container"
-	// PublicAccessNone ...
-	PublicAccessNone PublicAccess = "None"
-)
-
-// PossiblePublicAccessValues returns an array of possible values for the PublicAccess const type.
-func PossiblePublicAccessValues() []PublicAccess {
-	return []PublicAccess{PublicAccessBlob, PublicAccessContainer, PublicAccessNone}
-}
-
-// Reason enumerates the values for reason.
-type Reason string
-
-const (
-	// AccountNameInvalid ...
-	AccountNameInvalid Reason = "AccountNameInvalid"
-	// AlreadyExists ...
-	AlreadyExists Reason = "AlreadyExists"
-)
-
-// PossibleReasonValues returns an array of possible values for the Reason const type.
-func PossibleReasonValues() []Reason {
-	return []Reason{AccountNameInvalid, AlreadyExists}
-}
-
-// ReasonCode enumerates the values for reason code.
-type ReasonCode string
-
-const (
-	// NotAvailableForSubscription ...
-	NotAvailableForSubscription ReasonCode = "NotAvailableForSubscription"
-	// QuotaID ...
-	QuotaID ReasonCode = "QuotaId"
-)
-
-// PossibleReasonCodeValues returns an array of possible values for the ReasonCode const type.
-func PossibleReasonCodeValues() []ReasonCode {
-	return []ReasonCode{NotAvailableForSubscription, QuotaID}
-}
-
-// Services enumerates the values for services.
-type Services string
-
-const (
-	// B ...
-	B Services = "b"
-	// F ...
-	F Services = "f"
-	// Q ...
-	Q Services = "q"
-	// T ...
-	T Services = "t"
-)
-
-// PossibleServicesValues returns an array of possible values for the Services const type.
-func PossibleServicesValues() []Services {
-	return []Services{B, F, Q, T}
-}
-
-// SignedResource enumerates the values for signed resource.
-type SignedResource string
-
-const (
-	// SignedResourceB ...
-	SignedResourceB SignedResource = "b"
-	// SignedResourceC ...
-	SignedResourceC SignedResource = "c"
-	// SignedResourceF ...
-	SignedResourceF SignedResource = "f"
-	// SignedResourceS ...
-	SignedResourceS SignedResource = "s"
-)
-
-// PossibleSignedResourceValues returns an array of possible values for the SignedResource const type.
-func PossibleSignedResourceValues() []SignedResource {
-	return []SignedResource{SignedResourceB, SignedResourceC, SignedResourceF, SignedResourceS}
-}
-
-// SignedResourceTypes enumerates the values for signed resource types.
-type SignedResourceTypes string
-
-const (
-	// SignedResourceTypesC ...
-	SignedResourceTypesC SignedResourceTypes = "c"
-	// SignedResourceTypesO ...
-	SignedResourceTypesO SignedResourceTypes = "o"
-	// SignedResourceTypesS ...
-	SignedResourceTypesS SignedResourceTypes = "s"
-)
-
-// PossibleSignedResourceTypesValues returns an array of possible values for the SignedResourceTypes const type.
-func PossibleSignedResourceTypesValues() []SignedResourceTypes {
-	return []SignedResourceTypes{SignedResourceTypesC, SignedResourceTypesO, SignedResourceTypesS}
-}
-
-// SkuName enumerates the values for sku name.
-type SkuName string
-
-const (
-	// PremiumLRS ...
-	PremiumLRS SkuName = "Premium_LRS"
-	// PremiumZRS ...
-	PremiumZRS SkuName = "Premium_ZRS"
-	// StandardGRS ...
-	StandardGRS SkuName = "Standard_GRS"
-	// StandardLRS ...
-	StandardLRS SkuName = "Standard_LRS"
-	// StandardRAGRS ...
-	StandardRAGRS SkuName = "Standard_RAGRS"
-	// StandardZRS ...
-	StandardZRS SkuName = "Standard_ZRS"
-)
-
-// PossibleSkuNameValues returns an array of possible values for the SkuName const type.
-func PossibleSkuNameValues() []SkuName {
-	return []SkuName{PremiumLRS, PremiumZRS, StandardGRS, StandardLRS, StandardRAGRS, StandardZRS}
-}
-
-// SkuTier enumerates the values for sku tier.
-type SkuTier string
-
-const (
-	// Premium ...
-	Premium SkuTier = "Premium"
-	// Standard ...
-	Standard SkuTier = "Standard"
-)
-
-// PossibleSkuTierValues returns an array of possible values for the SkuTier const type.
-func PossibleSkuTierValues() []SkuTier {
-	return []SkuTier{Premium, Standard}
-}
-
-// State enumerates the values for state.
-type State string
-
-const (
-	// StateDeprovisioning ...
-	StateDeprovisioning State = "deprovisioning"
-	// StateFailed ...
-	StateFailed State = "failed"
-	// StateNetworkSourceDeleted ...
-	StateNetworkSourceDeleted State = "networkSourceDeleted"
-	// StateProvisioning ...
-	StateProvisioning State = "provisioning"
-	// StateSucceeded ...
-	StateSucceeded State = "succeeded"
-)
-
-// PossibleStateValues returns an array of possible values for the State const type.
-func PossibleStateValues() []State {
-	return []State{StateDeprovisioning, StateFailed, StateNetworkSourceDeleted, StateProvisioning, StateSucceeded}
-}
-
-// UsageUnit enumerates the values for usage unit.
-type UsageUnit string
-
-const (
-	// Bytes ...
-	Bytes UsageUnit = "Bytes"
-	// BytesPerSecond ...
-	BytesPerSecond UsageUnit = "BytesPerSecond"
-	// Count ...
-	Count UsageUnit = "Count"
-	// CountsPerSecond ...
-	CountsPerSecond UsageUnit = "CountsPerSecond"
-	// Percent ...
-	Percent UsageUnit = "Percent"
-	// Seconds ...
-	Seconds UsageUnit = "Seconds"
-)
-
-// PossibleUsageUnitValues returns an array of possible values for the UsageUnit const type.
-func PossibleUsageUnitValues() []UsageUnit {
-	return []UsageUnit{Bytes, BytesPerSecond, Count, CountsPerSecond, Percent, Seconds}
-}
-
-// Account the storage account.
-type Account struct {
-	autorest.Response `json:"-"`
-	// Sku - READ-ONLY; Gets the SKU.
-	Sku *Sku `json:"sku,omitempty"`
-	// Kind - READ-ONLY; Gets the Kind. Possible values include: 'Storage', 'StorageV2', 'BlobStorage', 'FileStorage', 'BlockBlobStorage'
-	Kind Kind `json:"kind,omitempty"`
-	// Identity - The identity of the resource.
-	Identity *Identity `json:"identity,omitempty"`
-	// AccountProperties - Properties of the storage account.
-	*AccountProperties `json:"properties,omitempty"`
-	// Tags - Resource tags.
-	Tags map[string]*string `json:"tags"`
-	// Location - The geo-location where the resource lives
-	Location *string `json:"location,omitempty"`
-	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
-	ID *string `json:"id,omitempty"`
-	// Name - READ-ONLY; The name of the resource
-	Name *string `json:"name,omitempty"`
-	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
-	Type *string `json:"type,omitempty"`
-}
-
-// MarshalJSON is the custom marshaler for Account.
-func (a Account) MarshalJSON() ([]byte, error) {
-	objectMap := make(map[string]interface{})
-	if a.Identity != nil {
-		objectMap["identity"] = a.Identity
-	}
-	if a.AccountProperties != nil {
-		objectMap["properties"] = a.AccountProperties
-	}
-	if a.Tags != nil {
-		objectMap["tags"] = a.Tags
-	}
-	if a.Location != nil {
-		objectMap["location"] = a.Location
-	}
-	return json.Marshal(objectMap)
-}
-
-// UnmarshalJSON is the custom unmarshaler for Account struct.
-func (a *Account) UnmarshalJSON(body []byte) error {
-	var m map[string]*json.RawMessage
-	err := json.Unmarshal(body, &m)
-	if err != nil {
-		return err
-	}
-	for k, v := range m {
-		switch k {
-		case "sku":
-			if v != nil {
-				var sku Sku
-				err = json.Unmarshal(*v, &sku)
-				if err != nil {
-					return err
-				}
-				a.Sku = &sku
-			}
-		case "kind":
-			if v != nil {
-				var kind Kind
-				err = json.Unmarshal(*v, &kind)
-				if err != nil {
-					return err
-				}
-				a.Kind = kind
-			}
-		case "identity":
-			if v != nil {
-				var identity Identity
-				err = json.Unmarshal(*v, &identity)
-				if err != nil {
-					return err
-				}
-				a.Identity = &identity
-			}
-		case "properties":
-			if v != nil {
-				var accountProperties AccountProperties
-				err = json.Unmarshal(*v, &accountProperties)
-				if err != nil {
-					return err
-				}
-				a.AccountProperties = &accountProperties
-			}
-		case "tags":
-			if v != nil {
-				var tags map[string]*string
-				err = json.Unmarshal(*v, &tags)
-				if err != nil {
-					return err
-				}
-				a.Tags = tags
-			}
-		case "location":
-			if v != nil {
-				var location string
-				err = json.Unmarshal(*v, &location)
-				if err != nil {
-					return err
-				}
-				a.Location = &location
-			}
-		case "id":
-			if v != nil {
-				var ID string
-				err = json.Unmarshal(*v, &ID)
-				if err != nil {
-					return err
-				}
-				a.ID = &ID
-			}
-		case "name":
-			if v != nil {
-				var name string
-				err = json.Unmarshal(*v, &name)
-				if err != nil {
-					return err
-				}
-				a.Name = &name
-			}
-		case "type":
-			if v != nil {
-				var typeVar string
-				err = json.Unmarshal(*v, &typeVar)
-				if err != nil {
-					return err
-				}
-				a.Type = &typeVar
-			}
-		}
-	}
-
-	return nil
-}
-
-// AccountCheckNameAvailabilityParameters the parameters used to check the availability of the storage
-// account name.
-type AccountCheckNameAvailabilityParameters struct {
-	// Name - The storage account name.
-	Name *string `json:"name,omitempty"`
-	// Type - The type of resource, Microsoft.Storage/storageAccounts
-	Type *string `json:"type,omitempty"`
-}
-
-// AccountCreateParameters the parameters used when creating a storage account.
-type AccountCreateParameters struct {
-	// Sku - Required. Gets or sets the SKU name.
-	Sku *Sku `json:"sku,omitempty"`
-	// Kind - Required. Indicates the type of storage account. Possible values include: 'Storage', 'StorageV2', 'BlobStorage', 'FileStorage', 'BlockBlobStorage'
-	Kind Kind `json:"kind,omitempty"`
-	// Location - Required. Gets or sets the location of the resource. This will be one of the supported and registered Azure Geo Regions (e.g. West US, East US, Southeast Asia, etc.). The geo region of a resource cannot be changed once it is created, but if an identical geo region is specified on update, the request will succeed.
-	Location *string `json:"location,omitempty"`
-	// Tags - Gets or sets a list of key value pairs that describe the resource. These tags can be used for viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key with a length no greater than 128 characters and a value with a length no greater than 256 characters.
-	Tags map[string]*string `json:"tags"`
-	// Identity - The identity of the resource.
-	Identity *Identity `json:"identity,omitempty"`
-	// AccountPropertiesCreateParameters - The parameters used to create the storage account.
-	*AccountPropertiesCreateParameters `json:"properties,omitempty"`
-}
-
-// MarshalJSON is the custom marshaler for AccountCreateParameters.
-func (acp AccountCreateParameters) MarshalJSON() ([]byte, error) {
-	objectMap := make(map[string]interface{})
-	if acp.Sku != nil {
-		objectMap["sku"] = acp.Sku
-	}
-	if acp.Kind != "" {
-		objectMap["kind"] = acp.Kind
-	}
-	if acp.Location != nil {
-		objectMap["location"] = acp.Location
-	}
-	if acp.Tags != nil {
-		objectMap["tags"] = acp.Tags
-	}
-	if acp.Identity != nil {
-		objectMap["identity"] = acp.Identity
-	}
-	if acp.AccountPropertiesCreateParameters != nil {
-		objectMap["properties"] = acp.AccountPropertiesCreateParameters
-	}
-	return json.Marshal(objectMap)
-}
-
-// UnmarshalJSON is the custom unmarshaler for AccountCreateParameters struct.
-func (acp *AccountCreateParameters) UnmarshalJSON(body []byte) error {
-	var m map[string]*json.RawMessage
-	err := json.Unmarshal(body, &m)
-	if err != nil {
-		return err
-	}
-	for k, v := range m {
-		switch k {
-		case "sku":
-			if v != nil {
-				var sku Sku
-				err = json.Unmarshal(*v, &sku)
-				if err != nil {
-					return err
-				}
-				acp.Sku = &sku
-			}
-		case "kind":
-			if v != nil {
-				var kind Kind
-				err = json.Unmarshal(*v, &kind)
-				if err != nil {
-					return err
-				}
-				acp.Kind = kind
-			}
-		case "location":
-			if v != nil {
-				var location string
-				err = json.Unmarshal(*v, &location)
-				if err != nil {
-					return err
-				}
-				acp.Location = &location
-			}
-		case "tags":
-			if v != nil {
-				var tags map[string]*string
-				err = json.Unmarshal(*v, &tags)
-				if err != nil {
-					return err
-				}
-				acp.Tags = tags
-			}
-		case "identity":
-			if v != nil {
-				var identity Identity
-				err = json.Unmarshal(*v, &identity)
-				if err != nil {
-					return err
-				}
-				acp.Identity = &identity
-			}
-		case "properties":
-			if v != nil {
-				var accountPropertiesCreateParameters AccountPropertiesCreateParameters
-				err = json.Unmarshal(*v, &accountPropertiesCreateParameters)
-				if err != nil {
-					return err
-				}
-				acp.AccountPropertiesCreateParameters = &accountPropertiesCreateParameters
-			}
-		}
-	}
-
-	return nil
-}
-
-// AccountKey an access key for the storage account.
-type AccountKey struct {
-	// KeyName - READ-ONLY; Name of the key.
-	KeyName *string `json:"keyName,omitempty"`
-	// Value - READ-ONLY; Base 64-encoded value of the key.
-	Value *string `json:"value,omitempty"`
-	// Permissions - READ-ONLY; Permissions for the key -- read-only or full permissions. Possible values include: 'Read', 'Full'
-	Permissions KeyPermission `json:"permissions,omitempty"`
-}
-
-// AccountListKeysResult the response from the ListKeys operation.
-type AccountListKeysResult struct {
-	autorest.Response `json:"-"`
-	// Keys - READ-ONLY; Gets the list of storage account keys and their properties for the specified storage account.
-	Keys *[]AccountKey `json:"keys,omitempty"`
-}
-
-// AccountListResult the response from the List Storage Accounts operation.
-type AccountListResult struct {
-	autorest.Response `json:"-"`
-	// Value - READ-ONLY; Gets the list of storage accounts and their properties.
-	Value *[]Account `json:"value,omitempty"`
-}
-
-// AccountManagementPolicies the Get Storage Account ManagementPolicies operation response.
-type AccountManagementPolicies struct {
-	autorest.Response `json:"-"`
-	// AccountManagementPoliciesRulesProperty - READ-ONLY; Returns the Storage Account Data Policies Rules.
-	*AccountManagementPoliciesRulesProperty `json:"properties,omitempty"`
-	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
-	ID *string `json:"id,omitempty"`
-	// Name - READ-ONLY; The name of the resource
-	Name *string `json:"name,omitempty"`
-	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
-	Type *string `json:"type,omitempty"`
-}
-
-// MarshalJSON is the custom marshaler for AccountManagementPolicies.
-func (amp AccountManagementPolicies) MarshalJSON() ([]byte, error) {
-	objectMap := make(map[string]interface{})
-	return json.Marshal(objectMap)
-}
-
-// UnmarshalJSON is the custom unmarshaler for AccountManagementPolicies struct.
-func (amp *AccountManagementPolicies) UnmarshalJSON(body []byte) error {
-	var m map[string]*json.RawMessage
-	err := json.Unmarshal(body, &m)
-	if err != nil {
-		return err
-	}
-	for k, v := range m {
-		switch k {
-		case "properties":
-			if v != nil {
-				var accountManagementPoliciesRulesProperty AccountManagementPoliciesRulesProperty
-				err = json.Unmarshal(*v, &accountManagementPoliciesRulesProperty)
-				if err != nil {
-					return err
-				}
-				amp.AccountManagementPoliciesRulesProperty = &accountManagementPoliciesRulesProperty
-			}
-		case "id":
-			if v != nil {
-				var ID string
-				err = json.Unmarshal(*v, &ID)
-				if err != nil {
-					return err
-				}
-				amp.ID = &ID
-			}
-		case "name":
-			if v != nil {
-				var name string
-				err = json.Unmarshal(*v, &name)
-				if err != nil {
-					return err
-				}
-				amp.Name = &name
-			}
-		case "type":
-			if v != nil {
-				var typeVar string
-				err = json.Unmarshal(*v, &typeVar)
-				if err != nil {
-					return err
-				}
-				amp.Type = &typeVar
-			}
-		}
-	}
-
-	return nil
-}
-
-// AccountManagementPoliciesRulesProperty the Storage Account Data Policies properties.
-type AccountManagementPoliciesRulesProperty struct {
-	// LastModifiedTime - READ-ONLY; Returns the date and time the ManagementPolicies was last modified.
-	LastModifiedTime *date.Time `json:"lastModifiedTime,omitempty"`
-	// Policy - The Storage Account ManagementPolicies Rules, in JSON format. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
-	Policy interface{} `json:"policy,omitempty"`
-}
-
-// AccountProperties properties of the storage account.
-type AccountProperties struct {
-	// ProvisioningState - READ-ONLY; Gets the status of the storage account at the time the operation was called. Possible values include: 'Creating', 'ResolvingDNS', 'Succeeded'
-	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
-	// PrimaryEndpoints - READ-ONLY; Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object. Note that Standard_ZRS and Premium_LRS accounts only return the blob endpoint.
-	PrimaryEndpoints *Endpoints `json:"primaryEndpoints,omitempty"`
-	// PrimaryLocation - READ-ONLY; Gets the location of the primary data center for the storage account.
-	PrimaryLocation *string `json:"primaryLocation,omitempty"`
-	// StatusOfPrimary - READ-ONLY; Gets the status indicating whether the primary location of the storage account is available or unavailable. Possible values include: 'Available', 'Unavailable'
-	StatusOfPrimary AccountStatus `json:"statusOfPrimary,omitempty"`
-	// LastGeoFailoverTime - READ-ONLY; Gets the timestamp of the most recent instance of a failover to the secondary location. Only the most recent timestamp is retained. This element is not returned if there has never been a failover instance. Only available if the accountType is Standard_GRS or Standard_RAGRS.
-	LastGeoFailoverTime *date.Time `json:"lastGeoFailoverTime,omitempty"`
-	// SecondaryLocation - READ-ONLY; Gets the location of the geo-replicated secondary for the storage account. Only available if the accountType is Standard_GRS or Standard_RAGRS.
-	SecondaryLocation *string `json:"secondaryLocation,omitempty"`
-	// StatusOfSecondary - READ-ONLY; Gets the status indicating whether the secondary location of the storage account is available or unavailable. Only available if the SKU name is Standard_GRS or Standard_RAGRS. Possible values include: 'Available', 'Unavailable'
-	StatusOfSecondary AccountStatus `json:"statusOfSecondary,omitempty"`
-	// CreationTime - READ-ONLY; Gets the creation date and time of the storage account in UTC.
-	CreationTime *date.Time `json:"creationTime,omitempty"`
-	// CustomDomain - READ-ONLY; Gets the custom domain the user assigned to this storage account.
-	CustomDomain *CustomDomain `json:"customDomain,omitempty"`
-	// SecondaryEndpoints - READ-ONLY; Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object from the secondary location of the storage account. Only available if the SKU name is Standard_RAGRS.
-	SecondaryEndpoints *Endpoints `json:"secondaryEndpoints,omitempty"`
-	// Encryption - READ-ONLY; Gets the encryption settings on the account. If unspecified, the account is unencrypted.
-	Encryption *Encryption `json:"encryption,omitempty"`
-	// AccessTier - READ-ONLY; Required for storage accounts where kind = BlobStorage. The access tier used for billing. Possible values include: 'Hot', 'Cool'
-	AccessTier AccessTier `json:"accessTier,omitempty"`
-	// EnableAzureFilesAadIntegration - Enables Azure Files AAD Integration for SMB if sets to true.
-	EnableAzureFilesAadIntegration *bool `json:"azureFilesAadIntegration,omitempty"`
-	// EnableHTTPSTrafficOnly - Allows https traffic only to storage service if sets to true.
-	EnableHTTPSTrafficOnly *bool `json:"supportsHttpsTrafficOnly,omitempty"`
-	// NetworkRuleSet - READ-ONLY; Network rule set
-	NetworkRuleSet *NetworkRuleSet `json:"networkAcls,omitempty"`
-	// IsHnsEnabled - Account HierarchicalNamespace enabled if sets to true.
-	IsHnsEnabled *bool `json:"isHnsEnabled,omitempty"`
-	// GeoReplicationStats - READ-ONLY; Geo Replication Stats
-	GeoReplicationStats *GeoReplicationStats `json:"geoReplicationStats,omitempty"`
-	// FailoverInProgress - READ-ONLY; If the failover is in progress, the value will be true, otherwise, it will be null.
-	FailoverInProgress *bool `json:"failoverInProgress,omitempty"`
-}
-
-// AccountPropertiesCreateParameters the parameters used to create the storage account.
-type AccountPropertiesCreateParameters struct {
-	// CustomDomain - User domain assigned to the storage account. Name is the CNAME source. Only one custom domain is supported per storage account at this time. To clear the existing custom domain, use an empty string for the custom domain name property.
-	CustomDomain *CustomDomain `json:"customDomain,omitempty"`
-	// Encryption - Provides the encryption settings on the account. If left unspecified the account encryption settings will remain the same. The default setting is unencrypted.
-	Encryption *Encryption `json:"encryption,omitempty"`
-	// NetworkRuleSet - Network rule set
-	NetworkRuleSet *NetworkRuleSet `json:"networkAcls,omitempty"`
-	// AccessTier - Required for storage accounts where kind = BlobStorage. The access tier used for billing. Possible values include: 'Hot', 'Cool'
-	AccessTier AccessTier `json:"accessTier,omitempty"`
-	// EnableAzureFilesAadIntegration - Enables Azure Files AAD Integration for SMB if sets to true.
-	EnableAzureFilesAadIntegration *bool `json:"azureFilesAadIntegration,omitempty"`
-	// EnableHTTPSTrafficOnly - Allows https traffic only to storage service if sets to true.
-	EnableHTTPSTrafficOnly *bool `json:"supportsHttpsTrafficOnly,omitempty"`
-	// IsHnsEnabled - Account HierarchicalNamespace enabled if sets to true.
-	IsHnsEnabled *bool `json:"isHnsEnabled,omitempty"`
-}
-
-// AccountPropertiesUpdateParameters the parameters used when updating a storage account.
-type AccountPropertiesUpdateParameters struct {
-	// CustomDomain - Custom domain assigned to the storage account by the user. Name is the CNAME source. Only one custom domain is supported per storage account at this time. To clear the existing custom domain, use an empty string for the custom domain name property.
-	CustomDomain *CustomDomain `json:"customDomain,omitempty"`
-	// Encryption - Provides the encryption settings on the account. The default setting is unencrypted.
-	Encryption *Encryption `json:"encryption,omitempty"`
-	// AccessTier - Required for storage accounts where kind = BlobStorage. The access tier used for billing. Possible values include: 'Hot', 'Cool'
-	AccessTier AccessTier `json:"accessTier,omitempty"`
-	// EnableAzureFilesAadIntegration - Enables Azure Files AAD Integration for SMB if sets to true.
-	EnableAzureFilesAadIntegration *bool `json:"azureFilesAadIntegration,omitempty"`
-	// EnableHTTPSTrafficOnly - Allows https traffic only to storage service if sets to true.
-	EnableHTTPSTrafficOnly *bool `json:"supportsHttpsTrafficOnly,omitempty"`
-	// NetworkRuleSet - Network rule set
-	NetworkRuleSet *NetworkRuleSet `json:"networkAcls,omitempty"`
-}
-
-// AccountRegenerateKeyParameters the parameters used to regenerate the storage account key.
-type AccountRegenerateKeyParameters struct {
-	// KeyName - The name of storage keys that want to be regenerated, possible values are key1, key2.
-	KeyName *string `json:"keyName,omitempty"`
-}
-
-// AccountSasParameters the parameters to list SAS credentials of a storage account.
-type AccountSasParameters struct {
-	// Services - The signed services accessible with the account SAS. Possible values include: Blob (b), Queue (q), Table (t), File (f). Possible values include: 'B', 'Q', 'T', 'F'
-	Services Services `json:"signedServices,omitempty"`
-	// ResourceTypes - The signed resource types that are accessible with the account SAS. Service (s): Access to service-level APIs; Container (c): Access to container-level APIs; Object (o): Access to object-level APIs for blobs, queue messages, table entities, and files. Possible values include: 'SignedResourceTypesS', 'SignedResourceTypesC', 'SignedResourceTypesO'
-	ResourceTypes SignedResourceTypes `json:"signedResourceTypes,omitempty"`
-	// Permissions - The signed permissions for the account SAS. Possible values include: Read (r), Write (w), Delete (d), List (l), Add (a), Create (c), Update (u) and Process (p). Possible values include: 'R', 'D', 'W', 'L', 'A', 'C', 'U', 'P'
-	Permissions Permissions `json:"signedPermission,omitempty"`
-	// IPAddressOrRange - An IP address or a range of IP addresses from which to accept requests.
-	IPAddressOrRange *string `json:"signedIp,omitempty"`
-	// Protocols - The protocol permitted for a request made with the account SAS. Possible values include: 'Httpshttp', 'HTTPS'
-	Protocols HTTPProtocol `json:"signedProtocol,omitempty"`
-	// SharedAccessStartTime - The time at which the SAS becomes valid.
-	SharedAccessStartTime *date.Time `json:"signedStart,omitempty"`
-	// SharedAccessExpiryTime - The time at which the shared access signature becomes invalid.
-	SharedAccessExpiryTime *date.Time `json:"signedExpiry,omitempty"`
-	// KeyToSign - The key to sign the account SAS token with.
-	KeyToSign *string `json:"keyToSign,omitempty"`
-}
-
-// AccountsCreateFuture an abstraction for monitoring and retrieving the results of a long-running
-// operation.
-type AccountsCreateFuture struct {
-	azure.Future
-}
-
-// Result returns the result of the asynchronous operation.
-// If the operation has not completed it will return an error.
-func (future *AccountsCreateFuture) Result(client AccountsClient) (a Account, err error) {
-	var done bool
-	done, err = future.DoneWithContext(context.Background(), client)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsCreateFuture", "Result", future.Response(), "Polling failure")
-		return
-	}
-	if !done {
-		err = azure.NewAsyncOpIncompleteError("storage.AccountsCreateFuture")
-		return
-	}
-	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
-	if a.Response.Response, err = future.GetResult(sender); err == nil && a.Response.Response.StatusCode != http.StatusNoContent {
-		a, err = client.CreateResponder(a.Response.Response)
-		if err != nil {
-			err = autorest.NewErrorWithError(err, "storage.AccountsCreateFuture", "Result", a.Response.Response, "Failure responding to request")
-		}
-	}
-	return
-}
-
-// AccountsFailoverFuture an abstraction for monitoring and retrieving the results of a long-running
-// operation.
-type AccountsFailoverFuture struct {
-	azure.Future
-}
-
-// Result returns the result of the asynchronous operation.
-// If the operation has not completed it will return an error.
-func (future *AccountsFailoverFuture) Result(client AccountsClient) (ar autorest.Response, err error) {
-	var done bool
-	done, err = future.DoneWithContext(context.Background(), client)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.AccountsFailoverFuture", "Result", future.Response(), "Polling failure")
-		return
-	}
-	if !done {
-		err = azure.NewAsyncOpIncompleteError("storage.AccountsFailoverFuture")
-		return
-	}
-	ar.Response = future.Response()
-	return
-}
-
-// AccountUpdateParameters the parameters that can be provided when updating the storage account
-// properties.
-type AccountUpdateParameters struct {
-	// Sku - Gets or sets the SKU name. Note that the SKU name cannot be updated to Standard_ZRS, Premium_LRS or Premium_ZRS, nor can accounts of those SKU names be updated to any other value.
-	Sku *Sku `json:"sku,omitempty"`
-	// Tags - Gets or sets a list of key value pairs that describe the resource. These tags can be used in viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key no greater in length than 128 characters and a value no greater in length than 256 characters.
-	Tags map[string]*string `json:"tags"`
-	// Identity - The identity of the resource.
-	Identity *Identity `json:"identity,omitempty"`
-	// AccountPropertiesUpdateParameters - The parameters used when updating a storage account.
-	*AccountPropertiesUpdateParameters `json:"properties,omitempty"`
-	// Kind - Optional. Indicates the type of storage account. Currently only StorageV2 value supported by server. Possible values include: 'Storage', 'StorageV2', 'BlobStorage', 'FileStorage', 'BlockBlobStorage'
-	Kind Kind `json:"kind,omitempty"`
-}
-
-// MarshalJSON is the custom marshaler for AccountUpdateParameters.
-func (aup AccountUpdateParameters) MarshalJSON() ([]byte, error) {
-	objectMap := make(map[string]interface{})
-	if aup.Sku != nil {
-		objectMap["sku"] = aup.Sku
-	}
-	if aup.Tags != nil {
-		objectMap["tags"] = aup.Tags
-	}
-	if aup.Identity != nil {
-		objectMap["identity"] = aup.Identity
-	}
-	if aup.AccountPropertiesUpdateParameters != nil {
-		objectMap["properties"] = aup.AccountPropertiesUpdateParameters
-	}
-	if aup.Kind != "" {
-		objectMap["kind"] = aup.Kind
-	}
-	return json.Marshal(objectMap)
-}
-
-// UnmarshalJSON is the custom unmarshaler for AccountUpdateParameters struct.
-func (aup *AccountUpdateParameters) UnmarshalJSON(body []byte) error {
-	var m map[string]*json.RawMessage
-	err := json.Unmarshal(body, &m)
-	if err != nil {
-		return err
-	}
-	for k, v := range m {
-		switch k {
-		case "sku":
-			if v != nil {
-				var sku Sku
-				err = json.Unmarshal(*v, &sku)
-				if err != nil {
-					return err
-				}
-				aup.Sku = &sku
-			}
-		case "tags":
-			if v != nil {
-				var tags map[string]*string
-				err = json.Unmarshal(*v, &tags)
-				if err != nil {
-					return err
-				}
-				aup.Tags = tags
-			}
-		case "identity":
-			if v != nil {
-				var identity Identity
-				err = json.Unmarshal(*v, &identity)
-				if err != nil {
-					return err
-				}
-				aup.Identity = &identity
-			}
-		case "properties":
-			if v != nil {
-				var accountPropertiesUpdateParameters AccountPropertiesUpdateParameters
-				err = json.Unmarshal(*v, &accountPropertiesUpdateParameters)
-				if err != nil {
-					return err
-				}
-				aup.AccountPropertiesUpdateParameters = &accountPropertiesUpdateParameters
-			}
-		case "kind":
-			if v != nil {
-				var kind Kind
-				err = json.Unmarshal(*v, &kind)
-				if err != nil {
-					return err
-				}
-				aup.Kind = kind
-			}
-		}
-	}
-
-	return nil
-}
-
-// AzureEntityResource the resource model definition for a Azure Resource Manager resource with an etag.
-type AzureEntityResource struct {
-	// Etag - READ-ONLY; Resource Etag.
-	Etag *string `json:"etag,omitempty"`
-	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
-	ID *string `json:"id,omitempty"`
-	// Name - READ-ONLY; The name of the resource
-	Name *string `json:"name,omitempty"`
-	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
-	Type *string `json:"type,omitempty"`
-}
-
-// BlobContainer properties of the blob container, including Id, resource name, resource type, Etag.
-type BlobContainer struct {
-	autorest.Response `json:"-"`
-	// ContainerProperties - Properties of the blob container.
-	*ContainerProperties `json:"properties,omitempty"`
-	// Etag - READ-ONLY; Resource Etag.
-	Etag *string `json:"etag,omitempty"`
-	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
-	ID *string `json:"id,omitempty"`
-	// Name - READ-ONLY; The name of the resource
-	Name *string `json:"name,omitempty"`
-	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
-	Type *string `json:"type,omitempty"`
-}
-
-// MarshalJSON is the custom marshaler for BlobContainer.
-func (bc BlobContainer) MarshalJSON() ([]byte, error) {
-	objectMap := make(map[string]interface{})
-	if bc.ContainerProperties != nil {
-		objectMap["properties"] = bc.ContainerProperties
-	}
-	return json.Marshal(objectMap)
-}
-
-// UnmarshalJSON is the custom unmarshaler for BlobContainer struct.
-func (bc *BlobContainer) UnmarshalJSON(body []byte) error {
-	var m map[string]*json.RawMessage
-	err := json.Unmarshal(body, &m)
-	if err != nil {
-		return err
-	}
-	for k, v := range m {
-		switch k {
-		case "properties":
-			if v != nil {
-				var containerProperties ContainerProperties
-				err = json.Unmarshal(*v, &containerProperties)
-				if err != nil {
-					return err
-				}
-				bc.ContainerProperties = &containerProperties
-			}
-		case "etag":
-			if v != nil {
-				var etag string
-				err = json.Unmarshal(*v, &etag)
-				if err != nil {
-					return err
-				}
-				bc.Etag = &etag
-			}
-		case "id":
-			if v != nil {
-				var ID string
-				err = json.Unmarshal(*v, &ID)
-				if err != nil {
-					return err
-				}
-				bc.ID = &ID
-			}
-		case "name":
-			if v != nil {
-				var name string
-				err = json.Unmarshal(*v, &name)
-				if err != nil {
-					return err
-				}
-				bc.Name = &name
-			}
-		case "type":
-			if v != nil {
-				var typeVar string
-				err = json.Unmarshal(*v, &typeVar)
-				if err != nil {
-					return err
-				}
-				bc.Type = &typeVar
-			}
-		}
-	}
-
-	return nil
-}
-
-// BlobServiceProperties the properties of a storage accounts Blob service.
-type BlobServiceProperties struct {
-	autorest.Response `json:"-"`
-	// BlobServicePropertiesProperties - The properties of a storage accounts Blob service.
-	*BlobServicePropertiesProperties `json:"properties,omitempty"`
-	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
-	ID *string `json:"id,omitempty"`
-	// Name - READ-ONLY; The name of the resource
-	Name *string `json:"name,omitempty"`
-	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
-	Type *string `json:"type,omitempty"`
-}
-
-// MarshalJSON is the custom marshaler for BlobServiceProperties.
-func (bsp BlobServiceProperties) MarshalJSON() ([]byte, error) {
-	objectMap := make(map[string]interface{})
-	if bsp.BlobServicePropertiesProperties != nil {
-		objectMap["properties"] = bsp.BlobServicePropertiesProperties
-	}
-	return json.Marshal(objectMap)
-}
-
-// UnmarshalJSON is the custom unmarshaler for BlobServiceProperties struct.
-func (bsp *BlobServiceProperties) UnmarshalJSON(body []byte) error {
-	var m map[string]*json.RawMessage
-	err := json.Unmarshal(body, &m)
-	if err != nil {
-		return err
-	}
-	for k, v := range m {
-		switch k {
-		case "properties":
-			if v != nil {
-				var blobServiceProperties BlobServicePropertiesProperties
-				err = json.Unmarshal(*v, &blobServiceProperties)
-				if err != nil {
-					return err
-				}
-				bsp.BlobServicePropertiesProperties = &blobServiceProperties
-			}
-		case "id":
-			if v != nil {
-				var ID string
-				err = json.Unmarshal(*v, &ID)
-				if err != nil {
-					return err
-				}
-				bsp.ID = &ID
-			}
-		case "name":
-			if v != nil {
-				var name string
-				err = json.Unmarshal(*v, &name)
-				if err != nil {
-					return err
-				}
-				bsp.Name = &name
-			}
-		case "type":
-			if v != nil {
-				var typeVar string
-				err = json.Unmarshal(*v, &typeVar)
-				if err != nil {
-					return err
-				}
-				bsp.Type = &typeVar
-			}
-		}
-	}
-
-	return nil
-}
-
-// BlobServicePropertiesProperties the properties of a storage accounts Blob service.
-type BlobServicePropertiesProperties struct {
-	// Cors - Specifies CORS rules for the Blob service. You can include up to five CorsRule elements in the request. If no CorsRule elements are included in the request body, all CORS rules will be deleted, and CORS will be disabled for the Blob service.
-	Cors *CorsRules `json:"cors,omitempty"`
-	// DefaultServiceVersion - DefaultServiceVersion indicates the default version to use for requests to the Blob service if an incoming requests version is not specified. Possible values include version 2008-10-27 and all more recent versions.
-	DefaultServiceVersion *string `json:"defaultServiceVersion,omitempty"`
-	// DeleteRetentionPolicy - The blob service properties for soft delete.
-	DeleteRetentionPolicy *DeleteRetentionPolicy `json:"deleteRetentionPolicy,omitempty"`
-}
-
-// CheckNameAvailabilityResult the CheckNameAvailability operation response.
-type CheckNameAvailabilityResult struct {
-	autorest.Response `json:"-"`
-	// NameAvailable - READ-ONLY; Gets a boolean value that indicates whether the name is available for you to use. If true, the name is available. If false, the name has already been taken or is invalid and cannot be used.
-	NameAvailable *bool `json:"nameAvailable,omitempty"`
-	// Reason - READ-ONLY; Gets the reason that a storage account name could not be used. The Reason element is only returned if NameAvailable is false. Possible values include: 'AccountNameInvalid', 'AlreadyExists'
-	Reason Reason `json:"reason,omitempty"`
-	// Message - READ-ONLY; Gets an error message explaining the Reason value in more detail.
-	Message *string `json:"message,omitempty"`
-}
-
-// ContainerProperties the properties of a container.
-type ContainerProperties struct {
-	// PublicAccess - Specifies whether data in the container may be accessed publicly and the level of access. Possible values include: 'PublicAccessContainer', 'PublicAccessBlob', 'PublicAccessNone'
-	PublicAccess PublicAccess `json:"publicAccess,omitempty"`
-	// LastModifiedTime - READ-ONLY; Returns the date and time the container was last modified.
-	LastModifiedTime *date.Time `json:"lastModifiedTime,omitempty"`
-	// LeaseStatus - READ-ONLY; The lease status of the container. Possible values include: 'LeaseStatusLocked', 'LeaseStatusUnlocked'
-	LeaseStatus LeaseStatus `json:"leaseStatus,omitempty"`
-	// LeaseState - READ-ONLY; Lease state of the container. Possible values include: 'LeaseStateAvailable', 'LeaseStateLeased', 'LeaseStateExpired', 'LeaseStateBreaking', 'LeaseStateBroken'
-	LeaseState LeaseState `json:"leaseState,omitempty"`
-	// LeaseDuration - READ-ONLY; Specifies whether the lease on a container is of infinite or fixed duration, only when the container is leased. Possible values include: 'Infinite', 'Fixed'
-	LeaseDuration LeaseDuration `json:"leaseDuration,omitempty"`
-	// Metadata - A name-value pair to associate with the container as metadata.
-	Metadata map[string]*string `json:"metadata"`
-	// ImmutabilityPolicy - READ-ONLY; The ImmutabilityPolicy property of the container.
-	ImmutabilityPolicy *ImmutabilityPolicyProperties `json:"immutabilityPolicy,omitempty"`
-	// LegalHold - READ-ONLY; The LegalHold property of the container.
-	LegalHold *LegalHoldProperties `json:"legalHold,omitempty"`
-	// HasLegalHold - READ-ONLY; The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account.
-	HasLegalHold *bool `json:"hasLegalHold,omitempty"`
-	// HasImmutabilityPolicy - READ-ONLY; The hasImmutabilityPolicy public property is set to true by SRP if ImmutabilityPolicy has been created for this container. The hasImmutabilityPolicy public property is set to false by SRP if ImmutabilityPolicy has not been created for this container.
-	HasImmutabilityPolicy *bool `json:"hasImmutabilityPolicy,omitempty"`
-}
-
-// MarshalJSON is the custom marshaler for ContainerProperties.
-func (cp ContainerProperties) MarshalJSON() ([]byte, error) {
-	objectMap := make(map[string]interface{})
-	if cp.PublicAccess != "" {
-		objectMap["publicAccess"] = cp.PublicAccess
-	}
-	if cp.Metadata != nil {
-		objectMap["metadata"] = cp.Metadata
-	}
-	return json.Marshal(objectMap)
-}
-
-// CorsRule specifies a CORS rule for the Blob service.
-type CorsRule struct {
-	// AllowedOrigins - Required if CorsRule element is present. A list of origin domains that will be allowed via CORS, or "*" to allow all domains
-	AllowedOrigins *[]string `json:"allowedOrigins,omitempty"`
-	// AllowedMethods - Required if CorsRule element is present. A list of HTTP methods that are allowed to be executed by the origin.
-	AllowedMethods *[]string `json:"allowedMethods,omitempty"`
-	// MaxAgeInSeconds - Required if CorsRule element is present. The number of seconds that the client/browser should cache a preflight response.
-	MaxAgeInSeconds *int32 `json:"maxAgeInSeconds,omitempty"`
-	// ExposedHeaders - Required if CorsRule element is present. A list of response headers to expose to CORS clients.
-	ExposedHeaders *[]string `json:"exposedHeaders,omitempty"`
-	// AllowedHeaders - Required if CorsRule element is present. A list of headers allowed to be part of the cross-origin request.
-	AllowedHeaders *[]string `json:"allowedHeaders,omitempty"`
-}
-
-// CorsRules sets the CORS rules. You can include up to five CorsRule elements in the request.
-type CorsRules struct {
-	// CorsRules - The List of CORS rules. You can include up to five CorsRule elements in the request.
-	CorsRules *[]CorsRule `json:"corsRules,omitempty"`
-}
-
-// CustomDomain the custom domain assigned to this storage account. This can be set via Update.
-type CustomDomain struct {
-	// Name - Gets or sets the custom domain name assigned to the storage account. Name is the CNAME source.
-	Name *string `json:"name,omitempty"`
-	// UseSubDomainName - Indicates whether indirect CName validation is enabled. Default value is false. This should only be set on updates.
-	UseSubDomainName *bool `json:"useSubDomainName,omitempty"`
-}
-
-// DeleteRetentionPolicy the blob service properties for soft delete.
-type DeleteRetentionPolicy struct {
-	// Enabled - Indicates whether DeleteRetentionPolicy is enabled for the Blob service.
-	Enabled *bool `json:"enabled,omitempty"`
-	// Days - Indicates the number of days that the deleted blob should be retained. The minimum specified value can be 1 and the maximum value can be 365.
-	Days *int32 `json:"days,omitempty"`
-}
-
-// Dimension dimension of blobs, possibly be blob type or access tier.
-type Dimension struct {
-	// Name - Display name of dimension.
-	Name *string `json:"name,omitempty"`
-	// DisplayName - Display name of dimension.
-	DisplayName *string `json:"displayName,omitempty"`
-}
-
-// Encryption the encryption settings on the storage account.
-type Encryption struct {
-	// Services - List of services which support encryption.
-	Services *EncryptionServices `json:"services,omitempty"`
-	// KeySource - The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Possible values include: 'MicrosoftStorage', 'MicrosoftKeyvault'
-	KeySource KeySource `json:"keySource,omitempty"`
-	// KeyVaultProperties - Properties provided by key vault.
-	KeyVaultProperties *KeyVaultProperties `json:"keyvaultproperties,omitempty"`
-}
-
-// EncryptionService a service that allows server-side encryption to be used.
-type EncryptionService struct {
-	// Enabled - A boolean indicating whether or not the service encrypts the data as it is stored.
-	Enabled *bool `json:"enabled,omitempty"`
-	// LastEnabledTime - READ-ONLY; Gets a rough estimate of the date/time when the encryption was last enabled by the user. Only returned when encryption is enabled. There might be some unencrypted blobs which were written after this time, as it is just a rough estimate.
-	LastEnabledTime *date.Time `json:"lastEnabledTime,omitempty"`
-}
-
-// EncryptionServices a list of services that support encryption.
-type EncryptionServices struct {
-	// Blob - The encryption function of the blob storage service.
-	Blob *EncryptionService `json:"blob,omitempty"`
-	// File - The encryption function of the file storage service.
-	File *EncryptionService `json:"file,omitempty"`
-	// Table - READ-ONLY; The encryption function of the table storage service.
-	Table *EncryptionService `json:"table,omitempty"`
-	// Queue - READ-ONLY; The encryption function of the queue storage service.
-	Queue *EncryptionService `json:"queue,omitempty"`
-}
-
-// Endpoints the URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs
-// object.
-type Endpoints struct {
-	// Blob - READ-ONLY; Gets the blob endpoint.
-	Blob *string `json:"blob,omitempty"`
-	// Queue - READ-ONLY; Gets the queue endpoint.
-	Queue *string `json:"queue,omitempty"`
-	// Table - READ-ONLY; Gets the table endpoint.
-	Table *string `json:"table,omitempty"`
-	// File - READ-ONLY; Gets the file endpoint.
-	File *string `json:"file,omitempty"`
-	// Web - READ-ONLY; Gets the web endpoint.
-	Web *string `json:"web,omitempty"`
-	// Dfs - READ-ONLY; Gets the dfs endpoint.
-	Dfs *string `json:"dfs,omitempty"`
-}
-
-// GeoReplicationStats statistics related to replication for storage account's Blob, Table, Queue and File
-// services. It is only available when geo-redundant replication is enabled for the storage account.
-type GeoReplicationStats struct {
-	// Status - READ-ONLY; The status of the secondary location. Possible values are: - Live: Indicates that the secondary location is active and operational. - Bootstrap: Indicates initial synchronization from the primary location to the secondary location is in progress.This typically occurs when replication is first enabled. - Unavailable: Indicates that the secondary location is temporarily unavailable. Possible values include: 'GeoReplicationStatusLive', 'GeoReplicationStatusBootstrap', 'GeoReplicationStatusUnavailable'
-	Status GeoReplicationStatus `json:"status,omitempty"`
-	// LastSyncTime - READ-ONLY; All primary writes preceding this UTC date/time value are guaranteed to be available for read operations. Primary writes following this point in time may or may not be available for reads. Element may be default value if value of LastSyncTime is not available, this can happen if secondary is offline or we are in bootstrap.
-	LastSyncTime *date.Time `json:"lastSyncTime,omitempty"`
-	// CanFailover - READ-ONLY; A boolean flag which indicates whether or not account failover is supported for the account.
-	CanFailover *bool `json:"canFailover,omitempty"`
-}
-
-// Identity identity for the resource.
-type Identity struct {
-	// PrincipalID - READ-ONLY; The principal ID of resource identity.
-	PrincipalID *string `json:"principalId,omitempty"`
-	// TenantID - READ-ONLY; The tenant ID of resource.
-	TenantID *string `json:"tenantId,omitempty"`
-	// Type - The identity type.
-	Type *string `json:"type,omitempty"`
-}
-
-// ImmutabilityPolicy the ImmutabilityPolicy property of a blob container, including Id, resource name,
-// resource type, Etag.
-type ImmutabilityPolicy struct {
-	autorest.Response `json:"-"`
-	// ImmutabilityPolicyProperty - The properties of an ImmutabilityPolicy of a blob container.
-	*ImmutabilityPolicyProperty `json:"properties,omitempty"`
-	// Etag - READ-ONLY; Resource Etag.
-	Etag *string `json:"etag,omitempty"`
-	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
-	ID *string `json:"id,omitempty"`
-	// Name - READ-ONLY; The name of the resource
-	Name *string `json:"name,omitempty"`
-	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
-	Type *string `json:"type,omitempty"`
-}
-
-// MarshalJSON is the custom marshaler for ImmutabilityPolicy.
-func (IP ImmutabilityPolicy) MarshalJSON() ([]byte, error) {
-	objectMap := make(map[string]interface{})
-	if IP.ImmutabilityPolicyProperty != nil {
-		objectMap["properties"] = IP.ImmutabilityPolicyProperty
-	}
-	return json.Marshal(objectMap)
-}
-
-// UnmarshalJSON is the custom unmarshaler for ImmutabilityPolicy struct.
-func (IP *ImmutabilityPolicy) UnmarshalJSON(body []byte) error {
-	var m map[string]*json.RawMessage
-	err := json.Unmarshal(body, &m)
-	if err != nil {
-		return err
-	}
-	for k, v := range m {
-		switch k {
-		case "properties":
-			if v != nil {
-				var immutabilityPolicyProperty ImmutabilityPolicyProperty
-				err = json.Unmarshal(*v, &immutabilityPolicyProperty)
-				if err != nil {
-					return err
-				}
-				IP.ImmutabilityPolicyProperty = &immutabilityPolicyProperty
-			}
-		case "etag":
-			if v != nil {
-				var etag string
-				err = json.Unmarshal(*v, &etag)
-				if err != nil {
-					return err
-				}
-				IP.Etag = &etag
-			}
-		case "id":
-			if v != nil {
-				var ID string
-				err = json.Unmarshal(*v, &ID)
-				if err != nil {
-					return err
-				}
-				IP.ID = &ID
-			}
-		case "name":
-			if v != nil {
-				var name string
-				err = json.Unmarshal(*v, &name)
-				if err != nil {
-					return err
-				}
-				IP.Name = &name
-			}
-		case "type":
-			if v != nil {
-				var typeVar string
-				err = json.Unmarshal(*v, &typeVar)
-				if err != nil {
-					return err
-				}
-				IP.Type = &typeVar
-			}
-		}
-	}
-
-	return nil
-}
-
-// ImmutabilityPolicyProperties the properties of an ImmutabilityPolicy of a blob container.
-type ImmutabilityPolicyProperties struct {
-	// ImmutabilityPolicyProperty - The properties of an ImmutabilityPolicy of a blob container.
-	*ImmutabilityPolicyProperty `json:"properties,omitempty"`
-	// Etag - READ-ONLY; ImmutabilityPolicy Etag.
-	Etag *string `json:"etag,omitempty"`
-	// UpdateHistory - READ-ONLY; The ImmutabilityPolicy update history of the blob container.
-	UpdateHistory *[]UpdateHistoryProperty `json:"updateHistory,omitempty"`
-}
-
-// MarshalJSON is the custom marshaler for ImmutabilityPolicyProperties.
-func (ipp ImmutabilityPolicyProperties) MarshalJSON() ([]byte, error) {
-	objectMap := make(map[string]interface{})
-	if ipp.ImmutabilityPolicyProperty != nil {
-		objectMap["properties"] = ipp.ImmutabilityPolicyProperty
-	}
-	return json.Marshal(objectMap)
-}
-
-// UnmarshalJSON is the custom unmarshaler for ImmutabilityPolicyProperties struct.
-func (ipp *ImmutabilityPolicyProperties) UnmarshalJSON(body []byte) error {
-	var m map[string]*json.RawMessage
-	err := json.Unmarshal(body, &m)
-	if err != nil {
-		return err
-	}
-	for k, v := range m {
-		switch k {
-		case "properties":
-			if v != nil {
-				var immutabilityPolicyProperty ImmutabilityPolicyProperty
-				err = json.Unmarshal(*v, &immutabilityPolicyProperty)
-				if err != nil {
-					return err
-				}
-				ipp.ImmutabilityPolicyProperty = &immutabilityPolicyProperty
-			}
-		case "etag":
-			if v != nil {
-				var etag string
-				err = json.Unmarshal(*v, &etag)
-				if err != nil {
-					return err
-				}
-				ipp.Etag = &etag
-			}
-		case "updateHistory":
-			if v != nil {
-				var updateHistory []UpdateHistoryProperty
-				err = json.Unmarshal(*v, &updateHistory)
-				if err != nil {
-					return err
-				}
-				ipp.UpdateHistory = &updateHistory
-			}
-		}
-	}
-
-	return nil
-}
-
-// ImmutabilityPolicyProperty the properties of an ImmutabilityPolicy of a blob container.
-type ImmutabilityPolicyProperty struct {
-	// ImmutabilityPeriodSinceCreationInDays - The immutability period for the blobs in the container since the policy creation, in days.
-	ImmutabilityPeriodSinceCreationInDays *int32 `json:"immutabilityPeriodSinceCreationInDays,omitempty"`
-	// State - READ-ONLY; The ImmutabilityPolicy state of a blob container, possible values include: Locked and Unlocked. Possible values include: 'Locked', 'Unlocked'
-	State ImmutabilityPolicyState `json:"state,omitempty"`
-}
-
-// IPRule IP rule with specific IP or IP range in CIDR format.
-type IPRule struct {
-	// IPAddressOrRange - Specifies the IP or IP range in CIDR format. Only IPV4 address is allowed.
-	IPAddressOrRange *string `json:"value,omitempty"`
-	// Action - The action of IP ACL rule. Possible values include: 'Allow'
-	Action Action `json:"action,omitempty"`
-}
-
-// KeyVaultProperties properties of key vault.
-type KeyVaultProperties struct {
-	// KeyName - The name of KeyVault key.
-	KeyName *string `json:"keyname,omitempty"`
-	// KeyVersion - The version of KeyVault key.
-	KeyVersion *string `json:"keyversion,omitempty"`
-	// KeyVaultURI - The Uri of KeyVault.
-	KeyVaultURI *string `json:"keyvaulturi,omitempty"`
-}
-
-// LeaseContainerRequest lease Container request schema.
-type LeaseContainerRequest struct {
-	// Action - Specifies the lease action. Can be one of the available actions. Possible values include: 'Acquire', 'Renew', 'Change', 'Release', 'Break'
-	Action Action1 `json:"action,omitempty"`
-	// LeaseID - Identifies the lease. Can be specified in any valid GUID string format.
-	LeaseID *string `json:"leaseId,omitempty"`
-	// BreakPeriod - Optional. For a break action, proposed duration the lease should continue before it is broken, in seconds, between 0 and 60.
-	BreakPeriod *int32 `json:"breakPeriod,omitempty"`
-	// LeaseDuration - Required for acquire. Specifies the duration of the lease, in seconds, or negative one (-1) for a lease that never expires.
-	LeaseDuration *int32 `json:"leaseDuration,omitempty"`
-	// ProposedLeaseID - Optional for acquire, required for change. Proposed lease ID, in a GUID string format.
-	ProposedLeaseID *string `json:"proposedLeaseId,omitempty"`
-}
-
-// LeaseContainerResponse lease Container response schema.
-type LeaseContainerResponse struct {
-	autorest.Response `json:"-"`
-	// LeaseID - Returned unique lease ID that must be included with any request to delete the container, or to renew, change, or release the lease.
-	LeaseID *string `json:"leaseId,omitempty"`
-	// LeaseTimeSeconds - Approximate time remaining in the lease period, in seconds.
-	LeaseTimeSeconds *string `json:"leaseTimeSeconds,omitempty"`
-}
-
-// LegalHold the LegalHold property of a blob container.
-type LegalHold struct {
-	autorest.Response `json:"-"`
-	// HasLegalHold - READ-ONLY; The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account.
-	HasLegalHold *bool `json:"hasLegalHold,omitempty"`
-	// Tags - Each tag should be 3 to 23 alphanumeric characters and is normalized to lower case at SRP.
-	Tags *[]string `json:"tags,omitempty"`
-}
-
-// LegalHoldProperties the LegalHold property of a blob container.
-type LegalHoldProperties struct {
-	// HasLegalHold - READ-ONLY; The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account.
-	HasLegalHold *bool `json:"hasLegalHold,omitempty"`
-	// Tags - The list of LegalHold tags of a blob container.
-	Tags *[]TagProperty `json:"tags,omitempty"`
-}
-
-// ListAccountSasResponse the List SAS credentials operation response.
-type ListAccountSasResponse struct {
-	autorest.Response `json:"-"`
-	// AccountSasToken - READ-ONLY; List SAS credentials of storage account.
-	AccountSasToken *string `json:"accountSasToken,omitempty"`
-}
-
-// ListContainerItem the blob container properties be listed out.
-type ListContainerItem struct {
-	// ContainerProperties - The blob container properties be listed out.
-	*ContainerProperties `json:"properties,omitempty"`
-	// Etag - READ-ONLY; Resource Etag.
-	Etag *string `json:"etag,omitempty"`
-	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
-	ID *string `json:"id,omitempty"`
-	// Name - READ-ONLY; The name of the resource
-	Name *string `json:"name,omitempty"`
-	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
-	Type *string `json:"type,omitempty"`
-}
-
-// MarshalJSON is the custom marshaler for ListContainerItem.
-func (lci ListContainerItem) MarshalJSON() ([]byte, error) {
-	objectMap := make(map[string]interface{})
-	if lci.ContainerProperties != nil {
-		objectMap["properties"] = lci.ContainerProperties
-	}
-	return json.Marshal(objectMap)
-}
-
-// UnmarshalJSON is the custom unmarshaler for ListContainerItem struct.
-func (lci *ListContainerItem) UnmarshalJSON(body []byte) error {
-	var m map[string]*json.RawMessage
-	err := json.Unmarshal(body, &m)
-	if err != nil {
-		return err
-	}
-	for k, v := range m {
-		switch k {
-		case "properties":
-			if v != nil {
-				var containerProperties ContainerProperties
-				err = json.Unmarshal(*v, &containerProperties)
-				if err != nil {
-					return err
-				}
-				lci.ContainerProperties = &containerProperties
-			}
-		case "etag":
-			if v != nil {
-				var etag string
-				err = json.Unmarshal(*v, &etag)
-				if err != nil {
-					return err
-				}
-				lci.Etag = &etag
-			}
-		case "id":
-			if v != nil {
-				var ID string
-				err = json.Unmarshal(*v, &ID)
-				if err != nil {
-					return err
-				}
-				lci.ID = &ID
-			}
-		case "name":
-			if v != nil {
-				var name string
-				err = json.Unmarshal(*v, &name)
-				if err != nil {
-					return err
-				}
-				lci.Name = &name
-			}
-		case "type":
-			if v != nil {
-				var typeVar string
-				err = json.Unmarshal(*v, &typeVar)
-				if err != nil {
-					return err
-				}
-				lci.Type = &typeVar
-			}
-		}
-	}
-
-	return nil
-}
-
-// ListContainerItems the list of blob containers.
-type ListContainerItems struct {
-	autorest.Response `json:"-"`
-	// Value - The list of blob containers.
-	Value *[]ListContainerItem `json:"value,omitempty"`
-}
-
-// ListServiceSasResponse the List service SAS credentials operation response.
-type ListServiceSasResponse struct {
-	autorest.Response `json:"-"`
-	// ServiceSasToken - READ-ONLY; List service SAS credentials of specific resource.
-	ServiceSasToken *string `json:"serviceSasToken,omitempty"`
-}
-
-// ManagementPoliciesRules the Storage Account ManagementPolicies Rules, in JSON format. See more details
-// in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
-type ManagementPoliciesRules struct {
-	// Policy - The Storage Account ManagementPolicies Rules, in JSON format. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
-	Policy interface{} `json:"policy,omitempty"`
-}
-
-// ManagementPoliciesRulesSetParameter the Storage Account ManagementPolicies Rules, in JSON format. See
-// more details in:
-// https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
-type ManagementPoliciesRulesSetParameter struct {
-	// ManagementPoliciesRules - The Storage Account ManagementPolicies Rules, in JSON format. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
-	*ManagementPoliciesRules `json:"properties,omitempty"`
-}
-
-// MarshalJSON is the custom marshaler for ManagementPoliciesRulesSetParameter.
-func (mprsp ManagementPoliciesRulesSetParameter) MarshalJSON() ([]byte, error) {
-	objectMap := make(map[string]interface{})
-	if mprsp.ManagementPoliciesRules != nil {
-		objectMap["properties"] = mprsp.ManagementPoliciesRules
-	}
-	return json.Marshal(objectMap)
-}
-
-// UnmarshalJSON is the custom unmarshaler for ManagementPoliciesRulesSetParameter struct.
-func (mprsp *ManagementPoliciesRulesSetParameter) UnmarshalJSON(body []byte) error {
-	var m map[string]*json.RawMessage
-	err := json.Unmarshal(body, &m)
-	if err != nil {
-		return err
-	}
-	for k, v := range m {
-		switch k {
-		case "properties":
-			if v != nil {
-				var managementPoliciesRules ManagementPoliciesRules
-				err = json.Unmarshal(*v, &managementPoliciesRules)
-				if err != nil {
-					return err
-				}
-				mprsp.ManagementPoliciesRules = &managementPoliciesRules
-			}
-		}
-	}
-
-	return nil
-}
-
-// MetricSpecification metric specification of operation.
-type MetricSpecification struct {
-	// Name - Name of metric specification.
-	Name *string `json:"name,omitempty"`
-	// DisplayName - Display name of metric specification.
-	DisplayName *string `json:"displayName,omitempty"`
-	// DisplayDescription - Display description of metric specification.
-	DisplayDescription *string `json:"displayDescription,omitempty"`
-	// Unit - Unit could be Bytes or Count.
-	Unit *string `json:"unit,omitempty"`
-	// Dimensions - Dimensions of blobs, including blob type and access tier.
-	Dimensions *[]Dimension `json:"dimensions,omitempty"`
-	// AggregationType - Aggregation type could be Average.
-	AggregationType *string `json:"aggregationType,omitempty"`
-	// FillGapWithZero - The property to decide fill gap with zero or not.
-	FillGapWithZero *bool `json:"fillGapWithZero,omitempty"`
-	// Category - The category this metric specification belong to, could be Capacity.
-	Category *string `json:"category,omitempty"`
-	// ResourceIDDimensionNameOverride - Account Resource Id.
-	ResourceIDDimensionNameOverride *string `json:"resourceIdDimensionNameOverride,omitempty"`
-}
-
-// NetworkRuleSet network rule set
-type NetworkRuleSet struct {
-	// Bypass - Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None to bypass none of those traffics. Possible values include: 'None', 'Logging', 'Metrics', 'AzureServices'
-	Bypass Bypass `json:"bypass,omitempty"`
-	// VirtualNetworkRules - Sets the virtual network rules
-	VirtualNetworkRules *[]VirtualNetworkRule `json:"virtualNetworkRules,omitempty"`
-	// IPRules - Sets the IP ACL rules
-	IPRules *[]IPRule `json:"ipRules,omitempty"`
-	// DefaultAction - Specifies the default action of allow or deny when no other rules match. Possible values include: 'DefaultActionAllow', 'DefaultActionDeny'
-	DefaultAction DefaultAction `json:"defaultAction,omitempty"`
-}
-
-// Operation storage REST API operation definition.
-type Operation struct {
-	// Name - Operation name: {provider}/{resource}/{operation}
-	Name *string `json:"name,omitempty"`
-	// Display - Display metadata associated with the operation.
-	Display *OperationDisplay `json:"display,omitempty"`
-	// Origin - The origin of operations.
-	Origin *string `json:"origin,omitempty"`
-	// OperationProperties - Properties of operation, include metric specifications.
-	*OperationProperties `json:"properties,omitempty"`
-}
-
-// MarshalJSON is the custom marshaler for Operation.
-func (o Operation) MarshalJSON() ([]byte, error) {
-	objectMap := make(map[string]interface{})
-	if o.Name != nil {
-		objectMap["name"] = o.Name
-	}
-	if o.Display != nil {
-		objectMap["display"] = o.Display
-	}
-	if o.Origin != nil {
-		objectMap["origin"] = o.Origin
-	}
-	if o.OperationProperties != nil {
-		objectMap["properties"] = o.OperationProperties
-	}
-	return json.Marshal(objectMap)
-}
-
-// UnmarshalJSON is the custom unmarshaler for Operation struct.
-func (o *Operation) UnmarshalJSON(body []byte) error {
-	var m map[string]*json.RawMessage
-	err := json.Unmarshal(body, &m)
-	if err != nil {
-		return err
-	}
-	for k, v := range m {
-		switch k {
-		case "name":
-			if v != nil {
-				var name string
-				err = json.Unmarshal(*v, &name)
-				if err != nil {
-					return err
-				}
-				o.Name = &name
-			}
-		case "display":
-			if v != nil {
-				var display OperationDisplay
-				err = json.Unmarshal(*v, &display)
-				if err != nil {
-					return err
-				}
-				o.Display = &display
-			}
-		case "origin":
-			if v != nil {
-				var origin string
-				err = json.Unmarshal(*v, &origin)
-				if err != nil {
-					return err
-				}
-				o.Origin = &origin
-			}
-		case "properties":
-			if v != nil {
-				var operationProperties OperationProperties
-				err = json.Unmarshal(*v, &operationProperties)
-				if err != nil {
-					return err
-				}
-				o.OperationProperties = &operationProperties
-			}
-		}
-	}
-
-	return nil
-}
-
-// OperationDisplay display metadata associated with the operation.
-type OperationDisplay struct {
-	// Provider - Service provider: Microsoft Storage.
-	Provider *string `json:"provider,omitempty"`
-	// Resource - Resource on which the operation is performed etc.
-	Resource *string `json:"resource,omitempty"`
-	// Operation - Type of operation: get, read, delete, etc.
-	Operation *string `json:"operation,omitempty"`
-	// Description - Description of the operation.
-	Description *string `json:"description,omitempty"`
-}
-
-// OperationListResult result of the request to list Storage operations. It contains a list of operations
-// and a URL link to get the next set of results.
-type OperationListResult struct {
-	autorest.Response `json:"-"`
-	// Value - List of Storage operations supported by the Storage resource provider.
-	Value *[]Operation `json:"value,omitempty"`
-}
-
-// OperationProperties properties of operation, include metric specifications.
-type OperationProperties struct {
-	// ServiceSpecification - One property of operation, include metric specifications.
-	ServiceSpecification *ServiceSpecification `json:"serviceSpecification,omitempty"`
-}
-
-// ProxyResource the resource model definition for a ARM proxy resource. It will have everything other than
-// required location and tags
-type ProxyResource struct {
-	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
-	ID *string `json:"id,omitempty"`
-	// Name - READ-ONLY; The name of the resource
-	Name *string `json:"name,omitempty"`
-	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
-	Type *string `json:"type,omitempty"`
-}
-
-// Resource ...
-type Resource struct {
-	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
-	ID *string `json:"id,omitempty"`
-	// Name - READ-ONLY; The name of the resource
-	Name *string `json:"name,omitempty"`
-	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
-	Type *string `json:"type,omitempty"`
-}
-
-// Restriction the restriction because of which SKU cannot be used.
-type Restriction struct {
-	// Type - READ-ONLY; The type of restrictions. As of now only possible value for this is location.
-	Type *string `json:"type,omitempty"`
-	// Values - READ-ONLY; The value of restrictions. If the restriction type is set to location. This would be different locations where the SKU is restricted.
-	Values *[]string `json:"values,omitempty"`
-	// ReasonCode - The reason for the restriction. As of now this can be "QuotaId" or "NotAvailableForSubscription". Quota Id is set when the SKU has requiredQuotas parameter as the subscription does not belong to that quota. The "NotAvailableForSubscription" is related to capacity at DC. Possible values include: 'QuotaID', 'NotAvailableForSubscription'
-	ReasonCode ReasonCode `json:"reasonCode,omitempty"`
-}
-
-// ServiceSasParameters the parameters to list service SAS credentials of a specific resource.
-type ServiceSasParameters struct {
-	// CanonicalizedResource - The canonical path to the signed resource.
-	CanonicalizedResource *string `json:"canonicalizedResource,omitempty"`
-	// Resource - The signed services accessible with the service SAS. Possible values include: Blob (b), Container (c), File (f), Share (s). Possible values include: 'SignedResourceB', 'SignedResourceC', 'SignedResourceF', 'SignedResourceS'
-	Resource SignedResource `json:"signedResource,omitempty"`
-	// Permissions - The signed permissions for the service SAS. Possible values include: Read (r), Write (w), Delete (d), List (l), Add (a), Create (c), Update (u) and Process (p). Possible values include: 'R', 'D', 'W', 'L', 'A', 'C', 'U', 'P'
-	Permissions Permissions `json:"signedPermission,omitempty"`
-	// IPAddressOrRange - An IP address or a range of IP addresses from which to accept requests.
-	IPAddressOrRange *string `json:"signedIp,omitempty"`
-	// Protocols - The protocol permitted for a request made with the account SAS. Possible values include: 'Httpshttp', 'HTTPS'
-	Protocols HTTPProtocol `json:"signedProtocol,omitempty"`
-	// SharedAccessStartTime - The time at which the SAS becomes valid.
-	SharedAccessStartTime *date.Time `json:"signedStart,omitempty"`
-	// SharedAccessExpiryTime - The time at which the shared access signature becomes invalid.
-	SharedAccessExpiryTime *date.Time `json:"signedExpiry,omitempty"`
-	// Identifier - A unique value up to 64 characters in length that correlates to an access policy specified for the container, queue, or table.
-	Identifier *string `json:"signedIdentifier,omitempty"`
-	// PartitionKeyStart - The start of partition key.
-	PartitionKeyStart *string `json:"startPk,omitempty"`
-	// PartitionKeyEnd - The end of partition key.
-	PartitionKeyEnd *string `json:"endPk,omitempty"`
-	// RowKeyStart - The start of row key.
-	RowKeyStart *string `json:"startRk,omitempty"`
-	// RowKeyEnd - The end of row key.
-	RowKeyEnd *string `json:"endRk,omitempty"`
-	// KeyToSign - The key to sign the account SAS token with.
-	KeyToSign *string `json:"keyToSign,omitempty"`
-	// CacheControl - The response header override for cache control.
-	CacheControl *string `json:"rscc,omitempty"`
-	// ContentDisposition - The response header override for content disposition.
-	ContentDisposition *string `json:"rscd,omitempty"`
-	// ContentEncoding - The response header override for content encoding.
-	ContentEncoding *string `json:"rsce,omitempty"`
-	// ContentLanguage - The response header override for content language.
-	ContentLanguage *string `json:"rscl,omitempty"`
-	// ContentType - The response header override for content type.
-	ContentType *string `json:"rsct,omitempty"`
-}
-
-// ServiceSpecification one property of operation, include metric specifications.
-type ServiceSpecification struct {
-	// MetricSpecifications - Metric specifications of operation.
-	MetricSpecifications *[]MetricSpecification `json:"metricSpecifications,omitempty"`
-}
-
-// Sku the SKU of the storage account.
-type Sku struct {
-	// Name - Gets or sets the SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType. Possible values include: 'StandardLRS', 'StandardGRS', 'StandardRAGRS', 'StandardZRS', 'PremiumLRS', 'PremiumZRS'
-	Name SkuName `json:"name,omitempty"`
-	// Tier - READ-ONLY; Gets the SKU tier. This is based on the SKU name. Possible values include: 'Standard', 'Premium'
-	Tier SkuTier `json:"tier,omitempty"`
-	// ResourceType - READ-ONLY; The type of the resource, usually it is 'storageAccounts'.
-	ResourceType *string `json:"resourceType,omitempty"`
-	// Kind - READ-ONLY; Indicates the type of storage account. Possible values include: 'Storage', 'StorageV2', 'BlobStorage', 'FileStorage', 'BlockBlobStorage'
-	Kind Kind `json:"kind,omitempty"`
-	// Locations - READ-ONLY; The set of locations that the SKU is available. This will be supported and registered Azure Geo Regions (e.g. West US, East US, Southeast Asia, etc.).
-	Locations *[]string `json:"locations,omitempty"`
-	// Capabilities - READ-ONLY; The capability information in the specified SKU, including file encryption, network ACLs, change notification, etc.
-	Capabilities *[]SKUCapability `json:"capabilities,omitempty"`
-	// Restrictions - The restrictions because of which SKU cannot be used. This is empty if there are no restrictions.
-	Restrictions *[]Restriction `json:"restrictions,omitempty"`
-}
-
-// SKUCapability the capability information in the specified SKU, including file encryption, network ACLs,
-// change notification, etc.
-type SKUCapability struct {
-	// Name - READ-ONLY; The name of capability, The capability information in the specified SKU, including file encryption, network ACLs, change notification, etc.
-	Name *string `json:"name,omitempty"`
-	// Value - READ-ONLY; A string value to indicate states of given capability. Possibly 'true' or 'false'.
-	Value *string `json:"value,omitempty"`
-}
-
-// SkuListResult the response from the List Storage SKUs operation.
-type SkuListResult struct {
-	autorest.Response `json:"-"`
-	// Value - READ-ONLY; Get the list result of storage SKUs and their properties.
-	Value *[]Sku `json:"value,omitempty"`
-}
-
-// TagProperty a tag of the LegalHold of a blob container.
-type TagProperty struct {
-	// Tag - READ-ONLY; The tag value.
-	Tag *string `json:"tag,omitempty"`
-	// Timestamp - READ-ONLY; Returns the date and time the tag was added.
-	Timestamp *date.Time `json:"timestamp,omitempty"`
-	// ObjectIdentifier - READ-ONLY; Returns the Object ID of the user who added the tag.
-	ObjectIdentifier *string `json:"objectIdentifier,omitempty"`
-	// TenantID - READ-ONLY; Returns the Tenant ID that issued the token for the user who added the tag.
-	TenantID *string `json:"tenantId,omitempty"`
-	// Upn - READ-ONLY; Returns the User Principal Name of the user who added the tag.
-	Upn *string `json:"upn,omitempty"`
-}
-
-// TrackedResource the resource model definition for a ARM tracked top level resource
-type TrackedResource struct {
-	// Tags - Resource tags.
-	Tags map[string]*string `json:"tags"`
-	// Location - The geo-location where the resource lives
-	Location *string `json:"location,omitempty"`
-	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
-	ID *string `json:"id,omitempty"`
-	// Name - READ-ONLY; The name of the resource
-	Name *string `json:"name,omitempty"`
-	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
-	Type *string `json:"type,omitempty"`
-}
-
-// MarshalJSON is the custom marshaler for TrackedResource.
-func (tr TrackedResource) MarshalJSON() ([]byte, error) {
-	objectMap := make(map[string]interface{})
-	if tr.Tags != nil {
-		objectMap["tags"] = tr.Tags
-	}
-	if tr.Location != nil {
-		objectMap["location"] = tr.Location
-	}
-	return json.Marshal(objectMap)
-}
-
-// UpdateHistoryProperty an update history of the ImmutabilityPolicy of a blob container.
-type UpdateHistoryProperty struct {
-	// Update - READ-ONLY; The ImmutabilityPolicy update type of a blob container, possible values include: put, lock and extend. Possible values include: 'Put', 'Lock', 'Extend'
-	Update ImmutabilityPolicyUpdateType `json:"update,omitempty"`
-	// ImmutabilityPeriodSinceCreationInDays - READ-ONLY; The immutability period for the blobs in the container since the policy creation, in days.
-	ImmutabilityPeriodSinceCreationInDays *int32 `json:"immutabilityPeriodSinceCreationInDays,omitempty"`
-	// Timestamp - READ-ONLY; Returns the date and time the ImmutabilityPolicy was updated.
-	Timestamp *date.Time `json:"timestamp,omitempty"`
-	// ObjectIdentifier - READ-ONLY; Returns the Object ID of the user who updated the ImmutabilityPolicy.
-	ObjectIdentifier *string `json:"objectIdentifier,omitempty"`
-	// TenantID - READ-ONLY; Returns the Tenant ID that issued the token for the user who updated the ImmutabilityPolicy.
-	TenantID *string `json:"tenantId,omitempty"`
-	// Upn - READ-ONLY; Returns the User Principal Name of the user who updated the ImmutabilityPolicy.
-	Upn *string `json:"upn,omitempty"`
-}
-
-// Usage describes Storage Resource Usage.
-type Usage struct {
-	// Unit - READ-ONLY; Gets the unit of measurement. Possible values include: 'Count', 'Bytes', 'Seconds', 'Percent', 'CountsPerSecond', 'BytesPerSecond'
-	Unit UsageUnit `json:"unit,omitempty"`
-	// CurrentValue - READ-ONLY; Gets the current count of the allocated resources in the subscription.
-	CurrentValue *int32 `json:"currentValue,omitempty"`
-	// Limit - READ-ONLY; Gets the maximum count of the resources that can be allocated in the subscription.
-	Limit *int32 `json:"limit,omitempty"`
-	// Name - READ-ONLY; Gets the name of the type of usage.
-	Name *UsageName `json:"name,omitempty"`
-}
-
-// UsageListResult the response from the List Usages operation.
-type UsageListResult struct {
-	autorest.Response `json:"-"`
-	// Value - Gets or sets the list of Storage Resource Usages.
-	Value *[]Usage `json:"value,omitempty"`
-}
-
-// UsageName the usage names that can be used; currently limited to StorageAccount.
-type UsageName struct {
-	// Value - READ-ONLY; Gets a string describing the resource name.
-	Value *string `json:"value,omitempty"`
-	// LocalizedValue - READ-ONLY; Gets a localized string describing the resource name.
-	LocalizedValue *string `json:"localizedValue,omitempty"`
-}
-
-// VirtualNetworkRule virtual Network rule.
-type VirtualNetworkRule struct {
-	// VirtualNetworkResourceID - Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
-	VirtualNetworkResourceID *string `json:"id,omitempty"`
-	// Action - The action of virtual network rule. Possible values include: 'Allow'
-	Action Action `json:"action,omitempty"`
-	// State - Gets the state of virtual network rule. Possible values include: 'StateProvisioning', 'StateDeprovisioning', 'StateSucceeded', 'StateFailed', 'StateNetworkSourceDeleted'
-	State State `json:"state,omitempty"`
-}
diff --git a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/operations.go b/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/operations.go
deleted file mode 100644
index bc7d01941..000000000
--- a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/operations.go
+++ /dev/null
@@ -1,109 +0,0 @@
-package storage
-
-// Copyright (c) Microsoft and contributors.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// Code generated by Microsoft (R) AutoRest Code Generator.
-// Changes may cause incorrect behavior and will be lost if the code is regenerated.
-
-import (
-	"context"
-	"github.com/Azure/go-autorest/autorest"
-	"github.com/Azure/go-autorest/autorest/azure"
-	"github.com/Azure/go-autorest/tracing"
-	"net/http"
-)
-
-// OperationsClient is the the Azure Storage Management API.
-type OperationsClient struct {
-	BaseClient
-}
-
-// NewOperationsClient creates an instance of the OperationsClient client.
-func NewOperationsClient(subscriptionID string) OperationsClient {
-	return NewOperationsClientWithBaseURI(DefaultBaseURI, subscriptionID)
-}
-
-// NewOperationsClientWithBaseURI creates an instance of the OperationsClient client using a custom endpoint.  Use this
-// when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
-func NewOperationsClientWithBaseURI(baseURI string, subscriptionID string) OperationsClient {
-	return OperationsClient{NewWithBaseURI(baseURI, subscriptionID)}
-}
-
-// List lists all of the available Storage Rest API operations.
-func (client OperationsClient) List(ctx context.Context) (result OperationListResult, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/OperationsClient.List")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	req, err := client.ListPreparer(ctx)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.OperationsClient", "List", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.ListSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.OperationsClient", "List", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.ListResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.OperationsClient", "List", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// ListPreparer prepares the List request.
-func (client OperationsClient) ListPreparer(ctx context.Context) (*http.Request, error) {
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsGet(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPath("/providers/Microsoft.Storage/operations"),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// ListSender sends the List request. The method will close the
-// http.Response Body if it receives an error.
-func (client OperationsClient) ListSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
-}
-
-// ListResponder handles the response to the List request. The method always
-// closes the http.Response Body.
-func (client OperationsClient) ListResponder(resp *http.Response) (result OperationListResult, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
diff --git a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/skus.go b/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/skus.go
deleted file mode 100644
index 879a4ded4..000000000
--- a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/skus.go
+++ /dev/null
@@ -1,120 +0,0 @@
-package storage
-
-// Copyright (c) Microsoft and contributors.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// Code generated by Microsoft (R) AutoRest Code Generator.
-// Changes may cause incorrect behavior and will be lost if the code is regenerated.
-
-import (
-	"context"
-	"github.com/Azure/go-autorest/autorest"
-	"github.com/Azure/go-autorest/autorest/azure"
-	"github.com/Azure/go-autorest/autorest/validation"
-	"github.com/Azure/go-autorest/tracing"
-	"net/http"
-)
-
-// SkusClient is the the Azure Storage Management API.
-type SkusClient struct {
-	BaseClient
-}
-
-// NewSkusClient creates an instance of the SkusClient client.
-func NewSkusClient(subscriptionID string) SkusClient {
-	return NewSkusClientWithBaseURI(DefaultBaseURI, subscriptionID)
-}
-
-// NewSkusClientWithBaseURI creates an instance of the SkusClient client using a custom endpoint.  Use this when
-// interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
-func NewSkusClientWithBaseURI(baseURI string, subscriptionID string) SkusClient {
-	return SkusClient{NewWithBaseURI(baseURI, subscriptionID)}
-}
-
-// List lists the available SKUs supported by Microsoft.Storage for given subscription.
-func (client SkusClient) List(ctx context.Context) (result SkuListResult, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/SkusClient.List")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.SkusClient", "List", err.Error())
-	}
-
-	req, err := client.ListPreparer(ctx)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.SkusClient", "List", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.ListSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.SkusClient", "List", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.ListResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.SkusClient", "List", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// ListPreparer prepares the List request.
-func (client SkusClient) ListPreparer(ctx context.Context) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"subscriptionId": autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsGet(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/providers/Microsoft.Storage/skus", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// ListSender sends the List request. The method will close the
-// http.Response Body if it receives an error.
-func (client SkusClient) ListSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// ListResponder handles the response to the List request. The method always
-// closes the http.Response Body.
-func (client SkusClient) ListResponder(resp *http.Response) (result SkuListResult, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
diff --git a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/usages.go b/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/usages.go
deleted file mode 100644
index 9397264ce..000000000
--- a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/usages.go
+++ /dev/null
@@ -1,123 +0,0 @@
-package storage
-
-// Copyright (c) Microsoft and contributors.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// Code generated by Microsoft (R) AutoRest Code Generator.
-// Changes may cause incorrect behavior and will be lost if the code is regenerated.
-
-import (
-	"context"
-	"github.com/Azure/go-autorest/autorest"
-	"github.com/Azure/go-autorest/autorest/azure"
-	"github.com/Azure/go-autorest/autorest/validation"
-	"github.com/Azure/go-autorest/tracing"
-	"net/http"
-)
-
-// UsagesClient is the the Azure Storage Management API.
-type UsagesClient struct {
-	BaseClient
-}
-
-// NewUsagesClient creates an instance of the UsagesClient client.
-func NewUsagesClient(subscriptionID string) UsagesClient {
-	return NewUsagesClientWithBaseURI(DefaultBaseURI, subscriptionID)
-}
-
-// NewUsagesClientWithBaseURI creates an instance of the UsagesClient client using a custom endpoint.  Use this when
-// interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
-func NewUsagesClientWithBaseURI(baseURI string, subscriptionID string) UsagesClient {
-	return UsagesClient{NewWithBaseURI(baseURI, subscriptionID)}
-}
-
-// ListByLocation gets the current usage count and the limit for the resources of the location under the subscription.
-// Parameters:
-// location - the location of the Azure Storage resource.
-func (client UsagesClient) ListByLocation(ctx context.Context, location string) (result UsageListResult, err error) {
-	if tracing.IsEnabled() {
-		ctx = tracing.StartSpan(ctx, fqdn+"/UsagesClient.ListByLocation")
-		defer func() {
-			sc := -1
-			if result.Response.Response != nil {
-				sc = result.Response.Response.StatusCode
-			}
-			tracing.EndSpan(ctx, sc, err)
-		}()
-	}
-	if err := validation.Validate([]validation.Validation{
-		{TargetValue: client.SubscriptionID,
-			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
-		return result, validation.NewError("storage.UsagesClient", "ListByLocation", err.Error())
-	}
-
-	req, err := client.ListByLocationPreparer(ctx, location)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.UsagesClient", "ListByLocation", nil, "Failure preparing request")
-		return
-	}
-
-	resp, err := client.ListByLocationSender(req)
-	if err != nil {
-		result.Response = autorest.Response{Response: resp}
-		err = autorest.NewErrorWithError(err, "storage.UsagesClient", "ListByLocation", resp, "Failure sending request")
-		return
-	}
-
-	result, err = client.ListByLocationResponder(resp)
-	if err != nil {
-		err = autorest.NewErrorWithError(err, "storage.UsagesClient", "ListByLocation", resp, "Failure responding to request")
-	}
-
-	return
-}
-
-// ListByLocationPreparer prepares the ListByLocation request.
-func (client UsagesClient) ListByLocationPreparer(ctx context.Context, location string) (*http.Request, error) {
-	pathParameters := map[string]interface{}{
-		"location":       autorest.Encode("path", location),
-		"subscriptionId": autorest.Encode("path", client.SubscriptionID),
-	}
-
-	const APIVersion = "2018-07-01"
-	queryParameters := map[string]interface{}{
-		"api-version": APIVersion,
-	}
-
-	preparer := autorest.CreatePreparer(
-		autorest.AsGet(),
-		autorest.WithBaseURL(client.BaseURI),
-		autorest.WithPathParameters("/subscriptions/{subscriptionId}/providers/Microsoft.Storage/locations/{location}/usages", pathParameters),
-		autorest.WithQueryParameters(queryParameters))
-	return preparer.Prepare((&http.Request{}).WithContext(ctx))
-}
-
-// ListByLocationSender sends the ListByLocation request. The method will close the
-// http.Response Body if it receives an error.
-func (client UsagesClient) ListByLocationSender(req *http.Request) (*http.Response, error) {
-	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
-}
-
-// ListByLocationResponder handles the response to the ListByLocation request. The method always
-// closes the http.Response Body.
-func (client UsagesClient) ListByLocationResponder(resp *http.Response) (result UsageListResult, err error) {
-	err = autorest.Respond(
-		resp,
-		client.ByInspecting(),
-		azure.WithErrorUnlessStatusCode(http.StatusOK),
-		autorest.ByUnmarshallingJSON(&result),
-		autorest.ByClosing())
-	result.Response = autorest.Response{Response: resp}
-	return
-}
diff --git a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/version.go b/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/version.go
deleted file mode 100644
index 057f57065..000000000
--- a/cluster-autoscaler/vendor/github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage/version.go
+++ /dev/null
@@ -1,30 +0,0 @@
-package storage
-
-import "github.com/Azure/azure-sdk-for-go/version"
-
-// Copyright (c) Microsoft and contributors.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// Code generated by Microsoft (R) AutoRest Code Generator.
-// Changes may cause incorrect behavior and will be lost if the code is regenerated.
-
-// UserAgent returns the UserAgent string to use when sending http.Requests.
-func UserAgent() string {
-	return "Azure-SDK-For-Go/" + Version() + " storage/2018-07-01"
-}
-
-// Version returns the semantic version (see http://semver.org) of the client.
-func Version() string {
-	return version.Number
-}
diff --git a/cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/containerserviceclient/mockcontainerserviceclient/doc.go b/cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/containerserviceclient/mockcontainerserviceclient/doc.go
deleted file mode 100644
index 8741385dd..000000000
--- a/cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/containerserviceclient/mockcontainerserviceclient/doc.go
+++ /dev/null
@@ -1,20 +0,0 @@
-// +build !providerless
-
-/*
-Copyright 2020 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-// Package mockcontainerserviceclient implements the mock client for azure container service.
-package mockcontainerserviceclient // import "k8s.io/legacy-cloud-providers/azure/clients/containerserviceclient/mockcontainerserviceclient"
diff --git a/cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/containerserviceclient/mockcontainerserviceclient/interface.go b/cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/containerserviceclient/mockcontainerserviceclient/interface.go
deleted file mode 100644
index 0de4526dd..000000000
--- a/cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/containerserviceclient/mockcontainerserviceclient/interface.go
+++ /dev/null
@@ -1,109 +0,0 @@
-// +build !providerless
-
-/*
-Copyright 2020 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package mockcontainerserviceclient
-
-import (
-	context "context"
-	reflect "reflect"
-
-	containerservice "github.com/Azure/azure-sdk-for-go/services/containerservice/mgmt/2020-04-01/containerservice"
-	gomock "github.com/golang/mock/gomock"
-	retry "k8s.io/legacy-cloud-providers/azure/retry"
-)
-
-// MockInterface is a mock of Interface interface
-type MockInterface struct {
-	ctrl     *gomock.Controller
-	recorder *MockInterfaceMockRecorder
-}
-
-// MockInterfaceMockRecorder is the mock recorder for MockInterface
-type MockInterfaceMockRecorder struct {
-	mock *MockInterface
-}
-
-// NewMockInterface creates a new mock instance
-func NewMockInterface(ctrl *gomock.Controller) *MockInterface {
-	mock := &MockInterface{ctrl: ctrl}
-	mock.recorder = &MockInterfaceMockRecorder{mock}
-	return mock
-}
-
-// EXPECT returns an object that allows the caller to indicate expected use
-func (m *MockInterface) EXPECT() *MockInterfaceMockRecorder {
-	return m.recorder
-}
-
-// CreateOrUpdate mocks base method
-func (m *MockInterface) CreateOrUpdate(ctx context.Context, resourceGroupName, managedClusterName string, parameters containerservice.ManagedCluster, etag string) *retry.Error {
-	m.ctrl.T.Helper()
-	ret := m.ctrl.Call(m, "CreateOrUpdate", ctx, resourceGroupName, managedClusterName, parameters, etag)
-	ret0, _ := ret[0].(*retry.Error)
-	return ret0
-}
-
-// CreateOrUpdate indicates an expected call of CreateOrUpdate
-func (mr *MockInterfaceMockRecorder) CreateOrUpdate(ctx, resourceGroupName, managedClusterName, parameters, etag interface{}) *gomock.Call {
-	mr.mock.ctrl.T.Helper()
-	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdate", reflect.TypeOf((*MockInterface)(nil).CreateOrUpdate), ctx, resourceGroupName, managedClusterName, parameters, etag)
-}
-
-// Delete mocks base method
-func (m *MockInterface) Delete(ctx context.Context, resourceGroupName, managedClusterName string) *retry.Error {
-	m.ctrl.T.Helper()
-	ret := m.ctrl.Call(m, "Delete", ctx, resourceGroupName, managedClusterName)
-	ret0, _ := ret[0].(*retry.Error)
-	return ret0
-}
-
-// Delete indicates an expected call of Delete
-func (mr *MockInterfaceMockRecorder) Delete(ctx, resourceGroupName, managedClusterName interface{}) *gomock.Call {
-	mr.mock.ctrl.T.Helper()
-	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockInterface)(nil).Delete), ctx, resourceGroupName, managedClusterName)
-}
-
-// Get mocks base method
-func (m *MockInterface) Get(ctx context.Context, resourceGroupName, managedClusterName string) (containerservice.ManagedCluster, *retry.Error) {
-	m.ctrl.T.Helper()
-	ret := m.ctrl.Call(m, "Get", ctx, resourceGroupName, managedClusterName)
-	ret0, _ := ret[0].(containerservice.ManagedCluster)
-	ret1, _ := ret[1].(*retry.Error)
-	return ret0, ret1
-}
-
-// Get indicates an expected call of Get
-func (mr *MockInterfaceMockRecorder) Get(ctx, resourceGroupName, managedClusterName interface{}) *gomock.Call {
-	mr.mock.ctrl.T.Helper()
-	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockInterface)(nil).Get), ctx, resourceGroupName, managedClusterName)
-}
-
-// List mocks base method
-func (m *MockInterface) List(ctx context.Context, resourceGroupName string) ([]containerservice.ManagedCluster, *retry.Error) {
-	m.ctrl.T.Helper()
-	ret := m.ctrl.Call(m, "List", ctx, resourceGroupName)
-	ret0, _ := ret[0].([]containerservice.ManagedCluster)
-	ret1, _ := ret[1].(*retry.Error)
-	return ret0, ret1
-}
-
-// List indicates an expected call of List
-func (mr *MockInterfaceMockRecorder) List(ctx, resourceGroupName interface{}) *gomock.Call {
-	mr.mock.ctrl.T.Helper()
-	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockInterface)(nil).List), ctx, resourceGroupName)
-}
diff --git a/cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient/mockstorageaccountclient/doc.go b/cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient/mockstorageaccountclient/doc.go
deleted file mode 100644
index 907a8e77b..000000000
--- a/cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient/mockstorageaccountclient/doc.go
+++ /dev/null
@@ -1,20 +0,0 @@
-// +build !providerless
-
-/*
-Copyright 2020 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-// Package mockstorageaccountclient implements the mock client for StorageAccounts.
-package mockstorageaccountclient // import "k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient/mockstorageaccountclient"
diff --git a/cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient/mockstorageaccountclient/interface.go b/cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient/mockstorageaccountclient/interface.go
deleted file mode 100644
index 45e8654ca..000000000
--- a/cluster-autoscaler/vendor/k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient/mockstorageaccountclient/interface.go
+++ /dev/null
@@ -1,123 +0,0 @@
-// +build !providerless
-
-/*
-Copyright 2020 The Kubernetes Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package mockstorageaccountclient
-
-import (
-	context "context"
-	storage "github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2019-06-01/storage"
-	gomock "github.com/golang/mock/gomock"
-	retry "k8s.io/legacy-cloud-providers/azure/retry"
-	reflect "reflect"
-)
-
-// MockInterface is a mock of Interface interface
-type MockInterface struct {
-	ctrl     *gomock.Controller
-	recorder *MockInterfaceMockRecorder
-}
-
-// MockInterfaceMockRecorder is the mock recorder for MockInterface
-type MockInterfaceMockRecorder struct {
-	mock *MockInterface
-}
-
-// NewMockInterface creates a new mock instance
-func NewMockInterface(ctrl *gomock.Controller) *MockInterface {
-	mock := &MockInterface{ctrl: ctrl}
-	mock.recorder = &MockInterfaceMockRecorder{mock}
-	return mock
-}
-
-// EXPECT returns an object that allows the caller to indicate expected use
-func (m *MockInterface) EXPECT() *MockInterfaceMockRecorder {
-	return m.recorder
-}
-
-// Create mocks base method
-func (m *MockInterface) Create(ctx context.Context, resourceGroupName, accountName string, parameters storage.AccountCreateParameters) *retry.Error {
-	m.ctrl.T.Helper()
-	ret := m.ctrl.Call(m, "Create", ctx, resourceGroupName, accountName, parameters)
-	ret0, _ := ret[0].(*retry.Error)
-	return ret0
-}
-
-// Create indicates an expected call of Create
-func (mr *MockInterfaceMockRecorder) Create(ctx, resourceGroupName, accountName, parameters interface{}) *gomock.Call {
-	mr.mock.ctrl.T.Helper()
-	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockInterface)(nil).Create), ctx, resourceGroupName, accountName, parameters)
-}
-
-// Delete mocks base method
-func (m *MockInterface) Delete(ctx context.Context, resourceGroupName, accountName string) *retry.Error {
-	m.ctrl.T.Helper()
-	ret := m.ctrl.Call(m, "Delete", ctx, resourceGroupName, accountName)
-	ret0, _ := ret[0].(*retry.Error)
-	return ret0
-}
-
-// Delete indicates an expected call of Delete
-func (mr *MockInterfaceMockRecorder) Delete(ctx, resourceGroupName, accountName interface{}) *gomock.Call {
-	mr.mock.ctrl.T.Helper()
-	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockInterface)(nil).Delete), ctx, resourceGroupName, accountName)
-}
-
-// ListKeys mocks base method
-func (m *MockInterface) ListKeys(ctx context.Context, resourceGroupName, accountName string) (storage.AccountListKeysResult, *retry.Error) {
-	m.ctrl.T.Helper()
-	ret := m.ctrl.Call(m, "ListKeys", ctx, resourceGroupName, accountName)
-	ret0, _ := ret[0].(storage.AccountListKeysResult)
-	ret1, _ := ret[1].(*retry.Error)
-	return ret0, ret1
-}
-
-// ListKeys indicates an expected call of ListKeys
-func (mr *MockInterfaceMockRecorder) ListKeys(ctx, resourceGroupName, accountName interface{}) *gomock.Call {
-	mr.mock.ctrl.T.Helper()
-	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListKeys", reflect.TypeOf((*MockInterface)(nil).ListKeys), ctx, resourceGroupName, accountName)
-}
-
-// ListByResourceGroup mocks base method
-func (m *MockInterface) ListByResourceGroup(ctx context.Context, resourceGroupName string) ([]storage.Account, *retry.Error) {
-	m.ctrl.T.Helper()
-	ret := m.ctrl.Call(m, "ListByResourceGroup", ctx, resourceGroupName)
-	ret0, _ := ret[0].([]storage.Account)
-	ret1, _ := ret[1].(*retry.Error)
-	return ret0, ret1
-}
-
-// ListByResourceGroup indicates an expected call of ListByResourceGroup
-func (mr *MockInterfaceMockRecorder) ListByResourceGroup(ctx, resourceGroupName interface{}) *gomock.Call {
-	mr.mock.ctrl.T.Helper()
-	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListByResourceGroup", reflect.TypeOf((*MockInterface)(nil).ListByResourceGroup), ctx, resourceGroupName)
-}
-
-// GetProperties mocks base method
-func (m *MockInterface) GetProperties(ctx context.Context, resourceGroupName, accountName string) (storage.Account, *retry.Error) {
-	m.ctrl.T.Helper()
-	ret := m.ctrl.Call(m, "GetProperties", ctx, resourceGroupName, accountName)
-	ret0, _ := ret[0].(storage.Account)
-	ret1, _ := ret[1].(*retry.Error)
-	return ret0, ret1
-}
-
-// GetProperties indicates an expected call of GetProperties
-func (mr *MockInterfaceMockRecorder) GetProperties(ctx, resourceGroupName, accountName interface{}) *gomock.Call {
-	mr.mock.ctrl.T.Helper()
-	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProperties", reflect.TypeOf((*MockInterface)(nil).GetProperties), ctx, resourceGroupName, accountName)
-}
diff --git a/cluster-autoscaler/vendor/modules.txt b/cluster-autoscaler/vendor/modules.txt
index 94a51e171..404ea258f 100644
--- a/cluster-autoscaler/vendor/modules.txt
+++ b/cluster-autoscaler/vendor/modules.txt
@@ -2,13 +2,11 @@
 ## explicit
 cloud.google.com/go/compute/metadata
 # github.com/Azure/azure-sdk-for-go v43.0.0+incompatible
-## explicit
 github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2019-12-01/compute
 github.com/Azure/azure-sdk-for-go/services/containerregistry/mgmt/2019-05-01/containerregistry
 github.com/Azure/azure-sdk-for-go/services/containerservice/mgmt/2020-04-01/containerservice
 github.com/Azure/azure-sdk-for-go/services/network/mgmt/2019-06-01/network
 github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2017-05-10/resources
-github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2018-07-01/storage
 github.com/Azure/azure-sdk-for-go/services/storage/mgmt/2019-06-01/storage
 github.com/Azure/azure-sdk-for-go/storage
 github.com/Azure/azure-sdk-for-go/version
@@ -18,19 +16,15 @@ github.com/Azure/go-ansiterm/winterm
 # github.com/Azure/go-autorest v14.2.0+incompatible
 github.com/Azure/go-autorest
 # github.com/Azure/go-autorest/autorest v0.11.12
-## explicit
 github.com/Azure/go-autorest/autorest
 github.com/Azure/go-autorest/autorest/azure
 # github.com/Azure/go-autorest/autorest/adal v0.9.5
-## explicit
 github.com/Azure/go-autorest/autorest/adal
 # github.com/Azure/go-autorest/autorest/date v0.3.0
-## explicit
 github.com/Azure/go-autorest/autorest/date
 # github.com/Azure/go-autorest/autorest/mocks v0.4.1
 github.com/Azure/go-autorest/autorest/mocks
 # github.com/Azure/go-autorest/autorest/to v0.2.0
-## explicit
 github.com/Azure/go-autorest/autorest/to
 # github.com/Azure/go-autorest/autorest/validation v0.1.0
 github.com/Azure/go-autorest/autorest/validation
@@ -263,7 +257,6 @@ github.com/gogo/protobuf/types
 # github.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e
 github.com/golang/groupcache/lru
 # github.com/golang/mock v1.4.4
-## explicit
 github.com/golang/mock/gomock
 # github.com/golang/protobuf v1.4.3
 github.com/golang/protobuf/proto
@@ -618,7 +611,6 @@ go.uber.org/zap/internal/color
 go.uber.org/zap/internal/exit
 go.uber.org/zap/zapcore
 # golang.org/x/crypto v0.0.0-20210220033148-5ea612d1eb83
-## explicit
 golang.org/x/crypto/cryptobyte
 golang.org/x/crypto/cryptobyte/asn1
 golang.org/x/crypto/ed25519
@@ -1695,7 +1687,6 @@ k8s.io/legacy-cloud-providers/azure/cache
 k8s.io/legacy-cloud-providers/azure/clients
 k8s.io/legacy-cloud-providers/azure/clients/armclient
 k8s.io/legacy-cloud-providers/azure/clients/containerserviceclient
-k8s.io/legacy-cloud-providers/azure/clients/containerserviceclient/mockcontainerserviceclient
 k8s.io/legacy-cloud-providers/azure/clients/deploymentclient
 k8s.io/legacy-cloud-providers/azure/clients/diskclient
 k8s.io/legacy-cloud-providers/azure/clients/diskclient/mockdiskclient
@@ -1714,7 +1705,6 @@ k8s.io/legacy-cloud-providers/azure/clients/securitygroupclient
 k8s.io/legacy-cloud-providers/azure/clients/securitygroupclient/mocksecuritygroupclient
 k8s.io/legacy-cloud-providers/azure/clients/snapshotclient
 k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient
-k8s.io/legacy-cloud-providers/azure/clients/storageaccountclient/mockstorageaccountclient
 k8s.io/legacy-cloud-providers/azure/clients/subnetclient
 k8s.io/legacy-cloud-providers/azure/clients/subnetclient/mocksubnetclient
 k8s.io/legacy-cloud-providers/azure/clients/vmclient
-- 
2.39.0

