From 7ae41ea914476b6f001d3028eb9c3376f820e206 Mon Sep 17 00:00:00 2001
From: Rahul Ganesh <rahulgab@amazon.com>
Date: Wed, 1 Oct 2025 15:51:27 -0700
Subject: [PATCH 1/1] Add retries around Mount action

Sometimes the block devices takes some time to load up eventhough
the disk is already available. This could potentially be due to
udev/mdev still loding up the devices. This change adds retries around
the mount action and keeps trying for 5 minutes to see if the device
becomes available.

Signed-off-by: Rahul Ganesh <rahulgab@amazon.com>
---
 writefile/main.go | 34 ++++++++++++++++++++++++++++++++--
 1 file changed, 32 insertions(+), 2 deletions(-)

diff --git a/writefile/main.go b/writefile/main.go
index 3d47ad8..0a11ca1 100644
--- a/writefile/main.go
+++ b/writefile/main.go
@@ -1,6 +1,7 @@
 package main
 
 import (
+	"context"
 	"errors"
 	"fmt"
 	"log/slog"
@@ -9,6 +10,7 @@ import (
 	"strconv"
 	"strings"
 	"syscall"
+	"time"
 
 	log "github.com/sirupsen/logrus"
 )
@@ -80,9 +82,21 @@ func main() {
 		os.Exit(1)
 	}
 
+	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
+	defer cancel()
+
+	// Sometimes the device takes time to load even though the disk is available
+	// This could potentially be due to udev/mdev still loading up the drivers
 	// Mount the block device to the /mountAction point
-	if err := syscall.Mount(blockDevice, mountAction, filesystemType, 0, ""); err != nil {
-		logger.Error("Mounting block device", "blockDevice", blockDevice, "mountAction", mountAction, "error", err)
+	err = Retry(ctx, 30, 10*time.Second, func() error {
+		return syscall.Mount(blockDevice, mountAction, filesystemType, 0, "")
+	})
+	if err != nil {
+		if errors.Is(err, context.DeadlineExceeded) {
+			logger.Error("Timed out waiting for mount action")
+		} else {
+			logger.Error("Operation failed after retries: Mounting [%s] -> [%s]: %v", blockDevice, mountAction, err)
+		}
 		os.Exit(1)
 	}
 	defer func() {
@@ -132,6 +146,22 @@ func dirExists(mountPath, path string) (bool, error) {
 	return !os.IsNotExist(err), nil
 }
 
+func Retry(ctx context.Context, attempts int, sleep time.Duration, fn func() error) error {
+	var err error
+	for i := 0; i < attempts; i++ {
+		if err = fn(); err == nil {
+			return nil
+		}
+		select {
+		case <-ctx.Done():
+			return ctx.Err()
+		case <-time.After(sleep):
+			continue
+		}
+	}
+	return err
+}
+
 func recursiveEnsureDir(mountPath, path string, mode os.FileMode, uid, gid int) error {
 	// Does the directory already exist? If so we can return early
 	exists, err := dirExists(mountPath, path)
-- 
2.46.0

